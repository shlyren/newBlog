{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/apple-touch-icon.png","path":"apple-touch-icon.png","modified":0,"renderable":0},{"_id":"source/favicon.ico","path":"favicon.ico","modified":0,"renderable":0},{"_id":"themes/maupassant/source/apple-touch-icon.png","path":"apple-touch-icon.png","modified":0,"renderable":1},{"_id":"themes/maupassant/source/favicon.ico","path":"favicon.ico","modified":0,"renderable":1},{"_id":"themes/maupassant/source/css/style.scss","path":"css/style.scss","modified":0,"renderable":1},{"_id":"themes/maupassant/source/css/jquery.fancybox.css","path":"css/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/codeblock-resizer.js","path":"js/codeblock-resizer.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/search.js","path":"js/search.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/fancybox.js","path":"js/fancybox.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/share.js","path":"js/share.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/smartresize.js","path":"js/smartresize.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/totop.js","path":"js/totop.js","modified":0,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"7c9dac7ce24f1afe046e0b42318e97abb4ba03f7","modified":1502354846000},{"_id":"source/apple-touch-icon.png","hash":"b49227f3c0fd2f69986e29dbc6d979676f936cf4","modified":1502354838000},{"_id":"source/favicon.ico","hash":"0ae94c565ad90270da76efec1fa004cfab0a8c33","modified":1502355753000},{"_id":"themes/maupassant/.DS_Store","hash":"2e84313b9cd8e7b34fb3940942f9771edc50959b","modified":1502354888000},{"_id":"themes/maupassant/.travis.yml","hash":"0339959f29deddc365e8fe8bd85da524410b9a23","modified":1493357784000},{"_id":"themes/maupassant/LICENSE","hash":"f0ac2f92770650c9835183f79010c0d307b34acd","modified":1493357784000},{"_id":"themes/maupassant/README.md","hash":"e26c4306cd3f936a2e9b334e947f99feb8e243c0","modified":1493357784000},{"_id":"themes/maupassant/_config.yml","hash":"f4289fbda2aca16a2d34d061bcc24c4ead5782d6","modified":1502355091000},{"_id":"themes/maupassant/package.json","hash":"81fb4e2ac051ecfb9a93f37b28910291b939771a","modified":1493357784000},{"_id":"source/_posts/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1501813018000},{"_id":"source/_posts/2017.md","hash":"2f6f45a59159b785fd6afd782fa18b28fb9e199f","modified":1493368412000},{"_id":"source/_posts/Android-Activity.md","hash":"4ee897a93a0da77072f5753360e4b48b5254dd7c","modified":1486710913000},{"_id":"source/_posts/Android-fragment.md","hash":"944b168e38caf61be0567a1530963dbcfef09df1","modified":1490328179000},{"_id":"source/_posts/C语言的几种排序方法.md","hash":"93159ad4a54ca82576182171817b9fe4ed8aa7d0","modified":1490859865000},{"_id":"source/_posts/IOS学习之作业篇(OC).md","hash":"c55e28edff0c2cd582478afe604e0e099a90b955","modified":1493368750000},{"_id":"source/_posts/OC基本概念.md","hash":"33c4230aca327ca3e39224c2e7b3f2cc393e36b9","modified":1493368899000},{"_id":"source/_posts/SVN常用命令.md","hash":"18b29ed6247ca968ca1a810659bd1772d54cdea4","modified":1494897521000},{"_id":"source/_posts/Swift学习笔记01.md","hash":"c0979dcef4922bd85d49732683605dd502e21ea5","modified":1493368908000},{"_id":"source/_posts/Swift学习笔记02.md","hash":"20a2f181a367a7d229e9acf41a6e583a5a9df608","modified":1493368812000},{"_id":"source/_posts/Swift学习笔记03.md","hash":"920c67b9c68f3dd9dab9c4b505078a17ba03b6e3","modified":1493368817000},{"_id":"source/_posts/Terminal命令之wget用法.md","hash":"ab592b8c2d8ae2fbd1734a1c59845e7d41a36c36","modified":1493281312000},{"_id":"source/_posts/UIScrollView-Category-error-message-with-deallocated-instance.md","hash":"4502bc81119f71e6c1798b74f1244569f05fdc29","modified":1492069906000},{"_id":"source/_posts/Ubuntu更新Nginx服务.md","hash":"91219f16f3b724aa43a8fdd66f18f63305e3f17c","modified":1493368835000},{"_id":"source/_posts/android-基本概念.md","hash":"d458915aea64658a916d002128ea95900996509e","modified":1492765856000},{"_id":"source/_posts/const-static-extern简介.md","hash":"db9df733ea10bd10c37d2fb5074206212dd1a993","modified":1493368921000},{"_id":"source/_posts/https使用网易音乐外链播放器无法播放.md","hash":"93a195a5aec8708017c1cdf453acd234eac7bfca","modified":1493368672000},{"_id":"source/_posts/install-VPN-on-your-vps.md","hash":"6ef609e355030bafd90dda36ed9fd3a1bf756a4d","modified":1493368734000},{"_id":"source/_posts/install-hexo-on-vps-and-update-with-git.md","hash":"c2505fff81dec55d1c05b44b82a106c975a663ff","modified":1493368691000},{"_id":"source/_posts/install-huno-theme.md","hash":"09d6e538109d0cab46c3ff385088e3e3c207a914","modified":1493368706000},{"_id":"source/_posts/install-shadowsocks-on-your-vps.md","hash":"b8cb1e49b3bd35b23e173bc750b5d0defa89b699","modified":1493368722000},{"_id":"source/_posts/javaScript基础.md","hash":"e05f02460a627c520c84c00af32a2a7cf1daef46","modified":1495420621000},{"_id":"source/_posts/learn-Android.md","hash":"08883bacabcb211d6db1bf677dbe910a182ac4ee","modified":1486630897000},{"_id":"source/_posts/linux常用命令.md","hash":"2d3e6e73b531a2ec5cb6e4bc49787c293b876136","modified":1492151687000},{"_id":"source/_posts/runtime.md","hash":"730d085bca1d0af4bb495ca65a105a969f8480b3","modified":1493368936000},{"_id":"source/_posts/short-haired-girl-is-also-good.md","hash":"f17dd4929ec9a7f2699133ba2297bb264a4f25ae","modified":1493368930000},{"_id":"source/_posts/use-gem-update-with-error.md","hash":"84ee124f35d52f0d9ea06da69a6d97e0fd8af452","modified":1492070474000},{"_id":"source/_posts/use-hexo-on-aliyun-and-update-with-git.md","hash":"13f4f979044a019a92f4faf95ef85011ef840682","modified":1493368859000},{"_id":"source/_posts/利用pods给你的程序添加第三方库.md","hash":"f08489a90783f3213aecdb86f8665b5b776ca7fe","modified":1493368483000},{"_id":"source/_posts/命令安装Mac系统.md","hash":"3a4b68405f251e00db05d20c478e53ffe555fac1","modified":1493368573000},{"_id":"source/_posts/命令给安卓程序打包.md","hash":"90183f13cfe847513cb4c8cd6b8aa3b8b844d541","modified":1493368582000},{"_id":"source/_posts/在Mac上配置Rect-Native开发环境.md","hash":"100064a6413248779a785a7ef10bd25d46dfceb3","modified":1493368603000},{"_id":"source/_posts/多线程.md","hash":"456a21b60cc0684d99bd617e9ca2055209341b7f","modified":1493368443000},{"_id":"source/_posts/很久以前.md","hash":"90b44144c1343287fcd50df64a732425a2949aad","modified":1493778518000},{"_id":"source/_posts/撩妹招数.md","hash":"145bb95332b1c1db5b45c8e515ca10be2e2cf2bb","modified":1493368532000},{"_id":"source/_posts/着手写一个APP.md","hash":"625fd102143c977e24c9eda43573653354fc1d8b","modified":1493368629000},{"_id":"source/_posts/面试题-01.md","hash":"1fb1f4d15ded803b7fc4fa1b3f3ab0b44f29adf3","modified":1493368546000},{"_id":"source/about/index.md","hash":"d1188e6948bfbe2a4008092b9504aedc5f1c071d","modified":1495684947000},{"_id":"source/archive/index.md","hash":"5470e5e74b1f79da2d2eebdecb57a503514aa2c4","modified":1480642576000},{"_id":"themes/maupassant/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1493357784000},{"_id":"themes/maupassant/.git/.DS_Store","hash":"1b0db719e2021e0adbaf96f29b7b23009488fc2b","modified":1493366066000},{"_id":"themes/maupassant/.git/config","hash":"037345b11c41abb3dbbbd6e0242ced24979a7097","modified":1493357784000},{"_id":"themes/maupassant/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1493357777000},{"_id":"themes/maupassant/.git/index","hash":"eafef1349c50712fa04a0a14d14c291b0c454a72","modified":1495684758000},{"_id":"themes/maupassant/.git/packed-refs","hash":"f65b7023b196b4120ce7d383c285fd0e21bcc670","modified":1493357784000},{"_id":"themes/maupassant/languages/de-DE.yml","hash":"5d3556a885e355a8c2da65ef3e7b3ee36a628bfa","modified":1493357784000},{"_id":"themes/maupassant/languages/en.yml","hash":"e8887110dd01c4b6c41493b661b433b6b579b110","modified":1493357784000},{"_id":"themes/maupassant/languages/es-ES.yml","hash":"58e1d04bcd1834fa9d2960e18e027abbbccbedc9","modified":1493357784000},{"_id":"themes/maupassant/languages/fr-FR.yml","hash":"b47906ec0abf867fb3e3360bc046b7afb68aee25","modified":1493357784000},{"_id":"themes/maupassant/languages/ko.yml","hash":"909a33e0befa6978e8e72157c6b415b48551ee31","modified":1493357784000},{"_id":"themes/maupassant/languages/ru.yml","hash":"2476a631f4d3c668de04af85a6c2c97ba2a57e96","modified":1493357784000},{"_id":"themes/maupassant/languages/zh-CN.yml","hash":"ec5c4b2667bb0cceb7fd0934ebe8631d6a701018","modified":1493357784000},{"_id":"themes/maupassant/languages/zh-TW.yml","hash":"17b22e638fd21ab16d4c156b22f8c89ececad9f5","modified":1493357784000},{"_id":"themes/maupassant/layout/.DS_Store","hash":"8f56c2d94378c7f3cb650760ca2cf8cb0362330d","modified":1493366066000},{"_id":"themes/maupassant/layout/archive.jade","hash":"0050c883b4f202add71c8664d65e6072179e7190","modified":1493357784000},{"_id":"themes/maupassant/layout/base-without-sidebar.jade","hash":"60b5a70f7c61c91aca9fbf813bde26096ef4028f","modified":1493357784000},{"_id":"themes/maupassant/layout/base.jade","hash":"41f3a0f5e3c5b722de9d058c458822e5122384e1","modified":1493357784000},{"_id":"themes/maupassant/layout/index.jade","hash":"c6d0f760df9a5f02aaeddc16a5eb3494f044eaa9","modified":1493693601000},{"_id":"themes/maupassant/layout/page.jade","hash":"8d70fd3b93f2c9087a9ea7ec538dcc1d413bea01","modified":1493357784000},{"_id":"themes/maupassant/layout/post.jade","hash":"88dcb72e5444aa39c90cd8d6e499525546a5a95b","modified":1493357784000},{"_id":"themes/maupassant/layout/single-column.jade","hash":"c35fff4d9b331a41af5bc10f4278ec3d9da503db","modified":1493357784000},{"_id":"themes/maupassant/layout/timeline.jade","hash":"649281ace58d7ff08a6ecb10606799ae2f77bb38","modified":1493357784000},{"_id":"themes/maupassant/source/.DS_Store","hash":"2f4964749c19ed9b07239204f7965a47ba8a6cb0","modified":1502355787000},{"_id":"themes/maupassant/source/apple-touch-icon.png","hash":"b49227f3c0fd2f69986e29dbc6d979676f936cf4","modified":1502354838000},{"_id":"themes/maupassant/source/favicon.ico","hash":"0ae94c565ad90270da76efec1fa004cfab0a8c33","modified":1502355753000},{"_id":"themes/maupassant/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1493357777000},{"_id":"themes/maupassant/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1493357777000},{"_id":"themes/maupassant/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1493357777000},{"_id":"themes/maupassant/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1493357777000},{"_id":"themes/maupassant/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1493357777000},{"_id":"themes/maupassant/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1493357777000},{"_id":"themes/maupassant/.git/hooks/pre-rebase.sample","hash":"5885a56ab4fca8075a05a562d005e922cde9853b","modified":1493357777000},{"_id":"themes/maupassant/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1493357777000},{"_id":"themes/maupassant/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1493357777000},{"_id":"themes/maupassant/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1493357777000},{"_id":"themes/maupassant/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1493357777000},{"_id":"themes/maupassant/.git/logs/.DS_Store","hash":"b34f32675fed1652085868b514c04dbd509a1058","modified":1493365990000},{"_id":"themes/maupassant/.git/logs/HEAD","hash":"5caf1c50e5c02d36bf2ed1ab95df56d40b55bdd6","modified":1493357784000},{"_id":"themes/maupassant/.git/objects/.DS_Store","hash":"e68c24cd36a530422452d3f7fed077f4f8862487","modified":1493365990000},{"_id":"themes/maupassant/.git/refs/.DS_Store","hash":"8c10321914050391e06922823eb21c2b64911832","modified":1493365990000},{"_id":"themes/maupassant/layout/_partial/after_footer.jade","hash":"f5f9bf483b328aa5ca72b9cf76bd9d561ad11fd4","modified":1493873085000},{"_id":"themes/maupassant/layout/_partial/comments.jade","hash":"5d23b3975e98ad12ebb8c2f3f96db1ef72fcbd9d","modified":1493361032000},{"_id":"themes/maupassant/layout/_partial/footer.jade","hash":"a0a2140b57adb5c311f795fe2640455a6c31e21a","modified":1494927415000},{"_id":"themes/maupassant/layout/_partial/head.jade","hash":"74585fd208f074cae496274cb3a656925915ed8a","modified":1493357784000},{"_id":"themes/maupassant/layout/_partial/helpers.jade","hash":"acdf9e2d52ee86c831fa15ce1570930c5779bc78","modified":1493357784000},{"_id":"themes/maupassant/layout/_partial/mathjax.jade","hash":"b54b56faff9e47ab3ca3cdd55056c73e60776f3c","modified":1493357784000},{"_id":"themes/maupassant/layout/_partial/mathjax2.jade","hash":"d6ac5dc4e9c7a1b866f1f92d88988cfb35aded4c","modified":1493357784000},{"_id":"themes/maupassant/layout/_partial/paginator.jade","hash":"53f9cb77448e84a98da5eb688e2e12b173c555bb","modified":1493357784000},{"_id":"themes/maupassant/layout/_partial/post_nav.jade","hash":"a2d698c84bb6da08195fe870dbd7215f65388d3f","modified":1493357784000},{"_id":"themes/maupassant/layout/_partial/tag.jade","hash":"0f0e6770e9d5dd8040e330d71bbbfadd2df36a28","modified":1493357784000},{"_id":"themes/maupassant/layout/_partial/totop.jade","hash":"8225bbc3cdb9648bc2e6872e5c616a9a1e4def4f","modified":1493357784000},{"_id":"themes/maupassant/layout/_widget/category.jade","hash":"7c6aed762934ca51aa2669b886254da24b77bc14","modified":1493357784000},{"_id":"themes/maupassant/layout/_widget/links.jade","hash":"f57a0c76d243882b2b77330132bdb43bc648948b","modified":1493357784000},{"_id":"themes/maupassant/layout/_widget/recent_comments.jade","hash":"e119c5afa85abc60d139e2da99b0bfcd7a6530f8","modified":1493357784000},{"_id":"themes/maupassant/layout/_widget/recent_posts.jade","hash":"19431336d724d2118e46da43683bce9063176541","modified":1493357784000},{"_id":"themes/maupassant/layout/_widget/search.jade","hash":"0a19bbae2508823137674aa041051acff79349f6","modified":1493360635000},{"_id":"themes/maupassant/layout/_widget/tag.jade","hash":"132f049ce677d0e38f50073174c4ee4b825d4a06","modified":1493357784000},{"_id":"themes/maupassant/source/css/style.scss","hash":"d8cb18ba798ec5e1128551de7c5f340fb72602cf","modified":1493357784000},{"_id":"themes/maupassant/source/css/jquery.fancybox.css","hash":"f42f761157f26244673eb2f4a9215c70956f80dc","modified":1493357784000},{"_id":"themes/maupassant/source/js/codeblock-resizer.js","hash":"5d0b786d60bf225d9eabcc9cece2719ff4d9b6cd","modified":1493357784000},{"_id":"themes/maupassant/source/js/search.js","hash":"0c0630e2ef213701d393b041f10572e951a27985","modified":1493357784000},{"_id":"themes/maupassant/source/js/fancybox.js","hash":"13c4781570339f4fba76a3d7f202e442817dd605","modified":1493357784000},{"_id":"themes/maupassant/source/js/share.js","hash":"6400d719d5eb14587d854a3dff6b290a3c06dc67","modified":1493357784000},{"_id":"themes/maupassant/source/js/smartresize.js","hash":"3ef157fd877167e3290f42c67a624ea375a46c24","modified":1493357784000},{"_id":"themes/maupassant/source/js/totop.js","hash":"7dbf8fcf582a4fb6eb9b2c60d6de9f9c2091ec4c","modified":1493357784000},{"_id":"themes/maupassant/.git/objects/pack/pack-7a21926d954013836781e270b8ba87ac6a70b4b3.idx","hash":"3bbdecfd8920c24b153a7ba56ac853998d539e1d","modified":1493357784000},{"_id":"themes/maupassant/.git/refs/heads/master","hash":"e0b60c071d675166305d8bfb41a642ddcd3bbcdb","modified":1493357784000},{"_id":"themes/maupassant/.git/logs/refs/heads/master","hash":"5caf1c50e5c02d36bf2ed1ab95df56d40b55bdd6","modified":1493357784000},{"_id":"themes/maupassant/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1493357784000},{"_id":"themes/maupassant/.git/logs/refs/remotes/origin/HEAD","hash":"5caf1c50e5c02d36bf2ed1ab95df56d40b55bdd6","modified":1493357784000},{"_id":"themes/maupassant/.git/objects/pack/pack-7a21926d954013836781e270b8ba87ac6a70b4b3.pack","hash":"32b9218cbd30d720e849ca3519ef3e8648eb873b","modified":1493357784000},{"_id":"public/sitemap.xml","hash":"f522f7922ff4eaee754ee01f54c37076ff87dfa9","modified":1502356503475},{"_id":"public/atom.xml","hash":"b25b749192f195959db506df5707a145622c2380","modified":1502356503496},{"_id":"public/about/index.html","hash":"90a3e8dd1a4cba951989b30f6af3dd0285b837f7","modified":1502356503512},{"_id":"public/archive/index.html","hash":"75a67cc7a481b999e67adaf24e3679d882b75525","modified":1502356503512},{"_id":"public/2017/05/22/javaScript基础/index.html","hash":"7b02ed93ecd4ff0a79f3cbafebfed061d67ad553","modified":1502356503512},{"_id":"public/2017/05/16/SVN常用命令/index.html","hash":"5b3783e0e0c1694910232db4691d2f8112879a90","modified":1502356503512},{"_id":"public/2017/04/27/Terminal命令之wget用法/index.html","hash":"642a7b6efc7007c8b008156e65540e796f93b76d","modified":1502356503513},{"_id":"public/2017/04/12/命令给安卓程序打包/index.html","hash":"861e18c1626b5980fe4c92d35f5da10fe9387408","modified":1502356503513},{"_id":"public/2017/03/31/linux常用命令/index.html","hash":"1a9ecc36b1921b3335d1f440577ba3465171e2c8","modified":1502356503513},{"_id":"public/2017/03/30/Ubuntu更新Nginx服务/index.html","hash":"4c46dd90d71772c91bf0e67505d20c77e895a6d7","modified":1502356503513},{"_id":"public/2017/03/30/在Mac上配置Rect-Native开发环境/index.html","hash":"68c24cd80f167f535bfcc12e6b302704d69b26d4","modified":1502356503514},{"_id":"public/2017/03/30/OC基本概念/index.html","hash":"0c867bb2b21b3a96d23b71ac86c9b44612d95fd2","modified":1502356503514},{"_id":"public/2017/03/30/install-shadowsocks-on-your-vps/index.html","hash":"ab0555708aa4bd5d8fa058504cdc18b8374b6a8c","modified":1502356503514},{"_id":"public/2017/03/24/Android-fragment/index.html","hash":"576ba390c59d9b1a3e5061b5f8f33b9ed0450c3b","modified":1502356503514},{"_id":"public/2017/03/24/android-基本概念/index.html","hash":"8a002dd8006eacca4d5abb5f49a910ecc504865a","modified":1502356503514},{"_id":"public/2017/02/10/Android-Activity/index.html","hash":"bf5c2727e242d12a620e54cfa52c4ec9eee74b1d","modified":1502356503515},{"_id":"public/2017/02/09/learn-Android/index.html","hash":"37a18a6196950b3178e6a836059868178e44098b","modified":1502356503515},{"_id":"public/2017/01/28/2017/index.html","hash":"940930a66347184332d10a1efc40e73f36386f3b","modified":1502356503515},{"_id":"public/2017/01/16/install-VPN-on-your-vps/index.html","hash":"068634dae9af19582f1283cf72832b977867b1f1","modified":1502356503515},{"_id":"public/2016/12/08/short-haired-girl-is-also-good/index.html","hash":"758394cd190d85c5afcec1fe2dc2ec25c9d3b2f6","modified":1502356503515},{"_id":"public/2016/12/06/UIScrollView-Category-error-message-with-deallocated-instance/index.html","hash":"74c6667303afc767d84a53d6fb536b232e1b26cd","modified":1502356503515},{"_id":"public/2016/12/02/use-gem-update-with-error/index.html","hash":"a5fdc0043414cf8e72b954844b9773bf497b9859","modified":1502356503515},{"_id":"public/2016/06/05/撩妹招数/index.html","hash":"b46088d85922723127f84d23c1608b7c70350cb5","modified":1502356503515},{"_id":"public/2016/06/05/很久以前/index.html","hash":"404170a487668ca321c528997d993d6d708d749d","modified":1502356503515},{"_id":"public/2016/06/03/https使用网易音乐外链播放器无法播放/index.html","hash":"91eaeb087743e6370d94e48ca4a4ca9dc23cf8e8","modified":1502356503516},{"_id":"public/2016/05/23/面试题-01/index.html","hash":"4ffe20aa15237cba72bb4d4ade53396913df2e85","modified":1502356503516},{"_id":"public/2016/04/01/着手写一个APP/index.html","hash":"e90e7d99b2045032169eebadbc08605eae074e63","modified":1502356503516},{"_id":"public/2016/03/26/IOS学习之作业篇(OC)/index.html","hash":"edc7d953b56c366251bcd9e30d379cf43933260a","modified":1502356503517},{"_id":"public/2016/03/21/命令安装Mac系统/index.html","hash":"faf99a531108b9a2f6a52e6a3df31d0c1e8f5885","modified":1502356503517},{"_id":"public/2016/03/21/利用pods给你的程序添加第三方库/index.html","hash":"d92bdf2200a5056178f97cd8b1eaa441f7e66b3d","modified":1502356503517},{"_id":"public/archives/index.html","hash":"41ecd74f678c868b7b7e0084fba871accf18540f","modified":1502356503517},{"_id":"public/categories/杂碎/index.html","hash":"66ea915bb52a110374339707b0e31ff7f4060849","modified":1502356503517},{"_id":"public/categories/Android/index.html","hash":"9b9f53552f9847f5a71f1e8c0ef6da5e05c9c9b7","modified":1502356503517},{"_id":"public/categories/C语言/index.html","hash":"ffc9add8103590c16dbc98538bf47daf1541af0b","modified":1502356503517},{"_id":"public/categories/iOS/index.html","hash":"efa179bf43e69c455b80bfcdb5ce30d3c91372bc","modified":1502356503517},{"_id":"public/categories/iOS/page/2/index.html","hash":"35e29fc0c75ca426a84050f98d896c69ff693197","modified":1502356503518},{"_id":"public/categories/命令/index.html","hash":"a93613306ac8dedb71ccc32410a30809a1e77b32","modified":1502356503518},{"_id":"public/categories/error/index.html","hash":"63c7be4aae82036d919e6a26fe08e406d0d52e05","modified":1502356503518},{"_id":"public/categories/教程/index.html","hash":"3a23263664e95c4e3ebe16cc1955e80104371126","modified":1502356503518},{"_id":"public/categories/教程/page/2/index.html","hash":"17ce455085833d5b3102259021afb95f38e3312c","modified":1502356503518},{"_id":"public/categories/HTMl/index.html","hash":"96140b645c68e1d2a1684e6dc8aa88dac15c6200","modified":1502356503518},{"_id":"public/page/2/index.html","hash":"f27b25860b7dba5b7cf683c864d5f6d01a40d9ae","modified":1502356503518},{"_id":"public/page/4/index.html","hash":"f145b196c2cd5b92320ab90c797dffe237907b22","modified":1502356503518},{"_id":"public/page/5/index.html","hash":"765eff4ea679ab291ee9c67d069d4e8205238ce0","modified":1502356503519},{"_id":"public/page/6/index.html","hash":"8cda0fca319ef35826e83e2e799295f75f2663d0","modified":1502356503519},{"_id":"public/tags/情感/index.html","hash":"18a38d9edb551fd78324300aeeacbded00b52e17","modified":1502356503519},{"_id":"public/tags/Android/index.html","hash":"9b9f53552f9847f5a71f1e8c0ef6da5e05c9c9b7","modified":1502356503519},{"_id":"public/tags/C语言/index.html","hash":"ffc9add8103590c16dbc98538bf47daf1541af0b","modified":1502356503519},{"_id":"public/tags/Objective-C/index.html","hash":"09b7083ba513620e58e7740efa685d850b40e513","modified":1502356503519},{"_id":"public/tags/命令/index.html","hash":"6341905ac143a32b56d313310841b7925955b36d","modified":1502356503519},{"_id":"public/tags/Swift/index.html","hash":"32eed6a61b1d18c950b9e524eeb3999b48d109ad","modified":1502356503519},{"_id":"public/tags/Xcode/index.html","hash":"0c3005b2a0b2cc0a2ec9587074313967400b6b72","modified":1502356503519},{"_id":"public/tags/error/index.html","hash":"63c7be4aae82036d919e6a26fe08e406d0d52e05","modified":1502356503519},{"_id":"public/tags/教程/index.html","hash":"2ec93b3998f772e18b92bea80223ab5d2c69b0f0","modified":1502356503519},{"_id":"public/tags/教程-翻墙/index.html","hash":"76bca407b9c4c46d0edc77a91ccf0b9da2433294","modified":1502356503520},{"_id":"public/tags/教程-Hexo/index.html","hash":"b92f6f7e7ecd812c1057203da31a81b1dc832b21","modified":1502356503520},{"_id":"public/tags/javaScript-html/index.html","hash":"fcd8bef0d285c70eab176e3d4a624e9f3f7d9661","modified":1502356503520},{"_id":"public/tags/杂碎/index.html","hash":"d6e6e6baab56dd66b61aeebfc1c605aaaf339d87","modified":1502356503520},{"_id":"public/tags/CocoaPods/index.html","hash":"6df900951aa4bf01fcbed111aeeae82c5db8d94f","modified":1502356503521},{"_id":"public/tags/MacOS/index.html","hash":"917fef8ec9726791e6f77fc4385699d1f412f6a8","modified":1502356503521},{"_id":"public/tags/教程-MacOS/index.html","hash":"06bfbe572f3d0295ba6eae569cca01f8be9b3e2d","modified":1502356503521},{"_id":"public/2017/04/24/use-hexo-on-aliyun-and-update-with-git/index.html","hash":"7a800f8350b4f19bea318bffbd5074fabe41033e","modified":1502356503521},{"_id":"public/2017/03/30/C语言的几种排序方法/index.html","hash":"592eaa5a28855e5d594aa3475b8e9411df159ca1","modified":1502356503521},{"_id":"public/2016/12/02/install-hexo-on-vps-and-update-with-git/index.html","hash":"8c93363cf71cfbc8445c95861270f6e1238ae2e4","modified":1502356503521},{"_id":"public/2016/12/02/install-huno-theme/index.html","hash":"0eea9d35ec76bcdfe0f8e2903ca041aebfff03e7","modified":1502356503521},{"_id":"public/2016/04/26/Swift学习笔记03/index.html","hash":"1bfa59a457a97125278807d02ed08d4597981435","modified":1502356503521},{"_id":"public/2016/04/24/Swift学习笔记02/index.html","hash":"556db0af34a23769afe03060227d40a62f1838e2","modified":1502356503521},{"_id":"public/2016/04/23/Swift学习笔记01/index.html","hash":"28287f1c2f7028f250e0da849670bd0b65513871","modified":1502356503521},{"_id":"public/2016/03/26/runtime/index.html","hash":"4e0f3ef6447b2e2900450e97e03672048d9a5f63","modified":1502356503521},{"_id":"public/2016/03/26/const-static-extern简介/index.html","hash":"4038472038f6ee11711c94a253b56c9cee8a6dc8","modified":1502356503521},{"_id":"public/2016/03/18/多线程/index.html","hash":"62324a6dea8e218d2639dfd66f0f5d0a4eeed749","modified":1502356503521},{"_id":"public/index.html","hash":"44cc1ba5211ca782364dad6e33384c5b2cb4fad4","modified":1502356503521},{"_id":"public/page/3/index.html","hash":"1a5d710f079ed93cd6beb74c8c5a878fc18e3f9d","modified":1502356503521},{"_id":"public/favicon.ico","hash":"0ae94c565ad90270da76efec1fa004cfab0a8c33","modified":1502356503525},{"_id":"public/apple-touch-icon.png","hash":"b49227f3c0fd2f69986e29dbc6d979676f936cf4","modified":1502356503525},{"_id":"public/css/jquery.fancybox.css","hash":"f42f761157f26244673eb2f4a9215c70956f80dc","modified":1502356503562},{"_id":"public/js/codeblock-resizer.js","hash":"5d0b786d60bf225d9eabcc9cece2719ff4d9b6cd","modified":1502356503562},{"_id":"public/js/search.js","hash":"0c0630e2ef213701d393b041f10572e951a27985","modified":1502356503563},{"_id":"public/js/fancybox.js","hash":"13c4781570339f4fba76a3d7f202e442817dd605","modified":1502356503563},{"_id":"public/js/share.js","hash":"6400d719d5eb14587d854a3dff6b290a3c06dc67","modified":1502356503563},{"_id":"public/js/smartresize.js","hash":"3ef157fd877167e3290f42c67a624ea375a46c24","modified":1502356503563},{"_id":"public/js/totop.js","hash":"7dbf8fcf582a4fb6eb9b2c60d6de9f9c2091ec4c","modified":1502356503563},{"_id":"public/css/style.css","hash":"3369d4ef06a8b7ced1f0fd3916dae904be4bf18d","modified":1502356503563}],"Category":[{"name":"杂碎","_id":"cj6686xkm0004xe9zr20wahse"},{"name":"Android","_id":"cj6686xky0009xe9zanasb77i"},{"name":"C语言","_id":"cj6686xl8000lxe9z214w0yuy"},{"name":"iOS","_id":"cj6686xlc000rxe9z9g6dnboy"},{"name":"命令","_id":"cj6686xly0014xe9z18mbxkms"},{"name":"error","_id":"cj6686xmv0024xe9zo112osoc"},{"name":"教程","_id":"cj6686xn1002dxe9ztwgm0xje"},{"name":"HTMl","_id":"cj6686xni003ixe9zukjba7oj"}],"Data":[],"Page":[{"title":"关于","date":"2016-12-02T01:52:46.000Z","_content":"\n我是一名iOS开发者.\n这个博客并没有什么技术性的文章, 只是偶尔的记录一些学习的笔记.\n\n对了, 最近在学习Android....\n由于工作需要,还在研究html\n\n---\n\n### 以下是我的一些个人信息\n\nGitHub : https://github.com/shlyren\n邮箱: <a href=\"mailto:mail@yuxiang.ren\">mail@yuxiang.ren</a>\n微博: http://weibo.com/shlyjen\n简历: https://resume.yuxiang.ren (好久没更新了...)\n\n最后给大家一个代理Google的网址(给那些无法翻墙的童鞋展示使用的)\nhttps://google.yuxiang.ren\n\n---\n\n### 以下是网站的大事记\n**2016/3**\n* 第一次尝试在vps上搭建博客, 用的是vultr的日本机房;\n* 采纳了朋友的建议使用了hexo环境搭建, 第一次折腾了很久;\n* 同时也搭建了翻墙环境, 以及<a href=\"https://google.yuxiang.ren\">Google代理</a>....\n\n**2016/6**\n* 全站使用https访问(好像是免费的startssl)....\n\n**2016/12 **\n* 由于一次操作失误, vps上所有的数据全部删除, 博客内容全部清空;\n* 只能再次重新搭建, 部分文章恢复 ;\n* 将博客全部内容同步到了<a href=\"https://github.com/shlyren/web/tree/master/yuxiang.ren\">Github</a>;\n* https更换为付费版, 并且使用的通配符性(主要是方便以后的扩展)...\n\n**2017/4**\n* 租用阿里云服务器,并且把博客放在了阿里云主机上;\n* 将名下的所有域名备案;\n* 重新部署服务器环境, 至此,速度有一定的提升;\n* 之前的vps只用来做翻墙服务;\n* 由于多说评论将停止服务, 故换成了网易云跟帖.","source":"about/index.md","raw":"---\ntitle: 关于\ndate: 2016-12-02 09:52:46\n---\n\n我是一名iOS开发者.\n这个博客并没有什么技术性的文章, 只是偶尔的记录一些学习的笔记.\n\n对了, 最近在学习Android....\n由于工作需要,还在研究html\n\n---\n\n### 以下是我的一些个人信息\n\nGitHub : https://github.com/shlyren\n邮箱: <a href=\"mailto:mail@yuxiang.ren\">mail@yuxiang.ren</a>\n微博: http://weibo.com/shlyjen\n简历: https://resume.yuxiang.ren (好久没更新了...)\n\n最后给大家一个代理Google的网址(给那些无法翻墙的童鞋展示使用的)\nhttps://google.yuxiang.ren\n\n---\n\n### 以下是网站的大事记\n**2016/3**\n* 第一次尝试在vps上搭建博客, 用的是vultr的日本机房;\n* 采纳了朋友的建议使用了hexo环境搭建, 第一次折腾了很久;\n* 同时也搭建了翻墙环境, 以及<a href=\"https://google.yuxiang.ren\">Google代理</a>....\n\n**2016/6**\n* 全站使用https访问(好像是免费的startssl)....\n\n**2016/12 **\n* 由于一次操作失误, vps上所有的数据全部删除, 博客内容全部清空;\n* 只能再次重新搭建, 部分文章恢复 ;\n* 将博客全部内容同步到了<a href=\"https://github.com/shlyren/web/tree/master/yuxiang.ren\">Github</a>;\n* https更换为付费版, 并且使用的通配符性(主要是方便以后的扩展)...\n\n**2017/4**\n* 租用阿里云服务器,并且把博客放在了阿里云主机上;\n* 将名下的所有域名备案;\n* 重新部署服务器环境, 至此,速度有一定的提升;\n* 之前的vps只用来做翻墙服务;\n* 由于多说评论将停止服务, 故换成了网易云跟帖.","updated":"2017-05-25T04:02:27.000Z","path":"about/index.html","comments":1,"layout":"page","_id":"cj6686xkg0001xe9z1wlb1xn4","content":"<p>我是一名iOS开发者.<br>这个博客并没有什么技术性的文章, 只是偶尔的记录一些学习的笔记.</p>\n<p>对了, 最近在学习Android….<br>由于工作需要,还在研究html</p>\n<hr>\n<h3 id=\"以下是我的一些个人信息\"><a href=\"#以下是我的一些个人信息\" class=\"headerlink\" title=\"以下是我的一些个人信息\"></a>以下是我的一些个人信息</h3><p>GitHub : <a href=\"https://github.com/shlyren\" target=\"_blank\" rel=\"external\">https://github.com/shlyren</a><br>邮箱: <a href=\"mailto:mail@yuxiang.ren\">mail@yuxiang.ren</a><br>微博: <a href=\"http://weibo.com/shlyjen\" target=\"_blank\" rel=\"external\">http://weibo.com/shlyjen</a><br>简历: <a href=\"https://resume.yuxiang.ren\" target=\"_blank\" rel=\"external\">https://resume.yuxiang.ren</a> (好久没更新了…)</p>\n<p>最后给大家一个代理Google的网址(给那些无法翻墙的童鞋展示使用的)<br><a href=\"https://google.yuxiang.ren\" target=\"_blank\" rel=\"external\">https://google.yuxiang.ren</a></p>\n<hr>\n<h3 id=\"以下是网站的大事记\"><a href=\"#以下是网站的大事记\" class=\"headerlink\" title=\"以下是网站的大事记\"></a>以下是网站的大事记</h3><p><strong>2016/3</strong></p>\n<ul>\n<li>第一次尝试在vps上搭建博客, 用的是vultr的日本机房;</li>\n<li>采纳了朋友的建议使用了hexo环境搭建, 第一次折腾了很久;</li>\n<li>同时也搭建了翻墙环境, 以及<a href=\"https://google.yuxiang.ren\" target=\"_blank\" rel=\"external\">Google代理</a>….</li>\n</ul>\n<p><strong>2016/6</strong></p>\n<ul>\n<li>全站使用https访问(好像是免费的startssl)….</li>\n</ul>\n<p><strong>2016/12 </strong></p>\n<ul>\n<li>由于一次操作失误, vps上所有的数据全部删除, 博客内容全部清空;</li>\n<li>只能再次重新搭建, 部分文章恢复 ;</li>\n<li>将博客全部内容同步到了<a href=\"https://github.com/shlyren/web/tree/master/yuxiang.ren\" target=\"_blank\" rel=\"external\">Github</a>;</li>\n<li>https更换为付费版, 并且使用的通配符性(主要是方便以后的扩展)…</li>\n</ul>\n<p><strong>2017/4</strong></p>\n<ul>\n<li>租用阿里云服务器,并且把博客放在了阿里云主机上;</li>\n<li>将名下的所有域名备案;</li>\n<li>重新部署服务器环境, 至此,速度有一定的提升;</li>\n<li>之前的vps只用来做翻墙服务;</li>\n<li>由于多说评论将停止服务, 故换成了网易云跟帖.</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>我是一名iOS开发者.<br>这个博客并没有什么技术性的文章, 只是偶尔的记录一些学习的笔记.</p>\n<p>对了, 最近在学习Android….<br>由于工作需要,还在研究html</p>\n<hr>\n<h3 id=\"以下是我的一些个人信息\"><a href=\"#以下是我的一些个人信息\" class=\"headerlink\" title=\"以下是我的一些个人信息\"></a>以下是我的一些个人信息</h3><p>GitHub : <a href=\"https://github.com/shlyren\" target=\"_blank\" rel=\"external\">https://github.com/shlyren</a><br>邮箱: <a href=\"mailto:mail@yuxiang.ren\">mail@yuxiang.ren</a><br>微博: <a href=\"http://weibo.com/shlyjen\" target=\"_blank\" rel=\"external\">http://weibo.com/shlyjen</a><br>简历: <a href=\"https://resume.yuxiang.ren\" target=\"_blank\" rel=\"external\">https://resume.yuxiang.ren</a> (好久没更新了…)</p>\n<p>最后给大家一个代理Google的网址(给那些无法翻墙的童鞋展示使用的)<br><a href=\"https://google.yuxiang.ren\" target=\"_blank\" rel=\"external\">https://google.yuxiang.ren</a></p>\n<hr>\n<h3 id=\"以下是网站的大事记\"><a href=\"#以下是网站的大事记\" class=\"headerlink\" title=\"以下是网站的大事记\"></a>以下是网站的大事记</h3><p><strong>2016/3</strong></p>\n<ul>\n<li>第一次尝试在vps上搭建博客, 用的是vultr的日本机房;</li>\n<li>采纳了朋友的建议使用了hexo环境搭建, 第一次折腾了很久;</li>\n<li>同时也搭建了翻墙环境, 以及<a href=\"https://google.yuxiang.ren\" target=\"_blank\" rel=\"external\">Google代理</a>….</li>\n</ul>\n<p><strong>2016/6</strong></p>\n<ul>\n<li>全站使用https访问(好像是免费的startssl)….</li>\n</ul>\n<p><strong>2016/12 </strong></p>\n<ul>\n<li>由于一次操作失误, vps上所有的数据全部删除, 博客内容全部清空;</li>\n<li>只能再次重新搭建, 部分文章恢复 ;</li>\n<li>将博客全部内容同步到了<a href=\"https://github.com/shlyren/web/tree/master/yuxiang.ren\" target=\"_blank\" rel=\"external\">Github</a>;</li>\n<li>https更换为付费版, 并且使用的通配符性(主要是方便以后的扩展)…</li>\n</ul>\n<p><strong>2017/4</strong></p>\n<ul>\n<li>租用阿里云服务器,并且把博客放在了阿里云主机上;</li>\n<li>将名下的所有域名备案;</li>\n<li>重新部署服务器环境, 至此,速度有一定的提升;</li>\n<li>之前的vps只用来做翻墙服务;</li>\n<li>由于多说评论将停止服务, 故换成了网易云跟帖.</li>\n</ul>\n"},{"title":"归档","layout":"page-archive","_content":"","source":"archive/index.md","raw":"---\ntitle: 归档\nlayout: page-archive\n---\n","date":"2017-05-23T09:01:23.000Z","updated":"2016-12-02T01:36:16.000Z","path":"archive/index.html","comments":1,"_id":"cj6686xkj0003xe9zmajhnujt","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"愿被这个世界温柔以待","date":"2017-01-27T16:19:56.000Z","_content":"\n\n\n2017年注定是一个悲伤的一年!\n\n今天是大连初一, 夜已深, 久久不能入眠, 不知是因为外面的鞭炮声还是内心的不安……\n\n有时候想想, 还是自己太天真了, 大多时候只因自己的一时兴起, 做了太多的错误的事情, 导致了26岁的我依旧还是一条单身汪, 眼看这一起上学的同学都结婚的结婚,生小孩的生小孩, 说自己心里不急的那肯定是假的...\n\n<!-- more -->\n\n失去后再珍惜,还有什么意义....  但如果没有失去, 怎么能知道珍惜的重要性... 或许这就是想要知道珍惜的重要性而要付出的代价吧。\n\n有些东西，错过了就是错过了，\n\n虽然这个博客对外开房。但 毕竟，这个网站没有人知道， 也没有人会来看，哈哈~\n\n话说，现在过年一点意思也没有了……\n\n希望你能遇到个对你好的人……","source":"_posts/2017.md","raw":"---\ntitle: 愿被这个世界温柔以待\ndate: 2017-01-28 00:19:56\ncategories: 杂碎\ntags: 情感\n---\n\n\n\n2017年注定是一个悲伤的一年!\n\n今天是大连初一, 夜已深, 久久不能入眠, 不知是因为外面的鞭炮声还是内心的不安……\n\n有时候想想, 还是自己太天真了, 大多时候只因自己的一时兴起, 做了太多的错误的事情, 导致了26岁的我依旧还是一条单身汪, 眼看这一起上学的同学都结婚的结婚,生小孩的生小孩, 说自己心里不急的那肯定是假的...\n\n<!-- more -->\n\n失去后再珍惜,还有什么意义....  但如果没有失去, 怎么能知道珍惜的重要性... 或许这就是想要知道珍惜的重要性而要付出的代价吧。\n\n有些东西，错过了就是错过了，\n\n虽然这个博客对外开房。但 毕竟，这个网站没有人知道， 也没有人会来看，哈哈~\n\n话说，现在过年一点意思也没有了……\n\n希望你能遇到个对你好的人……","slug":"2017","published":1,"updated":"2017-04-28T08:33:32.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6686xkb0000xe9z7qtlvsq1","content":"<p>2017年注定是一个悲伤的一年!</p>\n<p>今天是大连初一, 夜已深, 久久不能入眠, 不知是因为外面的鞭炮声还是内心的不安……</p>\n<p>有时候想想, 还是自己太天真了, 大多时候只因自己的一时兴起, 做了太多的错误的事情, 导致了26岁的我依旧还是一条单身汪, 眼看这一起上学的同学都结婚的结婚,生小孩的生小孩, 说自己心里不急的那肯定是假的…</p>\n<a id=\"more\"></a>\n<p>失去后再珍惜,还有什么意义….  但如果没有失去, 怎么能知道珍惜的重要性… 或许这就是想要知道珍惜的重要性而要付出的代价吧。</p>\n<p>有些东西，错过了就是错过了，</p>\n<p>虽然这个博客对外开房。但 毕竟，这个网站没有人知道， 也没有人会来看，哈哈~</p>\n<p>话说，现在过年一点意思也没有了……</p>\n<p>希望你能遇到个对你好的人……</p>\n","site":{"data":{}},"excerpt":"<p>2017年注定是一个悲伤的一年!</p>\n<p>今天是大连初一, 夜已深, 久久不能入眠, 不知是因为外面的鞭炮声还是内心的不安……</p>\n<p>有时候想想, 还是自己太天真了, 大多时候只因自己的一时兴起, 做了太多的错误的事情, 导致了26岁的我依旧还是一条单身汪, 眼看这一起上学的同学都结婚的结婚,生小孩的生小孩, 说自己心里不急的那肯定是假的…</p>","more":"<p>失去后再珍惜,还有什么意义….  但如果没有失去, 怎么能知道珍惜的重要性… 或许这就是想要知道珍惜的重要性而要付出的代价吧。</p>\n<p>有些东西，错过了就是错过了，</p>\n<p>虽然这个博客对外开房。但 毕竟，这个网站没有人知道， 也没有人会来看，哈哈~</p>\n<p>话说，现在过年一点意思也没有了……</p>\n<p>希望你能遇到个对你好的人……</p>"},{"title":"Android-fragment","date":"2017-03-24T03:03:01.000Z","_content":"\nFragment\n\n<!-- more -->\n\n\n\n","source":"_posts/Android-fragment.md","raw":"---\ntitle: Android-fragment\ndate: 2017-03-24 11:03:01\ncategories: Android\ntags: Android\n---\n\nFragment\n\n<!-- more -->\n\n\n\n","slug":"Android-fragment","published":1,"updated":"2017-03-24T04:02:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6686xkh0002xe9zzrxi8nli","content":"<p>Fragment</p>\n<a id=\"more\"></a>\n","site":{"data":{}},"excerpt":"<p>Fragment</p>","more":""},{"title":"Android Activity","date":"2017-02-10T01:01:47.000Z","_content":"\n\n\n\n\n<!-- more -->\n\n\n","source":"_posts/Android-Activity.md","raw":"---\ntitle: Android Activity\ndate: 2017-02-10 09:01:47\ncategories: Android\ntags: Android\n---\n\n\n\n\n\n<!-- more -->\n\n\n","slug":"Android-Activity","published":1,"updated":"2017-02-10T07:15:13.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6686xkq0006xe9zf7c5ibrg","content":"<a id=\"more\"></a>\n","site":{"data":{}},"excerpt":"","more":""},{"title":"C语言的几种排序方法","date":"2017-03-30T07:38:24.000Z","_content":"\n\n\n### 一. 选择排序\n\n1. 原理\n   首先在未排序序列中找到最小的元素，存放到排序序列的起始位置，然后再从剩余未排序元素中继续寻找最小元素，翻到排序序列末尾，以此类推，直到所有的元素均排序完毕.\n\n2. 基本思想\n\n   第一趟排序在所有待排序的n个记录中选出关键字最小的记录,将它与数据表中的第一个记录交换位置,使关键字最小的记录处于数据表的最前端;第二趟在剩下的n-1个记录中再选出关键字最 小的记录,将其与数据表中的第二个记录交换位置,使关键字次小的记录处于数据表的第二个位置;重复这样的操作,依次选出数据表中关键字第三小、第四小…的元素,将它们分别换到数据表的第三、第四…个位置上。排序共进行n-1趟,最终可实现数据表的升序排列。\n\n   <!-- more -->\n\n3. 代码\n\n   ```c\n   // 需要排序的数组\n   int nums[8] = {99, 12, 88, 34, 5, 44, 12, 100};\n   // 计算数组长度\n   int length = sizeof(nums) / sizeof(nums[0]);\n   printf(\"length = %i\\n\", length);\n\n   for (int i = 0; i < length; i++) {\n   \tprintf(\"排序前: nums[%i] = %i\\n\", i, nums[i]);\n   }\n       \n   printf(\"=====================\\n\");\n       \n   // 排序\n   for (int i = 0; i < length - 1; i++) {\n       for (int j = i+1; j < length; j++) {\n           if (nums[i] > nums[j]) {\n               // 交换位置\n   \t\t\tint temp = nums[i];\n   \t\t\tnums[i] = nums[j];\n   \t\t\tnums[j] = temp;\n           }\n       }\n   }\n       \n   for (int i = 0; i < length; i++) {\n       printf(\"排序后: nums[%i] = %i\\n\", i, nums[i]);\n   }\n   ```\n\n\n### 二. 冒泡排序\n\n1. 原理\n\n   它重复地走访过要排序的数列,一次比较两个元素,如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换,也就是说该数列已经排序完成。这个算法的名字由来 是因为越小的元素会经由交换慢慢“浮”到数列的顶端。\n\n2. 基本思想\n\n   * 比较相邻的元素。如果第一个比第二个大,就交换他们两个。\n   * 对每一对相邻元素作同样的工作,从开始第一对到结尾的最后一对。在这一点,最后的元素应 该会是最大的数。\n   * 针对所有的元素重复以上的步骤,除了最后一个。\n   * 持续每次对越来越少的元素重复上面的步骤,直到没有任何一对数字需要比较。\n\n3. 代码\n\n   ```c\n   int nums[8] = {99, 12, 88, 34, 5, 44, 12, 100};\n   int length = sizeof(nums) / sizeof(nums[0]);\n\n   for (int i = 0; i < length; i++) {\n       printf(\"排序前: nums[%i] = %i\\n\", i, nums[i]);\n   }\n\n   printf(\"----------\\n\");\n\n   for (int i = 0; i < length - 1; i++) {\n       for (int j = 0; j < length - 1 - i; j++) {\n           if (nums[j] > nums[j + 1]) {\n               int temp = nums[j];\n               nums[j] = nums[j + 1];\n               nums[j + 1] = temp;\n           }\n       }\n   }\n\n   for (int i = 0; i < length; i++) {\n       printf(\"排序后: nums[%i] = %i\\n\", i, nums[i]);\n   }\n   ```\n\n   ​\n\n### 三. 插入排序\n\n1. 原理\n\n   插入即表示将一个新的数据插入到一个有序数组中，并继续保持有序。例如有一个长度为N的无序数组，进行N-1次的插入即能完成排序；第一次，数组第1个数认为是有序的数组，将数组第二个元素插入仅有1个有序的数组中；第二次，数组前两个元素组成有序的数组，将数组第三个元素插入由两个元素构成的有序数组中……第N-1次，数组前N-1个元素组成有序的数组，将数组的第N个元素插入由N-1个元素构成的有序数组中，则完成了整个插入排序。\n\n2. 基本思想\n\n   插入排序是在一个已经有序的小序列的基础上，一次插入一个元素。当然，刚开始这个有序的小序列只有1个元素，就是第一个元素。比较是从有序序列的末尾开始，也就是想要插入的元素和已经有序的最大者开始比起，如果比它大则直接插入在其后面，否则一直往前找直到找到它该插入的位置。如果碰见一个和插入元素相等的，那么插入元素把想插入的元素放在相等元素的后面。所以，相等元素的前后顺序没有改变，从原无序序列出去的顺序就是排好序后的顺序，所以插入排序是稳定的。\n\n3. 代码\n\n   ```c\n   int nums[8] = {99, 12, 88, 34, 5, 44, 12, 100};\n   int length = sizeof(nums) / sizeof(nums[0]);\n\n   for (int i = 0; i < length; i++) {\n       printf(\"排序前: nums[%i] = %i\\n\", i, nums[i]);\n   }\n\n   printf(\"----------\\n\");\n\n   int i, j, temp;\n   for (i = 1; i < length; i++) {\n       if (nums[i] < nums[i - 1]){\n           temp = nums[i];\n           for (j = i - 1; j >= 0 && nums[j] > temp; j--)\n               nums[j + 1] = nums[j];\n           nums[j + 1] = temp;\n       }\n   }\n\n   for (int i = 0; i < length; i++) {\n       printf(\"排序后: nums[%i] = %i\\n\", i, nums[i]);\n   }\n   ```\n\n   ​","source":"_posts/C语言的几种排序方法.md","raw":"---\ntitle: C语言的几种排序方法\ndate: 2017-03-30 15:38:24\ncategories: C语言\ntags: C语言\n---\n\n\n\n### 一. 选择排序\n\n1. 原理\n   首先在未排序序列中找到最小的元素，存放到排序序列的起始位置，然后再从剩余未排序元素中继续寻找最小元素，翻到排序序列末尾，以此类推，直到所有的元素均排序完毕.\n\n2. 基本思想\n\n   第一趟排序在所有待排序的n个记录中选出关键字最小的记录,将它与数据表中的第一个记录交换位置,使关键字最小的记录处于数据表的最前端;第二趟在剩下的n-1个记录中再选出关键字最 小的记录,将其与数据表中的第二个记录交换位置,使关键字次小的记录处于数据表的第二个位置;重复这样的操作,依次选出数据表中关键字第三小、第四小…的元素,将它们分别换到数据表的第三、第四…个位置上。排序共进行n-1趟,最终可实现数据表的升序排列。\n\n   <!-- more -->\n\n3. 代码\n\n   ```c\n   // 需要排序的数组\n   int nums[8] = {99, 12, 88, 34, 5, 44, 12, 100};\n   // 计算数组长度\n   int length = sizeof(nums) / sizeof(nums[0]);\n   printf(\"length = %i\\n\", length);\n\n   for (int i = 0; i < length; i++) {\n   \tprintf(\"排序前: nums[%i] = %i\\n\", i, nums[i]);\n   }\n       \n   printf(\"=====================\\n\");\n       \n   // 排序\n   for (int i = 0; i < length - 1; i++) {\n       for (int j = i+1; j < length; j++) {\n           if (nums[i] > nums[j]) {\n               // 交换位置\n   \t\t\tint temp = nums[i];\n   \t\t\tnums[i] = nums[j];\n   \t\t\tnums[j] = temp;\n           }\n       }\n   }\n       \n   for (int i = 0; i < length; i++) {\n       printf(\"排序后: nums[%i] = %i\\n\", i, nums[i]);\n   }\n   ```\n\n\n### 二. 冒泡排序\n\n1. 原理\n\n   它重复地走访过要排序的数列,一次比较两个元素,如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换,也就是说该数列已经排序完成。这个算法的名字由来 是因为越小的元素会经由交换慢慢“浮”到数列的顶端。\n\n2. 基本思想\n\n   * 比较相邻的元素。如果第一个比第二个大,就交换他们两个。\n   * 对每一对相邻元素作同样的工作,从开始第一对到结尾的最后一对。在这一点,最后的元素应 该会是最大的数。\n   * 针对所有的元素重复以上的步骤,除了最后一个。\n   * 持续每次对越来越少的元素重复上面的步骤,直到没有任何一对数字需要比较。\n\n3. 代码\n\n   ```c\n   int nums[8] = {99, 12, 88, 34, 5, 44, 12, 100};\n   int length = sizeof(nums) / sizeof(nums[0]);\n\n   for (int i = 0; i < length; i++) {\n       printf(\"排序前: nums[%i] = %i\\n\", i, nums[i]);\n   }\n\n   printf(\"----------\\n\");\n\n   for (int i = 0; i < length - 1; i++) {\n       for (int j = 0; j < length - 1 - i; j++) {\n           if (nums[j] > nums[j + 1]) {\n               int temp = nums[j];\n               nums[j] = nums[j + 1];\n               nums[j + 1] = temp;\n           }\n       }\n   }\n\n   for (int i = 0; i < length; i++) {\n       printf(\"排序后: nums[%i] = %i\\n\", i, nums[i]);\n   }\n   ```\n\n   ​\n\n### 三. 插入排序\n\n1. 原理\n\n   插入即表示将一个新的数据插入到一个有序数组中，并继续保持有序。例如有一个长度为N的无序数组，进行N-1次的插入即能完成排序；第一次，数组第1个数认为是有序的数组，将数组第二个元素插入仅有1个有序的数组中；第二次，数组前两个元素组成有序的数组，将数组第三个元素插入由两个元素构成的有序数组中……第N-1次，数组前N-1个元素组成有序的数组，将数组的第N个元素插入由N-1个元素构成的有序数组中，则完成了整个插入排序。\n\n2. 基本思想\n\n   插入排序是在一个已经有序的小序列的基础上，一次插入一个元素。当然，刚开始这个有序的小序列只有1个元素，就是第一个元素。比较是从有序序列的末尾开始，也就是想要插入的元素和已经有序的最大者开始比起，如果比它大则直接插入在其后面，否则一直往前找直到找到它该插入的位置。如果碰见一个和插入元素相等的，那么插入元素把想插入的元素放在相等元素的后面。所以，相等元素的前后顺序没有改变，从原无序序列出去的顺序就是排好序后的顺序，所以插入排序是稳定的。\n\n3. 代码\n\n   ```c\n   int nums[8] = {99, 12, 88, 34, 5, 44, 12, 100};\n   int length = sizeof(nums) / sizeof(nums[0]);\n\n   for (int i = 0; i < length; i++) {\n       printf(\"排序前: nums[%i] = %i\\n\", i, nums[i]);\n   }\n\n   printf(\"----------\\n\");\n\n   int i, j, temp;\n   for (i = 1; i < length; i++) {\n       if (nums[i] < nums[i - 1]){\n           temp = nums[i];\n           for (j = i - 1; j >= 0 && nums[j] > temp; j--)\n               nums[j + 1] = nums[j];\n           nums[j + 1] = temp;\n       }\n   }\n\n   for (int i = 0; i < length; i++) {\n       printf(\"排序后: nums[%i] = %i\\n\", i, nums[i]);\n   }\n   ```\n\n   ​","slug":"C语言的几种排序方法","published":1,"updated":"2017-03-30T07:44:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6686xkt0007xe9zgwnua5mx","content":"<h3 id=\"一-选择排序\"><a href=\"#一-选择排序\" class=\"headerlink\" title=\"一. 选择排序\"></a>一. 选择排序</h3><ol>\n<li><p>原理<br>首先在未排序序列中找到最小的元素，存放到排序序列的起始位置，然后再从剩余未排序元素中继续寻找最小元素，翻到排序序列末尾，以此类推，直到所有的元素均排序完毕.</p>\n</li>\n<li><p>基本思想</p>\n<p>第一趟排序在所有待排序的n个记录中选出关键字最小的记录,将它与数据表中的第一个记录交换位置,使关键字最小的记录处于数据表的最前端;第二趟在剩下的n-1个记录中再选出关键字最 小的记录,将其与数据表中的第二个记录交换位置,使关键字次小的记录处于数据表的第二个位置;重复这样的操作,依次选出数据表中关键字第三小、第四小…的元素,将它们分别换到数据表的第三、第四…个位置上。排序共进行n-1趟,最终可实现数据表的升序排列。</p>\n<a id=\"more\"></a>\n</li>\n<li><p>代码</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 需要排序的数组</span></div><div class=\"line\"><span class=\"keyword\">int</span> nums[<span class=\"number\">8</span>] = &#123;<span class=\"number\">99</span>, <span class=\"number\">12</span>, <span class=\"number\">88</span>, <span class=\"number\">34</span>, <span class=\"number\">5</span>, <span class=\"number\">44</span>, <span class=\"number\">12</span>, <span class=\"number\">100</span>&#125;;</div><div class=\"line\"><span class=\"comment\">// 计算数组长度</span></div><div class=\"line\"><span class=\"keyword\">int</span> length = <span class=\"keyword\">sizeof</span>(nums) / <span class=\"keyword\">sizeof</span>(nums[<span class=\"number\">0</span>]);</div><div class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"length = %i\\n\"</span>, length);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; length; i++) &#123;</div><div class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"排序前: nums[%i] = %i\\n\"</span>, i, nums[i]);</div><div class=\"line\">&#125;</div><div class=\"line\">    </div><div class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"=====================\\n\"</span>);</div><div class=\"line\">    </div><div class=\"line\"><span class=\"comment\">// 排序</span></div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; length - <span class=\"number\">1</span>; i++) &#123;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = i+<span class=\"number\">1</span>; j &lt; length; j++) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (nums[i] &gt; nums[j]) &#123;</div><div class=\"line\">            <span class=\"comment\">// 交换位置</span></div><div class=\"line\">\t\t\t<span class=\"keyword\">int</span> temp = nums[i];</div><div class=\"line\">\t\t\tnums[i] = nums[j];</div><div class=\"line\">\t\t\tnums[j] = temp;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">    </div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; length; i++) &#123;</div><div class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"排序后: nums[%i] = %i\\n\"</span>, i, nums[i]);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"二-冒泡排序\"><a href=\"#二-冒泡排序\" class=\"headerlink\" title=\"二. 冒泡排序\"></a>二. 冒泡排序</h3><ol>\n<li><p>原理</p>\n<p>它重复地走访过要排序的数列,一次比较两个元素,如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换,也就是说该数列已经排序完成。这个算法的名字由来 是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p>\n</li>\n<li><p>基本思想</p>\n<ul>\n<li>比较相邻的元素。如果第一个比第二个大,就交换他们两个。</li>\n<li>对每一对相邻元素作同样的工作,从开始第一对到结尾的最后一对。在这一点,最后的元素应 该会是最大的数。</li>\n<li>针对所有的元素重复以上的步骤,除了最后一个。</li>\n<li>持续每次对越来越少的元素重复上面的步骤,直到没有任何一对数字需要比较。</li>\n</ul>\n</li>\n<li><p>代码</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> nums[<span class=\"number\">8</span>] = &#123;<span class=\"number\">99</span>, <span class=\"number\">12</span>, <span class=\"number\">88</span>, <span class=\"number\">34</span>, <span class=\"number\">5</span>, <span class=\"number\">44</span>, <span class=\"number\">12</span>, <span class=\"number\">100</span>&#125;;</div><div class=\"line\"><span class=\"keyword\">int</span> length = <span class=\"keyword\">sizeof</span>(nums) / <span class=\"keyword\">sizeof</span>(nums[<span class=\"number\">0</span>]);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; length; i++) &#123;</div><div class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"排序前: nums[%i] = %i\\n\"</span>, i, nums[i]);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"----------\\n\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; length - <span class=\"number\">1</span>; i++) &#123;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; length - <span class=\"number\">1</span> - i; j++) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (nums[j] &gt; nums[j + <span class=\"number\">1</span>]) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> temp = nums[j];</div><div class=\"line\">            nums[j] = nums[j + <span class=\"number\">1</span>];</div><div class=\"line\">            nums[j + <span class=\"number\">1</span>] = temp;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; length; i++) &#123;</div><div class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"排序后: nums[%i] = %i\\n\"</span>, i, nums[i]);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>​</p>\n</li>\n</ol>\n<h3 id=\"三-插入排序\"><a href=\"#三-插入排序\" class=\"headerlink\" title=\"三. 插入排序\"></a>三. 插入排序</h3><ol>\n<li><p>原理</p>\n<p>插入即表示将一个新的数据插入到一个有序数组中，并继续保持有序。例如有一个长度为N的无序数组，进行N-1次的插入即能完成排序；第一次，数组第1个数认为是有序的数组，将数组第二个元素插入仅有1个有序的数组中；第二次，数组前两个元素组成有序的数组，将数组第三个元素插入由两个元素构成的有序数组中……第N-1次，数组前N-1个元素组成有序的数组，将数组的第N个元素插入由N-1个元素构成的有序数组中，则完成了整个插入排序。</p>\n</li>\n<li><p>基本思想</p>\n<p>插入排序是在一个已经有序的小序列的基础上，一次插入一个元素。当然，刚开始这个有序的小序列只有1个元素，就是第一个元素。比较是从有序序列的末尾开始，也就是想要插入的元素和已经有序的最大者开始比起，如果比它大则直接插入在其后面，否则一直往前找直到找到它该插入的位置。如果碰见一个和插入元素相等的，那么插入元素把想插入的元素放在相等元素的后面。所以，相等元素的前后顺序没有改变，从原无序序列出去的顺序就是排好序后的顺序，所以插入排序是稳定的。</p>\n</li>\n<li><p>代码</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> nums[<span class=\"number\">8</span>] = &#123;<span class=\"number\">99</span>, <span class=\"number\">12</span>, <span class=\"number\">88</span>, <span class=\"number\">34</span>, <span class=\"number\">5</span>, <span class=\"number\">44</span>, <span class=\"number\">12</span>, <span class=\"number\">100</span>&#125;;</div><div class=\"line\"><span class=\"keyword\">int</span> length = <span class=\"keyword\">sizeof</span>(nums) / <span class=\"keyword\">sizeof</span>(nums[<span class=\"number\">0</span>]);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; length; i++) &#123;</div><div class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"排序前: nums[%i] = %i\\n\"</span>, i, nums[i]);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"----------\\n\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> i, j, temp;</div><div class=\"line\"><span class=\"keyword\">for</span> (i = <span class=\"number\">1</span>; i &lt; length; i++) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (nums[i] &lt; nums[i - <span class=\"number\">1</span>])&#123;</div><div class=\"line\">        temp = nums[i];</div><div class=\"line\">        <span class=\"keyword\">for</span> (j = i - <span class=\"number\">1</span>; j &gt;= <span class=\"number\">0</span> &amp;&amp; nums[j] &gt; temp; j--)</div><div class=\"line\">            nums[j + <span class=\"number\">1</span>] = nums[j];</div><div class=\"line\">        nums[j + <span class=\"number\">1</span>] = temp;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; length; i++) &#123;</div><div class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"排序后: nums[%i] = %i\\n\"</span>, i, nums[i]);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>​</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"<h3 id=\"一-选择排序\"><a href=\"#一-选择排序\" class=\"headerlink\" title=\"一. 选择排序\"></a>一. 选择排序</h3><ol>\n<li><p>原理<br>首先在未排序序列中找到最小的元素，存放到排序序列的起始位置，然后再从剩余未排序元素中继续寻找最小元素，翻到排序序列末尾，以此类推，直到所有的元素均排序完毕.</p>\n</li>\n<li><p>基本思想</p>\n<p>第一趟排序在所有待排序的n个记录中选出关键字最小的记录,将它与数据表中的第一个记录交换位置,使关键字最小的记录处于数据表的最前端;第二趟在剩下的n-1个记录中再选出关键字最 小的记录,将其与数据表中的第二个记录交换位置,使关键字次小的记录处于数据表的第二个位置;重复这样的操作,依次选出数据表中关键字第三小、第四小…的元素,将它们分别换到数据表的第三、第四…个位置上。排序共进行n-1趟,最终可实现数据表的升序排列。</p>","more":"</li>\n<li><p>代码</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 需要排序的数组</span></div><div class=\"line\"><span class=\"keyword\">int</span> nums[<span class=\"number\">8</span>] = &#123;<span class=\"number\">99</span>, <span class=\"number\">12</span>, <span class=\"number\">88</span>, <span class=\"number\">34</span>, <span class=\"number\">5</span>, <span class=\"number\">44</span>, <span class=\"number\">12</span>, <span class=\"number\">100</span>&#125;;</div><div class=\"line\"><span class=\"comment\">// 计算数组长度</span></div><div class=\"line\"><span class=\"keyword\">int</span> length = <span class=\"keyword\">sizeof</span>(nums) / <span class=\"keyword\">sizeof</span>(nums[<span class=\"number\">0</span>]);</div><div class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"length = %i\\n\"</span>, length);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; length; i++) &#123;</div><div class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"排序前: nums[%i] = %i\\n\"</span>, i, nums[i]);</div><div class=\"line\">&#125;</div><div class=\"line\">    </div><div class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"=====================\\n\"</span>);</div><div class=\"line\">    </div><div class=\"line\"><span class=\"comment\">// 排序</span></div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; length - <span class=\"number\">1</span>; i++) &#123;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = i+<span class=\"number\">1</span>; j &lt; length; j++) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (nums[i] &gt; nums[j]) &#123;</div><div class=\"line\">            <span class=\"comment\">// 交换位置</span></div><div class=\"line\">\t\t\t<span class=\"keyword\">int</span> temp = nums[i];</div><div class=\"line\">\t\t\tnums[i] = nums[j];</div><div class=\"line\">\t\t\tnums[j] = temp;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">    </div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; length; i++) &#123;</div><div class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"排序后: nums[%i] = %i\\n\"</span>, i, nums[i]);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"二-冒泡排序\"><a href=\"#二-冒泡排序\" class=\"headerlink\" title=\"二. 冒泡排序\"></a>二. 冒泡排序</h3><ol>\n<li><p>原理</p>\n<p>它重复地走访过要排序的数列,一次比较两个元素,如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换,也就是说该数列已经排序完成。这个算法的名字由来 是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p>\n</li>\n<li><p>基本思想</p>\n<ul>\n<li>比较相邻的元素。如果第一个比第二个大,就交换他们两个。</li>\n<li>对每一对相邻元素作同样的工作,从开始第一对到结尾的最后一对。在这一点,最后的元素应 该会是最大的数。</li>\n<li>针对所有的元素重复以上的步骤,除了最后一个。</li>\n<li>持续每次对越来越少的元素重复上面的步骤,直到没有任何一对数字需要比较。</li>\n</ul>\n</li>\n<li><p>代码</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> nums[<span class=\"number\">8</span>] = &#123;<span class=\"number\">99</span>, <span class=\"number\">12</span>, <span class=\"number\">88</span>, <span class=\"number\">34</span>, <span class=\"number\">5</span>, <span class=\"number\">44</span>, <span class=\"number\">12</span>, <span class=\"number\">100</span>&#125;;</div><div class=\"line\"><span class=\"keyword\">int</span> length = <span class=\"keyword\">sizeof</span>(nums) / <span class=\"keyword\">sizeof</span>(nums[<span class=\"number\">0</span>]);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; length; i++) &#123;</div><div class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"排序前: nums[%i] = %i\\n\"</span>, i, nums[i]);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"----------\\n\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; length - <span class=\"number\">1</span>; i++) &#123;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; length - <span class=\"number\">1</span> - i; j++) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (nums[j] &gt; nums[j + <span class=\"number\">1</span>]) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> temp = nums[j];</div><div class=\"line\">            nums[j] = nums[j + <span class=\"number\">1</span>];</div><div class=\"line\">            nums[j + <span class=\"number\">1</span>] = temp;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; length; i++) &#123;</div><div class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"排序后: nums[%i] = %i\\n\"</span>, i, nums[i]);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>​</p>\n</li>\n</ol>\n<h3 id=\"三-插入排序\"><a href=\"#三-插入排序\" class=\"headerlink\" title=\"三. 插入排序\"></a>三. 插入排序</h3><ol>\n<li><p>原理</p>\n<p>插入即表示将一个新的数据插入到一个有序数组中，并继续保持有序。例如有一个长度为N的无序数组，进行N-1次的插入即能完成排序；第一次，数组第1个数认为是有序的数组，将数组第二个元素插入仅有1个有序的数组中；第二次，数组前两个元素组成有序的数组，将数组第三个元素插入由两个元素构成的有序数组中……第N-1次，数组前N-1个元素组成有序的数组，将数组的第N个元素插入由N-1个元素构成的有序数组中，则完成了整个插入排序。</p>\n</li>\n<li><p>基本思想</p>\n<p>插入排序是在一个已经有序的小序列的基础上，一次插入一个元素。当然，刚开始这个有序的小序列只有1个元素，就是第一个元素。比较是从有序序列的末尾开始，也就是想要插入的元素和已经有序的最大者开始比起，如果比它大则直接插入在其后面，否则一直往前找直到找到它该插入的位置。如果碰见一个和插入元素相等的，那么插入元素把想插入的元素放在相等元素的后面。所以，相等元素的前后顺序没有改变，从原无序序列出去的顺序就是排好序后的顺序，所以插入排序是稳定的。</p>\n</li>\n<li><p>代码</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> nums[<span class=\"number\">8</span>] = &#123;<span class=\"number\">99</span>, <span class=\"number\">12</span>, <span class=\"number\">88</span>, <span class=\"number\">34</span>, <span class=\"number\">5</span>, <span class=\"number\">44</span>, <span class=\"number\">12</span>, <span class=\"number\">100</span>&#125;;</div><div class=\"line\"><span class=\"keyword\">int</span> length = <span class=\"keyword\">sizeof</span>(nums) / <span class=\"keyword\">sizeof</span>(nums[<span class=\"number\">0</span>]);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; length; i++) &#123;</div><div class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"排序前: nums[%i] = %i\\n\"</span>, i, nums[i]);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"----------\\n\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> i, j, temp;</div><div class=\"line\"><span class=\"keyword\">for</span> (i = <span class=\"number\">1</span>; i &lt; length; i++) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (nums[i] &lt; nums[i - <span class=\"number\">1</span>])&#123;</div><div class=\"line\">        temp = nums[i];</div><div class=\"line\">        <span class=\"keyword\">for</span> (j = i - <span class=\"number\">1</span>; j &gt;= <span class=\"number\">0</span> &amp;&amp; nums[j] &gt; temp; j--)</div><div class=\"line\">            nums[j + <span class=\"number\">1</span>] = nums[j];</div><div class=\"line\">        nums[j + <span class=\"number\">1</span>] = temp;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; length; i++) &#123;</div><div class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"排序后: nums[%i] = %i\\n\"</span>, i, nums[i]);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>​</p>\n</li>\n</ol>"},{"title":"IOS学习之作业篇(一)","date":"2016-03-26T05:45:08.000Z","_content":"\n平时学习时的课后作业归纳,仅自己学习使用.\n\n<!-- more -->\n\n## 实战技术\n### day01\n1. **`+load`和`+initialize`的区别是什么？**\n* `+load`:是在类加载到内存的时候调用,只会调用一次\n* `+initialize`:是在第一次使用类或者子类的时候调用,会调用多次\n2. **`UITabBarCOntroller`控制器中view的内部结构?**\n* 存放子控制器的`view`\n* `tabbar`: height = 49;\n\n\n### day02\n1. **简述你对协议的理解?**\n* **为什么使用协议**: 当有些事情,自己不想做,交给别人,就搞个协议.实例:Appdelegate\n* **什么时候使用协议**: 延展到封装自己框架(自定义类),常常通过协议给外界提供接.\n2. **UICollectionView使用步骤?**\n* `UICollectionView`在创建的时候就需要初始化一个布局参数,设置数据.\n* `cell`必须通过注册,不能通过alloc创建.\n* `UICollectionView`默认内部并没有子控件,需要我们手动去添加自定义cell\n\n### day03\n1. **category和extension的区别?**\n* category是分类;只能扩充方法,不能添加属性.\n* extension是类扩展(匿名分类,类目);可以添加属性,也可以声明方法.\n* category常常给系统类扩展方法.\n* extension用于自定义类.\n2. **runtime实现的机制是什么,有哪些用法，一般用于干嘛?**\n* runtime实现的机制是运行时机制:只有在运行的时候才能确定调用哪些方法\n* 用法:\n     * 遍历类中所有属性和方法,可以自己写一套字典转模型工具类\n     * 动态给分类添加属性,需求:当想把一个属性保存系统的类中\n     * 交换方法,系统方法达不到我们需求,想给系统的方法扩充一些功能\n     * 动态添加方法\n\n### day04\n1. **什么时候会发生EXC BAD ACCESS异常？**\n* 解释EXC BAD ACCESS:野指针错误\n* 怎么才会导致这个错误:访问不该访问的对象\n* 避免这种:当一个对象被销毁,记得清空指针\n2. **怎么研究新的API?**\n* 百度 iOS10API\n* WWDC和苹果官方文档 英文能力很好 毅力\n* 在新xcode中创建项目,在旧的xcode去打开,发现很多错误,碰见一些感兴趣 查一查\n* 查看别人blog,关注一些牛人微博,猫神,新的技术 及时更新 关注: 简书\n\n\n## 项目准备\n### day01\n1. 你是怎么理解bounds的\n* frame: 控件可视范围 相对于 父控件\n* bounds: 也是指的是范围 指的是 控件可视范围 在 '内容中' 区域 . 控件可视范围相对于内容\n* 内容:每个控件都有自己内容,而且是无限大,而且这个控件的所有子控件都是相对于内容\n2. 数据传值的几种方式\n* 顺传:直接定义属性传值\n* 逆传:代理,block,通知\n  * 通知传值:当谁也拿不到谁的事情,可以采取使用通知传值\n\n### day02\n1. KVC底层怎么实现的?\n   KVC全称为`key value coding`即**键值编码**:运行时动态的给对象发送setValue:forKey消息 设置数据;\n   **底层实现:**\n* 去模型中查找有没有setValue:，直接调用这个对象setValue:赋值\n* 如果没有setValue:，就在模型中查找value属性\n* 如果没有value属性，就查找带_的成员属性\n* 如果还没有就报 \n2. KVO底层怎么实现的?\n   KVO全称为`Key Value Observer`即**键值监听**:观察一个对象的某一个属性发生改变.当发生改变时,通知另外一个对象做事情;\n   **底层实现:**\n   * 当第一次观察一个对象时,Runtime会动态的创建一个继承自该对象所属类的子类 NSKVONotifying_(父类的名字)\n   * 这个新创建的子类重写了所有被观察属性的 setter 方法，并且在内部给观察者发送通知，通知所有观察对象值的更改。\n   * 最后把这个对象所在类的 isa指针 指向这个新创建的子类\n\n### day03\n1. 简述项目开发的步骤<br>\n  * **独立开发:**\n    * 需求文档:描述下应用功能\n    * 查看原型图:描述app每个界面 和 怎么与用户交互\n    * 根据原型图搭建基本项目结构,开始按模块去开发\n    * 界面搭建完,再去查看接口文档,请求数据,然后展示<br>\n  * **迭代开发:**\n    * 根据组长,项目经理提供excel去做,这里就有每月的任务\n    * 需要去寻找找到对应的类做事情,1.根据类名,去猜 2.通过断点去调试,一层一层去寻找\n2. 如何做一个新的模块\n* 根据原型图,划分结构\n* 搭建界面\n* 参照接口文档,请求数据,展示数据\n* 调整界面细节,提高用户体验\n* 处理界面业务逻辑(功能)\n\n\n","source":"_posts/IOS学习之作业篇(OC).md","raw":"---\ntitle: IOS学习之作业篇(一)\ndate: 2016-03-26 13:45:08\ncategories: iOS\ntags: [Objective-C]\n---\n\n平时学习时的课后作业归纳,仅自己学习使用.\n\n<!-- more -->\n\n## 实战技术\n### day01\n1. **`+load`和`+initialize`的区别是什么？**\n* `+load`:是在类加载到内存的时候调用,只会调用一次\n* `+initialize`:是在第一次使用类或者子类的时候调用,会调用多次\n2. **`UITabBarCOntroller`控制器中view的内部结构?**\n* 存放子控制器的`view`\n* `tabbar`: height = 49;\n\n\n### day02\n1. **简述你对协议的理解?**\n* **为什么使用协议**: 当有些事情,自己不想做,交给别人,就搞个协议.实例:Appdelegate\n* **什么时候使用协议**: 延展到封装自己框架(自定义类),常常通过协议给外界提供接.\n2. **UICollectionView使用步骤?**\n* `UICollectionView`在创建的时候就需要初始化一个布局参数,设置数据.\n* `cell`必须通过注册,不能通过alloc创建.\n* `UICollectionView`默认内部并没有子控件,需要我们手动去添加自定义cell\n\n### day03\n1. **category和extension的区别?**\n* category是分类;只能扩充方法,不能添加属性.\n* extension是类扩展(匿名分类,类目);可以添加属性,也可以声明方法.\n* category常常给系统类扩展方法.\n* extension用于自定义类.\n2. **runtime实现的机制是什么,有哪些用法，一般用于干嘛?**\n* runtime实现的机制是运行时机制:只有在运行的时候才能确定调用哪些方法\n* 用法:\n     * 遍历类中所有属性和方法,可以自己写一套字典转模型工具类\n     * 动态给分类添加属性,需求:当想把一个属性保存系统的类中\n     * 交换方法,系统方法达不到我们需求,想给系统的方法扩充一些功能\n     * 动态添加方法\n\n### day04\n1. **什么时候会发生EXC BAD ACCESS异常？**\n* 解释EXC BAD ACCESS:野指针错误\n* 怎么才会导致这个错误:访问不该访问的对象\n* 避免这种:当一个对象被销毁,记得清空指针\n2. **怎么研究新的API?**\n* 百度 iOS10API\n* WWDC和苹果官方文档 英文能力很好 毅力\n* 在新xcode中创建项目,在旧的xcode去打开,发现很多错误,碰见一些感兴趣 查一查\n* 查看别人blog,关注一些牛人微博,猫神,新的技术 及时更新 关注: 简书\n\n\n## 项目准备\n### day01\n1. 你是怎么理解bounds的\n* frame: 控件可视范围 相对于 父控件\n* bounds: 也是指的是范围 指的是 控件可视范围 在 '内容中' 区域 . 控件可视范围相对于内容\n* 内容:每个控件都有自己内容,而且是无限大,而且这个控件的所有子控件都是相对于内容\n2. 数据传值的几种方式\n* 顺传:直接定义属性传值\n* 逆传:代理,block,通知\n  * 通知传值:当谁也拿不到谁的事情,可以采取使用通知传值\n\n### day02\n1. KVC底层怎么实现的?\n   KVC全称为`key value coding`即**键值编码**:运行时动态的给对象发送setValue:forKey消息 设置数据;\n   **底层实现:**\n* 去模型中查找有没有setValue:，直接调用这个对象setValue:赋值\n* 如果没有setValue:，就在模型中查找value属性\n* 如果没有value属性，就查找带_的成员属性\n* 如果还没有就报 \n2. KVO底层怎么实现的?\n   KVO全称为`Key Value Observer`即**键值监听**:观察一个对象的某一个属性发生改变.当发生改变时,通知另外一个对象做事情;\n   **底层实现:**\n   * 当第一次观察一个对象时,Runtime会动态的创建一个继承自该对象所属类的子类 NSKVONotifying_(父类的名字)\n   * 这个新创建的子类重写了所有被观察属性的 setter 方法，并且在内部给观察者发送通知，通知所有观察对象值的更改。\n   * 最后把这个对象所在类的 isa指针 指向这个新创建的子类\n\n### day03\n1. 简述项目开发的步骤<br>\n  * **独立开发:**\n    * 需求文档:描述下应用功能\n    * 查看原型图:描述app每个界面 和 怎么与用户交互\n    * 根据原型图搭建基本项目结构,开始按模块去开发\n    * 界面搭建完,再去查看接口文档,请求数据,然后展示<br>\n  * **迭代开发:**\n    * 根据组长,项目经理提供excel去做,这里就有每月的任务\n    * 需要去寻找找到对应的类做事情,1.根据类名,去猜 2.通过断点去调试,一层一层去寻找\n2. 如何做一个新的模块\n* 根据原型图,划分结构\n* 搭建界面\n* 参照接口文档,请求数据,展示数据\n* 调整界面细节,提高用户体验\n* 处理界面业务逻辑(功能)\n\n\n","slug":"IOS学习之作业篇(OC)","published":1,"updated":"2017-04-28T08:39:10.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6686xku0008xe9z73hjqe3p","content":"<p>平时学习时的课后作业归纳,仅自己学习使用.</p>\n<a id=\"more\"></a>\n<h2 id=\"实战技术\"><a href=\"#实战技术\" class=\"headerlink\" title=\"实战技术\"></a>实战技术</h2><h3 id=\"day01\"><a href=\"#day01\" class=\"headerlink\" title=\"day01\"></a>day01</h3><ol>\n<li><strong><code>+load</code>和<code>+initialize</code>的区别是什么？</strong></li>\n</ol>\n<ul>\n<li><code>+load</code>:是在类加载到内存的时候调用,只会调用一次</li>\n<li><code>+initialize</code>:是在第一次使用类或者子类的时候调用,会调用多次</li>\n</ul>\n<ol>\n<li><strong><code>UITabBarCOntroller</code>控制器中view的内部结构?</strong></li>\n</ol>\n<ul>\n<li>存放子控制器的<code>view</code></li>\n<li><code>tabbar</code>: height = 49;</li>\n</ul>\n<h3 id=\"day02\"><a href=\"#day02\" class=\"headerlink\" title=\"day02\"></a>day02</h3><ol>\n<li><strong>简述你对协议的理解?</strong></li>\n</ol>\n<ul>\n<li><strong>为什么使用协议</strong>: 当有些事情,自己不想做,交给别人,就搞个协议.实例:Appdelegate</li>\n<li><strong>什么时候使用协议</strong>: 延展到封装自己框架(自定义类),常常通过协议给外界提供接.</li>\n</ul>\n<ol>\n<li><strong>UICollectionView使用步骤?</strong></li>\n</ol>\n<ul>\n<li><code>UICollectionView</code>在创建的时候就需要初始化一个布局参数,设置数据.</li>\n<li><code>cell</code>必须通过注册,不能通过alloc创建.</li>\n<li><code>UICollectionView</code>默认内部并没有子控件,需要我们手动去添加自定义cell</li>\n</ul>\n<h3 id=\"day03\"><a href=\"#day03\" class=\"headerlink\" title=\"day03\"></a>day03</h3><ol>\n<li><strong>category和extension的区别?</strong></li>\n</ol>\n<ul>\n<li>category是分类;只能扩充方法,不能添加属性.</li>\n<li>extension是类扩展(匿名分类,类目);可以添加属性,也可以声明方法.</li>\n<li>category常常给系统类扩展方法.</li>\n<li>extension用于自定义类.</li>\n</ul>\n<ol>\n<li><strong>runtime实现的机制是什么,有哪些用法，一般用于干嘛?</strong></li>\n</ol>\n<ul>\n<li>runtime实现的机制是运行时机制:只有在运行的时候才能确定调用哪些方法</li>\n<li>用法:<ul>\n<li>遍历类中所有属性和方法,可以自己写一套字典转模型工具类</li>\n<li>动态给分类添加属性,需求:当想把一个属性保存系统的类中</li>\n<li>交换方法,系统方法达不到我们需求,想给系统的方法扩充一些功能</li>\n<li>动态添加方法</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"day04\"><a href=\"#day04\" class=\"headerlink\" title=\"day04\"></a>day04</h3><ol>\n<li><strong>什么时候会发生EXC BAD ACCESS异常？</strong></li>\n</ol>\n<ul>\n<li>解释EXC BAD ACCESS:野指针错误</li>\n<li>怎么才会导致这个错误:访问不该访问的对象</li>\n<li>避免这种:当一个对象被销毁,记得清空指针</li>\n</ul>\n<ol>\n<li><strong>怎么研究新的API?</strong></li>\n</ol>\n<ul>\n<li>百度 iOS10API</li>\n<li>WWDC和苹果官方文档 英文能力很好 毅力</li>\n<li>在新xcode中创建项目,在旧的xcode去打开,发现很多错误,碰见一些感兴趣 查一查</li>\n<li>查看别人blog,关注一些牛人微博,猫神,新的技术 及时更新 关注: 简书</li>\n</ul>\n<h2 id=\"项目准备\"><a href=\"#项目准备\" class=\"headerlink\" title=\"项目准备\"></a>项目准备</h2><h3 id=\"day01-1\"><a href=\"#day01-1\" class=\"headerlink\" title=\"day01\"></a>day01</h3><ol>\n<li>你是怎么理解bounds的</li>\n</ol>\n<ul>\n<li>frame: 控件可视范围 相对于 父控件</li>\n<li>bounds: 也是指的是范围 指的是 控件可视范围 在 ‘内容中’ 区域 . 控件可视范围相对于内容</li>\n<li>内容:每个控件都有自己内容,而且是无限大,而且这个控件的所有子控件都是相对于内容</li>\n</ul>\n<ol>\n<li>数据传值的几种方式</li>\n</ol>\n<ul>\n<li>顺传:直接定义属性传值</li>\n<li>逆传:代理,block,通知<ul>\n<li>通知传值:当谁也拿不到谁的事情,可以采取使用通知传值</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"day02-1\"><a href=\"#day02-1\" class=\"headerlink\" title=\"day02\"></a>day02</h3><ol>\n<li>KVC底层怎么实现的?<br>KVC全称为<code>key value coding</code>即<strong>键值编码</strong>:运行时动态的给对象发送setValue:forKey消息 设置数据;<br><strong>底层实现:</strong></li>\n</ol>\n<ul>\n<li>去模型中查找有没有setValue:，直接调用这个对象setValue:赋值</li>\n<li>如果没有setValue:，就在模型中查找value属性</li>\n<li>如果没有value属性，就查找带_的成员属性</li>\n<li>如果还没有就报 </li>\n</ul>\n<ol>\n<li>KVO底层怎么实现的?<br>KVO全称为<code>Key Value Observer</code>即<strong>键值监听</strong>:观察一个对象的某一个属性发生改变.当发生改变时,通知另外一个对象做事情;<br><strong>底层实现:</strong><ul>\n<li>当第一次观察一个对象时,Runtime会动态的创建一个继承自该对象所属类的子类 NSKVONotifying_(父类的名字)</li>\n<li>这个新创建的子类重写了所有被观察属性的 setter 方法，并且在内部给观察者发送通知，通知所有观察对象值的更改。</li>\n<li>最后把这个对象所在类的 isa指针 指向这个新创建的子类</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"day03-1\"><a href=\"#day03-1\" class=\"headerlink\" title=\"day03\"></a>day03</h3><ol>\n<li>简述项目开发的步骤<br><ul>\n<li><strong>独立开发:</strong><ul>\n<li>需求文档:描述下应用功能</li>\n<li>查看原型图:描述app每个界面 和 怎么与用户交互</li>\n<li>根据原型图搭建基本项目结构,开始按模块去开发</li>\n<li>界面搭建完,再去查看接口文档,请求数据,然后展示<br></li>\n</ul>\n</li>\n<li><strong>迭代开发:</strong><ul>\n<li>根据组长,项目经理提供excel去做,这里就有每月的任务</li>\n<li>需要去寻找找到对应的类做事情,1.根据类名,去猜 2.通过断点去调试,一层一层去寻找</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>如何做一个新的模块</li>\n</ol>\n<ul>\n<li>根据原型图,划分结构</li>\n<li>搭建界面</li>\n<li>参照接口文档,请求数据,展示数据</li>\n<li>调整界面细节,提高用户体验</li>\n<li>处理界面业务逻辑(功能)</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>平时学习时的课后作业归纳,仅自己学习使用.</p>","more":"<h2 id=\"实战技术\"><a href=\"#实战技术\" class=\"headerlink\" title=\"实战技术\"></a>实战技术</h2><h3 id=\"day01\"><a href=\"#day01\" class=\"headerlink\" title=\"day01\"></a>day01</h3><ol>\n<li><strong><code>+load</code>和<code>+initialize</code>的区别是什么？</strong></li>\n</ol>\n<ul>\n<li><code>+load</code>:是在类加载到内存的时候调用,只会调用一次</li>\n<li><code>+initialize</code>:是在第一次使用类或者子类的时候调用,会调用多次</li>\n</ul>\n<ol>\n<li><strong><code>UITabBarCOntroller</code>控制器中view的内部结构?</strong></li>\n</ol>\n<ul>\n<li>存放子控制器的<code>view</code></li>\n<li><code>tabbar</code>: height = 49;</li>\n</ul>\n<h3 id=\"day02\"><a href=\"#day02\" class=\"headerlink\" title=\"day02\"></a>day02</h3><ol>\n<li><strong>简述你对协议的理解?</strong></li>\n</ol>\n<ul>\n<li><strong>为什么使用协议</strong>: 当有些事情,自己不想做,交给别人,就搞个协议.实例:Appdelegate</li>\n<li><strong>什么时候使用协议</strong>: 延展到封装自己框架(自定义类),常常通过协议给外界提供接.</li>\n</ul>\n<ol>\n<li><strong>UICollectionView使用步骤?</strong></li>\n</ol>\n<ul>\n<li><code>UICollectionView</code>在创建的时候就需要初始化一个布局参数,设置数据.</li>\n<li><code>cell</code>必须通过注册,不能通过alloc创建.</li>\n<li><code>UICollectionView</code>默认内部并没有子控件,需要我们手动去添加自定义cell</li>\n</ul>\n<h3 id=\"day03\"><a href=\"#day03\" class=\"headerlink\" title=\"day03\"></a>day03</h3><ol>\n<li><strong>category和extension的区别?</strong></li>\n</ol>\n<ul>\n<li>category是分类;只能扩充方法,不能添加属性.</li>\n<li>extension是类扩展(匿名分类,类目);可以添加属性,也可以声明方法.</li>\n<li>category常常给系统类扩展方法.</li>\n<li>extension用于自定义类.</li>\n</ul>\n<ol>\n<li><strong>runtime实现的机制是什么,有哪些用法，一般用于干嘛?</strong></li>\n</ol>\n<ul>\n<li>runtime实现的机制是运行时机制:只有在运行的时候才能确定调用哪些方法</li>\n<li>用法:<ul>\n<li>遍历类中所有属性和方法,可以自己写一套字典转模型工具类</li>\n<li>动态给分类添加属性,需求:当想把一个属性保存系统的类中</li>\n<li>交换方法,系统方法达不到我们需求,想给系统的方法扩充一些功能</li>\n<li>动态添加方法</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"day04\"><a href=\"#day04\" class=\"headerlink\" title=\"day04\"></a>day04</h3><ol>\n<li><strong>什么时候会发生EXC BAD ACCESS异常？</strong></li>\n</ol>\n<ul>\n<li>解释EXC BAD ACCESS:野指针错误</li>\n<li>怎么才会导致这个错误:访问不该访问的对象</li>\n<li>避免这种:当一个对象被销毁,记得清空指针</li>\n</ul>\n<ol>\n<li><strong>怎么研究新的API?</strong></li>\n</ol>\n<ul>\n<li>百度 iOS10API</li>\n<li>WWDC和苹果官方文档 英文能力很好 毅力</li>\n<li>在新xcode中创建项目,在旧的xcode去打开,发现很多错误,碰见一些感兴趣 查一查</li>\n<li>查看别人blog,关注一些牛人微博,猫神,新的技术 及时更新 关注: 简书</li>\n</ul>\n<h2 id=\"项目准备\"><a href=\"#项目准备\" class=\"headerlink\" title=\"项目准备\"></a>项目准备</h2><h3 id=\"day01-1\"><a href=\"#day01-1\" class=\"headerlink\" title=\"day01\"></a>day01</h3><ol>\n<li>你是怎么理解bounds的</li>\n</ol>\n<ul>\n<li>frame: 控件可视范围 相对于 父控件</li>\n<li>bounds: 也是指的是范围 指的是 控件可视范围 在 ‘内容中’ 区域 . 控件可视范围相对于内容</li>\n<li>内容:每个控件都有自己内容,而且是无限大,而且这个控件的所有子控件都是相对于内容</li>\n</ul>\n<ol>\n<li>数据传值的几种方式</li>\n</ol>\n<ul>\n<li>顺传:直接定义属性传值</li>\n<li>逆传:代理,block,通知<ul>\n<li>通知传值:当谁也拿不到谁的事情,可以采取使用通知传值</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"day02-1\"><a href=\"#day02-1\" class=\"headerlink\" title=\"day02\"></a>day02</h3><ol>\n<li>KVC底层怎么实现的?<br>KVC全称为<code>key value coding</code>即<strong>键值编码</strong>:运行时动态的给对象发送setValue:forKey消息 设置数据;<br><strong>底层实现:</strong></li>\n</ol>\n<ul>\n<li>去模型中查找有没有setValue:，直接调用这个对象setValue:赋值</li>\n<li>如果没有setValue:，就在模型中查找value属性</li>\n<li>如果没有value属性，就查找带_的成员属性</li>\n<li>如果还没有就报 </li>\n</ul>\n<ol>\n<li>KVO底层怎么实现的?<br>KVO全称为<code>Key Value Observer</code>即<strong>键值监听</strong>:观察一个对象的某一个属性发生改变.当发生改变时,通知另外一个对象做事情;<br><strong>底层实现:</strong><ul>\n<li>当第一次观察一个对象时,Runtime会动态的创建一个继承自该对象所属类的子类 NSKVONotifying_(父类的名字)</li>\n<li>这个新创建的子类重写了所有被观察属性的 setter 方法，并且在内部给观察者发送通知，通知所有观察对象值的更改。</li>\n<li>最后把这个对象所在类的 isa指针 指向这个新创建的子类</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"day03-1\"><a href=\"#day03-1\" class=\"headerlink\" title=\"day03\"></a>day03</h3><ol>\n<li>简述项目开发的步骤<br><ul>\n<li><strong>独立开发:</strong><ul>\n<li>需求文档:描述下应用功能</li>\n<li>查看原型图:描述app每个界面 和 怎么与用户交互</li>\n<li>根据原型图搭建基本项目结构,开始按模块去开发</li>\n<li>界面搭建完,再去查看接口文档,请求数据,然后展示<br></li>\n</ul>\n</li>\n<li><strong>迭代开发:</strong><ul>\n<li>根据组长,项目经理提供excel去做,这里就有每月的任务</li>\n<li>需要去寻找找到对应的类做事情,1.根据类名,去猜 2.通过断点去调试,一层一层去寻找</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>如何做一个新的模块</li>\n</ol>\n<ul>\n<li>根据原型图,划分结构</li>\n<li>搭建界面</li>\n<li>参照接口文档,请求数据,展示数据</li>\n<li>调整界面细节,提高用户体验</li>\n<li>处理界面业务逻辑(功能)</li>\n</ul>"},{"title":"OC学习","date":"2017-03-30T06:53:12.000Z","_content":"\n1. `+load`和`+initialize`区别\n\n   * `+load`: 是在类加载到内存的时候调用, 仅调用一次\n   * `+initialize`: 是在第一次使用类或者子类的时候调用,会调用多次\n\n2. runtime\n\n   * runtime实现的机制是运行时机制,\n\n   * 用法:\n\n     * 遍历类中所有属性和方法,可以自己写一套字典转模型工具类\n     * 动态给分类添加属性,需求:当想把一个属性保存系统的类中交换方法,系统方法达不到我们需求,想给系统的方法扩充一些功能\n     * 动态添加方法\n\n     <!-- more -->\n\n3. `bounds`理解\n\n   * `frame`: 控件可视范围 相对于 父控件\n   * `bounds`: 也是指的是范围 指的是 控件可视范围 在 ‘内容中’ 区域 . 控件可视范围相对于内容\n   * `内容`:每个控件都有自己内容,而且是无限大,而且这个控件的所有子控件都是相对于内容\n\n4. 数据传值\n\n   * 顺传:直接定义属性传值\n   * 逆传:代理,block,通知\n   * 通知传值:当谁也拿不到谁的事情,可以采取使用通知传值\n\n5. KVC\n\n   KVC全称为`key value coding`即**键值编码**:运行时动态的给对象发送setValue:forKey消息 设置数据;\n\n   * 当第一次观察一个对象时,Runtime会动态的创建一个继承自该对象所属类的子类 NSKVONotifying_(父类的名字)\n   * 这个新创建的子类重写了所有被观察属性的 setter 方法，并且在内部给观察者发送通知，通知所有观察对象值的更改\n   * 最后把这个对象所在类的 isa指针 指向这个新创建的子类\n\n6. 简述项目开发的步骤\n\n   * **独立开发:**\n     * 需求文档:描述下应用功能\n     * 查看原型图:描述app每个界面 和 怎么与用户交互\n     * 根据原型图搭建基本项目结构,开始按模块去开发\n     * 界面搭建完,再去查看接口文档,请求数据,然后展示\n   * **迭代开发:**\n     * 根据组长,项目经理提供excel去做,这里就有每月的任务\n     * 需要去寻找找到对应的类做事情,1.根据类名,去猜 2.通过断点去调试,一层一层去寻找\n\n7. 如何做一个新的模块\n\n   * 根据原型图,划分结构\n   * 搭建界面\n   * 参照接口文档,请求数据,展示数据\n   * 调整界面细节,提高用户体验\n   * 处理界面业务逻辑(功能)\n\n\n","source":"_posts/OC基本概念.md","raw":"---\ntitle: OC学习\ndate: 2017-03-30 14:53:12\ncategories: iOS\ntags: Objective-C\n---\n\n1. `+load`和`+initialize`区别\n\n   * `+load`: 是在类加载到内存的时候调用, 仅调用一次\n   * `+initialize`: 是在第一次使用类或者子类的时候调用,会调用多次\n\n2. runtime\n\n   * runtime实现的机制是运行时机制,\n\n   * 用法:\n\n     * 遍历类中所有属性和方法,可以自己写一套字典转模型工具类\n     * 动态给分类添加属性,需求:当想把一个属性保存系统的类中交换方法,系统方法达不到我们需求,想给系统的方法扩充一些功能\n     * 动态添加方法\n\n     <!-- more -->\n\n3. `bounds`理解\n\n   * `frame`: 控件可视范围 相对于 父控件\n   * `bounds`: 也是指的是范围 指的是 控件可视范围 在 ‘内容中’ 区域 . 控件可视范围相对于内容\n   * `内容`:每个控件都有自己内容,而且是无限大,而且这个控件的所有子控件都是相对于内容\n\n4. 数据传值\n\n   * 顺传:直接定义属性传值\n   * 逆传:代理,block,通知\n   * 通知传值:当谁也拿不到谁的事情,可以采取使用通知传值\n\n5. KVC\n\n   KVC全称为`key value coding`即**键值编码**:运行时动态的给对象发送setValue:forKey消息 设置数据;\n\n   * 当第一次观察一个对象时,Runtime会动态的创建一个继承自该对象所属类的子类 NSKVONotifying_(父类的名字)\n   * 这个新创建的子类重写了所有被观察属性的 setter 方法，并且在内部给观察者发送通知，通知所有观察对象值的更改\n   * 最后把这个对象所在类的 isa指针 指向这个新创建的子类\n\n6. 简述项目开发的步骤\n\n   * **独立开发:**\n     * 需求文档:描述下应用功能\n     * 查看原型图:描述app每个界面 和 怎么与用户交互\n     * 根据原型图搭建基本项目结构,开始按模块去开发\n     * 界面搭建完,再去查看接口文档,请求数据,然后展示\n   * **迭代开发:**\n     * 根据组长,项目经理提供excel去做,这里就有每月的任务\n     * 需要去寻找找到对应的类做事情,1.根据类名,去猜 2.通过断点去调试,一层一层去寻找\n\n7. 如何做一个新的模块\n\n   * 根据原型图,划分结构\n   * 搭建界面\n   * 参照接口文档,请求数据,展示数据\n   * 调整界面细节,提高用户体验\n   * 处理界面业务逻辑(功能)\n\n\n","slug":"OC基本概念","published":1,"updated":"2017-04-28T08:41:39.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6686xkz000cxe9zz1sxve06","content":"<ol>\n<li><p><code>+load</code>和<code>+initialize</code>区别</p>\n<ul>\n<li><code>+load</code>: 是在类加载到内存的时候调用, 仅调用一次</li>\n<li><code>+initialize</code>: 是在第一次使用类或者子类的时候调用,会调用多次</li>\n</ul>\n</li>\n<li><p>runtime</p>\n<ul>\n<li><p>runtime实现的机制是运行时机制,</p>\n</li>\n<li><p>用法:</p>\n<ul>\n<li>遍历类中所有属性和方法,可以自己写一套字典转模型工具类</li>\n<li>动态给分类添加属性,需求:当想把一个属性保存系统的类中交换方法,系统方法达不到我们需求,想给系统的方法扩充一些功能</li>\n<li>动态添加方法</li>\n</ul>\n<a id=\"more\"></a>\n</li>\n</ul>\n</li>\n<li><p><code>bounds</code>理解</p>\n<ul>\n<li><code>frame</code>: 控件可视范围 相对于 父控件</li>\n<li><code>bounds</code>: 也是指的是范围 指的是 控件可视范围 在 ‘内容中’ 区域 . 控件可视范围相对于内容</li>\n<li><code>内容</code>:每个控件都有自己内容,而且是无限大,而且这个控件的所有子控件都是相对于内容</li>\n</ul>\n</li>\n<li><p>数据传值</p>\n<ul>\n<li>顺传:直接定义属性传值</li>\n<li>逆传:代理,block,通知</li>\n<li>通知传值:当谁也拿不到谁的事情,可以采取使用通知传值</li>\n</ul>\n</li>\n<li><p>KVC</p>\n<p>KVC全称为<code>key value coding</code>即<strong>键值编码</strong>:运行时动态的给对象发送setValue:forKey消息 设置数据;</p>\n<ul>\n<li>当第一次观察一个对象时,Runtime会动态的创建一个继承自该对象所属类的子类 NSKVONotifying_(父类的名字)</li>\n<li>这个新创建的子类重写了所有被观察属性的 setter 方法，并且在内部给观察者发送通知，通知所有观察对象值的更改</li>\n<li>最后把这个对象所在类的 isa指针 指向这个新创建的子类</li>\n</ul>\n</li>\n<li><p>简述项目开发的步骤</p>\n<ul>\n<li><strong>独立开发:</strong><ul>\n<li>需求文档:描述下应用功能</li>\n<li>查看原型图:描述app每个界面 和 怎么与用户交互</li>\n<li>根据原型图搭建基本项目结构,开始按模块去开发</li>\n<li>界面搭建完,再去查看接口文档,请求数据,然后展示</li>\n</ul>\n</li>\n<li><strong>迭代开发:</strong><ul>\n<li>根据组长,项目经理提供excel去做,这里就有每月的任务</li>\n<li>需要去寻找找到对应的类做事情,1.根据类名,去猜 2.通过断点去调试,一层一层去寻找</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>如何做一个新的模块</p>\n<ul>\n<li>根据原型图,划分结构</li>\n<li>搭建界面</li>\n<li>参照接口文档,请求数据,展示数据</li>\n<li>调整界面细节,提高用户体验</li>\n<li>处理界面业务逻辑(功能)</li>\n</ul>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"<ol>\n<li><p><code>+load</code>和<code>+initialize</code>区别</p>\n<ul>\n<li><code>+load</code>: 是在类加载到内存的时候调用, 仅调用一次</li>\n<li><code>+initialize</code>: 是在第一次使用类或者子类的时候调用,会调用多次</li>\n</ul>\n</li>\n<li><p>runtime</p>\n<ul>\n<li><p>runtime实现的机制是运行时机制,</p>\n</li>\n<li><p>用法:</p>\n<ul>\n<li>遍历类中所有属性和方法,可以自己写一套字典转模型工具类</li>\n<li>动态给分类添加属性,需求:当想把一个属性保存系统的类中交换方法,系统方法达不到我们需求,想给系统的方法扩充一些功能</li>\n<li>动态添加方法</li>\n</ul>","more":"</li>\n</ul>\n</li>\n<li><p><code>bounds</code>理解</p>\n<ul>\n<li><code>frame</code>: 控件可视范围 相对于 父控件</li>\n<li><code>bounds</code>: 也是指的是范围 指的是 控件可视范围 在 ‘内容中’ 区域 . 控件可视范围相对于内容</li>\n<li><code>内容</code>:每个控件都有自己内容,而且是无限大,而且这个控件的所有子控件都是相对于内容</li>\n</ul>\n</li>\n<li><p>数据传值</p>\n<ul>\n<li>顺传:直接定义属性传值</li>\n<li>逆传:代理,block,通知</li>\n<li>通知传值:当谁也拿不到谁的事情,可以采取使用通知传值</li>\n</ul>\n</li>\n<li><p>KVC</p>\n<p>KVC全称为<code>key value coding</code>即<strong>键值编码</strong>:运行时动态的给对象发送setValue:forKey消息 设置数据;</p>\n<ul>\n<li>当第一次观察一个对象时,Runtime会动态的创建一个继承自该对象所属类的子类 NSKVONotifying_(父类的名字)</li>\n<li>这个新创建的子类重写了所有被观察属性的 setter 方法，并且在内部给观察者发送通知，通知所有观察对象值的更改</li>\n<li>最后把这个对象所在类的 isa指针 指向这个新创建的子类</li>\n</ul>\n</li>\n<li><p>简述项目开发的步骤</p>\n<ul>\n<li><strong>独立开发:</strong><ul>\n<li>需求文档:描述下应用功能</li>\n<li>查看原型图:描述app每个界面 和 怎么与用户交互</li>\n<li>根据原型图搭建基本项目结构,开始按模块去开发</li>\n<li>界面搭建完,再去查看接口文档,请求数据,然后展示</li>\n</ul>\n</li>\n<li><strong>迭代开发:</strong><ul>\n<li>根据组长,项目经理提供excel去做,这里就有每月的任务</li>\n<li>需要去寻找找到对应的类做事情,1.根据类名,去猜 2.通过断点去调试,一层一层去寻找</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>如何做一个新的模块</p>\n<ul>\n<li>根据原型图,划分结构</li>\n<li>搭建界面</li>\n<li>参照接口文档,请求数据,展示数据</li>\n<li>调整界面细节,提高用户体验</li>\n<li>处理界面业务逻辑(功能)</li>\n</ul>\n</li>\n</ol>"},{"title":"SVN常用命令","date":"2017-05-16T00:56:21.000Z","_content":"\n\n\n1. 将文件checkout到本地\n\n   `svn checkout <path>`;\n\n   `svn co <path>`\n\n2. 添加新的文件\n\n   `svn add <file>`: 添加名为file的文件\n\n   `svn add *.m`: 添加后缀为.m的所有文\n\n3. 提交到版本库\n\n   `svn commit -m 'message'`\n\n   `svn ci`\n\n4. 更新到某个版本\n\n   `svn update -r m <path>`\n\n   `svn update`:将当前目录以及子目录下的所有文件都更新到最新版本。 \n\n   `svn up`\n\n<!-- more -->\n\n5. 查看文件或者目录状态\n   * `svn status`: 【?：不在svn的控制中；M：内容被修改；C：发生冲突；A：预定加入到版本库；K：被锁定】\n   * `svn st`: 简写\n6. 删除文件\n   * `svn delete <file name>`: 删除\n   * `svn ci \"message\"`: 提交\n7. 查看历史\n   * `svn log`\n8. 查看文件详情\n   * `svn info`","source":"_posts/SVN常用命令.md","raw":"---\ntitle: SVN常用命令\ndate: 2017-05-16 08:56:21\ncategories: 命令\ntags: 命令\n---\n\n\n\n1. 将文件checkout到本地\n\n   `svn checkout <path>`;\n\n   `svn co <path>`\n\n2. 添加新的文件\n\n   `svn add <file>`: 添加名为file的文件\n\n   `svn add *.m`: 添加后缀为.m的所有文\n\n3. 提交到版本库\n\n   `svn commit -m 'message'`\n\n   `svn ci`\n\n4. 更新到某个版本\n\n   `svn update -r m <path>`\n\n   `svn update`:将当前目录以及子目录下的所有文件都更新到最新版本。 \n\n   `svn up`\n\n<!-- more -->\n\n5. 查看文件或者目录状态\n   * `svn status`: 【?：不在svn的控制中；M：内容被修改；C：发生冲突；A：预定加入到版本库；K：被锁定】\n   * `svn st`: 简写\n6. 删除文件\n   * `svn delete <file name>`: 删除\n   * `svn ci \"message\"`: 提交\n7. 查看历史\n   * `svn log`\n8. 查看文件详情\n   * `svn info`","slug":"SVN常用命令","published":1,"updated":"2017-05-16T01:18:41.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6686xl3000exe9zlmb7lqnz","content":"<ol>\n<li><p>将文件checkout到本地</p>\n<p><code>svn checkout &lt;path&gt;</code>;</p>\n<p><code>svn co &lt;path&gt;</code></p>\n</li>\n<li><p>添加新的文件</p>\n<p><code>svn add &lt;file&gt;</code>: 添加名为file的文件</p>\n<p><code>svn add *.m</code>: 添加后缀为.m的所有文</p>\n</li>\n<li><p>提交到版本库</p>\n<p><code>svn commit -m &#39;message&#39;</code></p>\n<p><code>svn ci</code></p>\n</li>\n<li><p>更新到某个版本</p>\n<p><code>svn update -r m &lt;path&gt;</code></p>\n<p><code>svn update</code>:将当前目录以及子目录下的所有文件都更新到最新版本。 </p>\n<p><code>svn up</code></p>\n</li>\n</ol>\n<a id=\"more\"></a>\n<ol>\n<li>查看文件或者目录状态<ul>\n<li><code>svn status</code>: 【?：不在svn的控制中；M：内容被修改；C：发生冲突；A：预定加入到版本库；K：被锁定】</li>\n<li><code>svn st</code>: 简写</li>\n</ul>\n</li>\n<li>删除文件<ul>\n<li><code>svn delete &lt;file name&gt;</code>: 删除</li>\n<li><code>svn ci &quot;message&quot;</code>: 提交</li>\n</ul>\n</li>\n<li>查看历史<ul>\n<li><code>svn log</code></li>\n</ul>\n</li>\n<li>查看文件详情<ul>\n<li><code>svn info</code></li>\n</ul>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"<ol>\n<li><p>将文件checkout到本地</p>\n<p><code>svn checkout &lt;path&gt;</code>;</p>\n<p><code>svn co &lt;path&gt;</code></p>\n</li>\n<li><p>添加新的文件</p>\n<p><code>svn add &lt;file&gt;</code>: 添加名为file的文件</p>\n<p><code>svn add *.m</code>: 添加后缀为.m的所有文</p>\n</li>\n<li><p>提交到版本库</p>\n<p><code>svn commit -m &#39;message&#39;</code></p>\n<p><code>svn ci</code></p>\n</li>\n<li><p>更新到某个版本</p>\n<p><code>svn update -r m &lt;path&gt;</code></p>\n<p><code>svn update</code>:将当前目录以及子目录下的所有文件都更新到最新版本。 </p>\n<p><code>svn up</code></p>\n</li>\n</ol>","more":"<ol>\n<li>查看文件或者目录状态<ul>\n<li><code>svn status</code>: 【?：不在svn的控制中；M：内容被修改；C：发生冲突；A：预定加入到版本库；K：被锁定】</li>\n<li><code>svn st</code>: 简写</li>\n</ul>\n</li>\n<li>删除文件<ul>\n<li><code>svn delete &lt;file name&gt;</code>: 删除</li>\n<li><code>svn ci &quot;message&quot;</code>: 提交</li>\n</ul>\n</li>\n<li>查看历史<ul>\n<li><code>svn log</code></li>\n</ul>\n</li>\n<li>查看文件详情<ul>\n<li><code>svn info</code></li>\n</ul>\n</li>\n</ol>"},{"title":"Swift学习笔记02","date":"2016-04-24T07:34:28.000Z","_content":"\n### 一、类型转换\n#### 1. is as\n* is: 判断是否是某一种类型(`isKindOfClass`)\n* as: Swift字符串转OC字符串`str as NSString`\n\n#### 2. as? as!\n* as?: 将AnyObject转成可选类型,通过判断可选类型是否有值,来决定是否转换成功\n* as!: 将AngObject转成具体类型,但是如果不是该类型程勋会崩溃\n  <!-- more -->\n\n```swift\nlet arr : [AnyObject] = [\"ren\", 20, 1.77]\nlet objc = arr.first\n// NSObject? 转成 String?\nif let name = objc as? String {\nprint(name)\n}\n//不推荐使用,转换不成功会崩溃\nlet name1 = objc as! String\n```\n---\n\n### 二、函数\n#### 1. 函数介绍\n* 函数相当于OC中的方法\n* func 是关键字, 多个参数列表之间可以使用逗号分开,没有参数之间写()\n* 使用箭头`->`指向返回值类型\n* 如果没有返回值类型,返回值类型写`Void` 也可以不写\n\n```swift  \n   func 函数名(参数列表) -> 返回值类型 {\n        代码块...\n        return 返回值\n   }\n```\n\n#### 2. 常见的函数类型\n\n```swift\n// 1.没有参数,没有返回值\nfunc about() -> Void {\n    print(\"没有参数,没用返回值\")\n}\n// 调用函数\nabout()\n// 简单写法\nfunc about1() -> () {\n    print(\"如果没用返回值,Void可以写成()\")\n}\nfunc about2() {\n    print(\"如果没有返回值,后面的内容可以都不写\")\n}\n\n// 2.有参数,没用返回值\nfunc callPhone(phoneNum : String) {\n    \n}\n\n// 3.没用参数,有返回值\nfunc readMessage() -> String {\n    return \"返回值\"\n}\nvar str = readMessage()\nprint(str)\n\n// 4.有参数,有返回值\nfunc sum(num1 : Int, num2 : Int) -> Int {\n    return num1 + num2\n}\nvar result = sum(20, num2: 30)\nprint(result)\n\n// 5.有多个返回值的函数\nlet nums = [1, 3, 4, 8, 22, 23]\nfunc getNumCount(nums : [Int]) -> (oddCount : Int, evenCount : Int) {\n    var oddCount = 0\n    var evenCount = 0\n    for num in nums {\n        if num % 2 == 0 {\n            oddCount++\n        } else {\n            evenCount++\n        }\n    }\n    return (oddCount, evenCount)\n}\n\nlet result = getNumCount(nums)\nresult.oddCount\nresult.evenCount\n```\n\n#### 3. 函数的使用注意\n* 注意一: 外部参数和内部参数\n    * 在函数内部可以看到的参数就是内部参数\n    * 在函数外部可以看到的参数就是外部参数\n    * 默认情况下,从第二个参数开始,参数既是内部参数也是外部参数\n    * 如果第一个参数也想要有外部参数,可以设置标签:`在变量名前添加`\n    * 如果不想要外部参数,可以参参数前加`_`\n\n```swift\nfunc sum(num1 num1 : Int, a num2 : Int, _ num3 : Int) -> Int {\n    return num1 + num2 + num3\n}\nsum(num1: 10, a: 20, 30) // 60\n\n// 方法重载:方法名称相同,但是参数不同,可以称之为方法的重载(了解)\nfunc sum(num1 : Int, num2 : Int) -> Int {\n    return num1 + num2\n}\n```\n* 注意二: 默认参数\n     * 某些情况,如果没有传入具体的参数可以使用默认参数\n\n```swift\nfunc demo(name : String = \"默认参数\") {}\n```\n* 注意三: 可变参数\n     * swift中函数的参数可以变化, 它可以接受不确定数量的参数\n     * 这些参数的类型必须相同\n     * 在参数类型后面加`...` 即可表示可变参数\n\n```swift\nfunc sum(nums : Double...) -> Double {\n    var total = 0.0\n    for num in muns {\n        total += num\n    }\n    return total\n}\n```\n* 注意四: 引用类型(指针类型)\n    * 默认情况下, 函数的参数是值传递, 如果想改变外面的变量,则需要传递变量的地址\n    * 通过Swift的`inout`关键字可以实现\n\n```swift\nvar a = 10\nvar b = 20\n\nfunc exchange(inout a : Int, inout b : Int) -> Int {\n    let temp = a\n    a = b\n    b = temp\n}\n// 调用\nexchange(&a, b: &b) // a == 20. b == 10\n```\n\n#### 4. 函数的嵌套使用\n* swift中函数可以嵌套使用,但不推荐\n\n```swift\nfunc test1() {\n    func test2() {\n        print(\"test2\")\n    }\n    print(\"test1\")\n    test2() // test2 必须在test1中调用 因为test2的作用域只在test1中\n}\ntest1()\n// 打印结果: \n// test1\n// test2\n```\n\n#### 5. 函数的类型\n* 每个函数都有属于自己的类型,由函数的参数类型和返回值类型组成\n    * 在下面的例子中定义了两个简单的数学函数: `addTwoInts` 和 `multiplyTwoInts`\n    * 这两个函数都传入了两个Int类型, 返回一个合适的Int类型\n    * 这两个函数的类型是`(Int, Int) -> Int`\n\n```swift\nfunc addTwoInts(a : Int, b : Int) -> Int {\n    return a + b\n}\n\nfunc multiplyTwoInt(a : Int, b : Int) -> Int {\n    return a * b\n}\n```\n\n* 抽取两个函数的类型并使用\n\n```swift\n// 定义函数的类型\nvar mathFunction : (Int, Int) -> Int = addTwoInts\n// 使用函数的名称\nmathFunction(10, 20) // 30\n// 给函数的标识符赋值\nmathFunction = multiplyTwoInt\nmathFunction(10, 20) // 200\n```\n\n* 函数的类型作为方法的参数\n\n```swift\nfunc result(a : Int, b : Int, method : (Int, Int) -> Int) {\n    print(method(a, b)) // 打印结果\n}\n//  调用\nresult(10, b: 20, method: addTwoInts) // 30\nresult(10, b: 20, method: multiplyTwoInt) // 200\n```\n\n* 函数作为方法的返回值\n\n```swift\nfunc test2() -> ((Int, Int) -> Int) {\n    return addTwoInts\n}\nlet tmpFunc = test2()\ntmpFunc(20, 30) // 50\n```\n---\n\n### 三、 枚举\n#### 1. 基本概念\n* 概念介绍\n    * 枚举定义了一个通用类型的一组相关的值,使你可以在你的代码中以一个安全的方式来使用这些值.\n    * 在C/OC中枚举的值只能为整型\n    * Swift中的枚举更加灵活,它可以提供一个值是字符串,字符,整型或浮点值\n* 枚举语法\n\n   ```swift\n   enum 枚举名 {\n        枚举值\n   }\n   ```\n\n#### 2. 枚举定义\n* 以下是指南针四个方向的一个例子\n    * `case`关键字表明新的一行成员值将被定义\n    * 与C 和 OC 不一样, Swift的枚举成员在被创建的时候不会被赋一个默认值\n\n   ```swift\n   enum CompassPoint {\n        case North\n        case South\n        case East\n        case West\n   }\n   ```\n\n* 方式二: 多个陈远志可以出现在同一行上\n\n   ```swift\n   enum CompassPoint {\n        case North, South, East, West\n   }\n   ```\n\n#### 3. 给枚举类型赋值\n* 枚举类型赋值可以是字符串/字符/整型/浮点型\n    * 注意如果有给枚举类型赋值,则必须在枚举类型后面明确说明具体的类型\n\n ```swift\n // 方式一\n enum CompassPoint : Int {\n      case North = 1\n      case South = 2\n      case East = 3\n      case West = 4\n }\n\n // 方式二\n enum CompassPoint : Int {\n      case North = 1, South, East, West\n }\n\n // 赋具体值\n let point = CompassPoint(rawValue : 1)\n ```\n---\n\n### 四、结构体\n#### 1. 结构体介绍(struct)\n* 基本概念\n    * 结构体是由一系列具有相同类型或不同类型的数据构成的数据集合\n    * 结构体指的是一种数据结构\n    * 结构体是值类型,在方法中传递时是值传递\n* 结构体的定义格式\n\n ```swift\n struct Location {\n      var x : Double\n      var y : Double\n }\n ```\n\n#### 2. 结构体增强\n* 扩充构造函数\n     * 默认情况下创建的Location时使用Location(x : x值, y : y值)\n     * 但是为了让我们在使用该结构体是更加灵活, swift还可以对构造函数进行个扩充\n     * 扩充的注意点\n         * 在扩充的构造函数中必须保证成员变量是有值的\n         * 扩充的构造函数会覆盖原有的构造函数\n\n ```swift\n struct Location {\n      var x : Double\n      var y : Double\n\n      // 原有的构造函数\n      init() {\n      }\n    \n      // 扩充的构造函数\n      init(x : Double, y : Double) {\n          self.x = x\n          self.y = y\n      }\n }\n let location = Location(x: 100, y: 100)\n ```\n\n* 扩充方法\n     * 为了让结构体使用更加灵活,swift的结构体中可以扩充方法\n     * 例子:为了Location结构体扩充两个方法\n         * 向水平方向移动的方法\n         * 向垂直方向移动的方法\n\n ```swift\n struct Location {\n      var x : Double\n      var y : Double\n\n      init(x : Double, y : Double) {\n          self.x = x\n          self.y = y\n      }\n\n      mutating func moveH(x : Double) {\n          self.x += x\n      }\n\n      mutating func moveV(y : Double) {\n          self.y += y\n      }\n   }\n ```\n ---\n\n### 五、类的使用\n#### 1. 类的介绍和定义\n* `class`是Swift中的关键字,用于定义类\n* 注意:\n    * 定义的类可以没有父类,那么该类是rootClass\n    * 通常情况下,定义类是,继承NSObject\n\n    ```swift\n    class 类名 : superClass {\n        // 类的属性和方法\n    }\n    ```\n\n#### 2. 类的属性\n* swift中类的属性有多种\n    * 存储属性: 存储实例的常量和变量\n        * 可以给存储属性提供一个默认值，也可以在初始化方法中对其进行初始化\n* 计算属性: 通过某种方式计算出来的属性\n    * 计算属性并不存储实际的值，而是提供一个getter和一个可选的setter来间接获取和设置其它属性\n        * 计算属性一般只提供getter方法\n        * 如果只提供getter，而不提供setter，则该计算属性为只读属性,并且可以省略get{}\n    * 类属性: 与整个类自身相关的属性\n        * 所有的类和实例都共有一份类属性.因此在某一处修改之后,该类属性就会被修改\n        * 类属性的设置和修改,需要通过类来完成\n* 监听属性的改变\n    * 在OC中我们可以重写`set`方法来监听属性的改变\n    * Swift中可以通过属性观察者来监听和响应属性值的变化\n    * 通常是监听存储属性和类属性的改变.(对于计算属性，我们不需要定义属性观察者，因为我们可以在计算属性的`setter`中直接观察并响应这种值的变化)\n    * 我们通过设置以下观察方法来定义观察者\n        * `willSet`：在属性值被存储之前设置。此时新属性值作为一个常量参数被传入。该参数名默认为`newValue`，我们可以自己定义该参数名\n        * `didSet`：在新属性值被存储后立即调用。与`willSet`相同，此时传入的是属性的旧值，默认参数名为`oldValue`\n        * `willSet`与`didSet`只有在属性第一次被设置时才会调用，在初始化时，不会去调用这些监听方法\n    * 监听的方式如下:\n\n   ```swift\n   class Person : NSObject {\n      var name : String? {\n          // 可以给newValue自定义名称\n          willSet (new){ // 属性即将改变,还未改变时会调用的方法\n              // 在该方法中有一个默认的系统属性newValue,用于存储值\n          }\n          // 可以给oldValue自定义名称\n          didSet (old) { // 属性值已经改变了,会调用的方法\n              // 在该方法中有一个默认的系统属性oldValue,用于存储旧值\n          }\n      }\n   }\n   ```\n\n#### 3. 类的构造函数\n* 构造函数的介绍\n    * 构造函数类似于OC中的初始化方法:`init`方法\n    * 默认情况下载创建一个类时,必然会调用一个构造函数\n    * 即便是没有编写任何构造函数，编译器也会提供一个默认的构造函数。\n    * 如果是继承自`NSObject`,可以对父类的构造函数进行重写\n* 基本使用\n    * 类的属性必须有值\n    * 如果不是在定义时初始化值,可以在构造函数中赋值\n* 初始化时给属性赋值\n    * 很多时候,我们在创建一个对象时就会给属性赋值\n    * 可以自定义构造函数\n    * **注意**:如果自定义了构造函数,会覆盖init()方法.即不在有默认的构造函数\n* 字典转模型(初始化时传入字典)\n    * 真实创建对象时,更多的是将字典转成模型\n    * 注意\n        * 去字典中取出的是`NSObject`,任意类型.\n        * 可以通过`as!`转成需要的类型,再赋值(不可以直接赋值)\n\n     ```swift\n      class Person: NSObject {\n              var name : String\n              var age : Int\n          \n              // 自定义构造函数,会覆盖init()函数\n              init(dict : [String : NSObject]) {\n                  name = dict[\"name\"] as! String\n                  age = dict[\"age\"] as! Int\n              }\n       }\n\n          // 创建一个Person对象\n          let dict = [\"name\" : \"why\", \"age\" : 18]\n          let p = Person(dict: dict)\n     ```\n\n* 字典转模型(KVC)\n    * 利用KVC字典转模型会更加方便\n    * 注意\n        * KVC并不能保证会给所有的属性赋值\n        * 因此属性需要有默认值\n            * 基本数据类型默认值设置为0\n            * 对象或者结构体类型定义为可选类型即可(可选类型没有赋值前为nil)\n\n      ```swift\n       class Person: NSObject {\n            // 结构体或者类的类型,必须是可选类型.因为不能保证一定会赋值\n            var name : String?\n        \n            // 基本数据类型不能是可选类型,否则KVC无法转化\n            var age : Int = 0\n        \n            // 自定义构造函数,会覆盖init()函数\n            init(dict : [String : NSObject]) {\n                // 必须先初始化对象\n                super.init()\n        \n                // 调用对象的KVC方法字典转模型\n                setValuesForKeysWithDictionary(dict)\n            }\n        }\n        \n       // 创建一个Person对象\n       let dict = [\"name\" : \"why\", \"age\" : 18]\n       let p = Person(dict: dict)\n      ```\n\n#### 4. 类的析构函数\n* Swift 会自动释放不再需要的实例以释放资源\n    * Swift 通过自动引用计数（ARC）处理实例的内存管理\n    * 当引用计数为0时,系统会自动调用析构函数(不可以手动调用)\n    * 通常在析构函数中释放一些资源(如移除通知等操作)\n* 析构函数的写法\n\n```swift\ndeinit {\n// 执行析构过程\n}\n```\n\n\n","source":"_posts/Swift学习笔记02.md","raw":"---\ntitle: Swift学习笔记02\ndate: 2016-04-24 15:34:28\ncategories: iOS\ntags: [Swift]\n---\n\n### 一、类型转换\n#### 1. is as\n* is: 判断是否是某一种类型(`isKindOfClass`)\n* as: Swift字符串转OC字符串`str as NSString`\n\n#### 2. as? as!\n* as?: 将AnyObject转成可选类型,通过判断可选类型是否有值,来决定是否转换成功\n* as!: 将AngObject转成具体类型,但是如果不是该类型程勋会崩溃\n  <!-- more -->\n\n```swift\nlet arr : [AnyObject] = [\"ren\", 20, 1.77]\nlet objc = arr.first\n// NSObject? 转成 String?\nif let name = objc as? String {\nprint(name)\n}\n//不推荐使用,转换不成功会崩溃\nlet name1 = objc as! String\n```\n---\n\n### 二、函数\n#### 1. 函数介绍\n* 函数相当于OC中的方法\n* func 是关键字, 多个参数列表之间可以使用逗号分开,没有参数之间写()\n* 使用箭头`->`指向返回值类型\n* 如果没有返回值类型,返回值类型写`Void` 也可以不写\n\n```swift  \n   func 函数名(参数列表) -> 返回值类型 {\n        代码块...\n        return 返回值\n   }\n```\n\n#### 2. 常见的函数类型\n\n```swift\n// 1.没有参数,没有返回值\nfunc about() -> Void {\n    print(\"没有参数,没用返回值\")\n}\n// 调用函数\nabout()\n// 简单写法\nfunc about1() -> () {\n    print(\"如果没用返回值,Void可以写成()\")\n}\nfunc about2() {\n    print(\"如果没有返回值,后面的内容可以都不写\")\n}\n\n// 2.有参数,没用返回值\nfunc callPhone(phoneNum : String) {\n    \n}\n\n// 3.没用参数,有返回值\nfunc readMessage() -> String {\n    return \"返回值\"\n}\nvar str = readMessage()\nprint(str)\n\n// 4.有参数,有返回值\nfunc sum(num1 : Int, num2 : Int) -> Int {\n    return num1 + num2\n}\nvar result = sum(20, num2: 30)\nprint(result)\n\n// 5.有多个返回值的函数\nlet nums = [1, 3, 4, 8, 22, 23]\nfunc getNumCount(nums : [Int]) -> (oddCount : Int, evenCount : Int) {\n    var oddCount = 0\n    var evenCount = 0\n    for num in nums {\n        if num % 2 == 0 {\n            oddCount++\n        } else {\n            evenCount++\n        }\n    }\n    return (oddCount, evenCount)\n}\n\nlet result = getNumCount(nums)\nresult.oddCount\nresult.evenCount\n```\n\n#### 3. 函数的使用注意\n* 注意一: 外部参数和内部参数\n    * 在函数内部可以看到的参数就是内部参数\n    * 在函数外部可以看到的参数就是外部参数\n    * 默认情况下,从第二个参数开始,参数既是内部参数也是外部参数\n    * 如果第一个参数也想要有外部参数,可以设置标签:`在变量名前添加`\n    * 如果不想要外部参数,可以参参数前加`_`\n\n```swift\nfunc sum(num1 num1 : Int, a num2 : Int, _ num3 : Int) -> Int {\n    return num1 + num2 + num3\n}\nsum(num1: 10, a: 20, 30) // 60\n\n// 方法重载:方法名称相同,但是参数不同,可以称之为方法的重载(了解)\nfunc sum(num1 : Int, num2 : Int) -> Int {\n    return num1 + num2\n}\n```\n* 注意二: 默认参数\n     * 某些情况,如果没有传入具体的参数可以使用默认参数\n\n```swift\nfunc demo(name : String = \"默认参数\") {}\n```\n* 注意三: 可变参数\n     * swift中函数的参数可以变化, 它可以接受不确定数量的参数\n     * 这些参数的类型必须相同\n     * 在参数类型后面加`...` 即可表示可变参数\n\n```swift\nfunc sum(nums : Double...) -> Double {\n    var total = 0.0\n    for num in muns {\n        total += num\n    }\n    return total\n}\n```\n* 注意四: 引用类型(指针类型)\n    * 默认情况下, 函数的参数是值传递, 如果想改变外面的变量,则需要传递变量的地址\n    * 通过Swift的`inout`关键字可以实现\n\n```swift\nvar a = 10\nvar b = 20\n\nfunc exchange(inout a : Int, inout b : Int) -> Int {\n    let temp = a\n    a = b\n    b = temp\n}\n// 调用\nexchange(&a, b: &b) // a == 20. b == 10\n```\n\n#### 4. 函数的嵌套使用\n* swift中函数可以嵌套使用,但不推荐\n\n```swift\nfunc test1() {\n    func test2() {\n        print(\"test2\")\n    }\n    print(\"test1\")\n    test2() // test2 必须在test1中调用 因为test2的作用域只在test1中\n}\ntest1()\n// 打印结果: \n// test1\n// test2\n```\n\n#### 5. 函数的类型\n* 每个函数都有属于自己的类型,由函数的参数类型和返回值类型组成\n    * 在下面的例子中定义了两个简单的数学函数: `addTwoInts` 和 `multiplyTwoInts`\n    * 这两个函数都传入了两个Int类型, 返回一个合适的Int类型\n    * 这两个函数的类型是`(Int, Int) -> Int`\n\n```swift\nfunc addTwoInts(a : Int, b : Int) -> Int {\n    return a + b\n}\n\nfunc multiplyTwoInt(a : Int, b : Int) -> Int {\n    return a * b\n}\n```\n\n* 抽取两个函数的类型并使用\n\n```swift\n// 定义函数的类型\nvar mathFunction : (Int, Int) -> Int = addTwoInts\n// 使用函数的名称\nmathFunction(10, 20) // 30\n// 给函数的标识符赋值\nmathFunction = multiplyTwoInt\nmathFunction(10, 20) // 200\n```\n\n* 函数的类型作为方法的参数\n\n```swift\nfunc result(a : Int, b : Int, method : (Int, Int) -> Int) {\n    print(method(a, b)) // 打印结果\n}\n//  调用\nresult(10, b: 20, method: addTwoInts) // 30\nresult(10, b: 20, method: multiplyTwoInt) // 200\n```\n\n* 函数作为方法的返回值\n\n```swift\nfunc test2() -> ((Int, Int) -> Int) {\n    return addTwoInts\n}\nlet tmpFunc = test2()\ntmpFunc(20, 30) // 50\n```\n---\n\n### 三、 枚举\n#### 1. 基本概念\n* 概念介绍\n    * 枚举定义了一个通用类型的一组相关的值,使你可以在你的代码中以一个安全的方式来使用这些值.\n    * 在C/OC中枚举的值只能为整型\n    * Swift中的枚举更加灵活,它可以提供一个值是字符串,字符,整型或浮点值\n* 枚举语法\n\n   ```swift\n   enum 枚举名 {\n        枚举值\n   }\n   ```\n\n#### 2. 枚举定义\n* 以下是指南针四个方向的一个例子\n    * `case`关键字表明新的一行成员值将被定义\n    * 与C 和 OC 不一样, Swift的枚举成员在被创建的时候不会被赋一个默认值\n\n   ```swift\n   enum CompassPoint {\n        case North\n        case South\n        case East\n        case West\n   }\n   ```\n\n* 方式二: 多个陈远志可以出现在同一行上\n\n   ```swift\n   enum CompassPoint {\n        case North, South, East, West\n   }\n   ```\n\n#### 3. 给枚举类型赋值\n* 枚举类型赋值可以是字符串/字符/整型/浮点型\n    * 注意如果有给枚举类型赋值,则必须在枚举类型后面明确说明具体的类型\n\n ```swift\n // 方式一\n enum CompassPoint : Int {\n      case North = 1\n      case South = 2\n      case East = 3\n      case West = 4\n }\n\n // 方式二\n enum CompassPoint : Int {\n      case North = 1, South, East, West\n }\n\n // 赋具体值\n let point = CompassPoint(rawValue : 1)\n ```\n---\n\n### 四、结构体\n#### 1. 结构体介绍(struct)\n* 基本概念\n    * 结构体是由一系列具有相同类型或不同类型的数据构成的数据集合\n    * 结构体指的是一种数据结构\n    * 结构体是值类型,在方法中传递时是值传递\n* 结构体的定义格式\n\n ```swift\n struct Location {\n      var x : Double\n      var y : Double\n }\n ```\n\n#### 2. 结构体增强\n* 扩充构造函数\n     * 默认情况下创建的Location时使用Location(x : x值, y : y值)\n     * 但是为了让我们在使用该结构体是更加灵活, swift还可以对构造函数进行个扩充\n     * 扩充的注意点\n         * 在扩充的构造函数中必须保证成员变量是有值的\n         * 扩充的构造函数会覆盖原有的构造函数\n\n ```swift\n struct Location {\n      var x : Double\n      var y : Double\n\n      // 原有的构造函数\n      init() {\n      }\n    \n      // 扩充的构造函数\n      init(x : Double, y : Double) {\n          self.x = x\n          self.y = y\n      }\n }\n let location = Location(x: 100, y: 100)\n ```\n\n* 扩充方法\n     * 为了让结构体使用更加灵活,swift的结构体中可以扩充方法\n     * 例子:为了Location结构体扩充两个方法\n         * 向水平方向移动的方法\n         * 向垂直方向移动的方法\n\n ```swift\n struct Location {\n      var x : Double\n      var y : Double\n\n      init(x : Double, y : Double) {\n          self.x = x\n          self.y = y\n      }\n\n      mutating func moveH(x : Double) {\n          self.x += x\n      }\n\n      mutating func moveV(y : Double) {\n          self.y += y\n      }\n   }\n ```\n ---\n\n### 五、类的使用\n#### 1. 类的介绍和定义\n* `class`是Swift中的关键字,用于定义类\n* 注意:\n    * 定义的类可以没有父类,那么该类是rootClass\n    * 通常情况下,定义类是,继承NSObject\n\n    ```swift\n    class 类名 : superClass {\n        // 类的属性和方法\n    }\n    ```\n\n#### 2. 类的属性\n* swift中类的属性有多种\n    * 存储属性: 存储实例的常量和变量\n        * 可以给存储属性提供一个默认值，也可以在初始化方法中对其进行初始化\n* 计算属性: 通过某种方式计算出来的属性\n    * 计算属性并不存储实际的值，而是提供一个getter和一个可选的setter来间接获取和设置其它属性\n        * 计算属性一般只提供getter方法\n        * 如果只提供getter，而不提供setter，则该计算属性为只读属性,并且可以省略get{}\n    * 类属性: 与整个类自身相关的属性\n        * 所有的类和实例都共有一份类属性.因此在某一处修改之后,该类属性就会被修改\n        * 类属性的设置和修改,需要通过类来完成\n* 监听属性的改变\n    * 在OC中我们可以重写`set`方法来监听属性的改变\n    * Swift中可以通过属性观察者来监听和响应属性值的变化\n    * 通常是监听存储属性和类属性的改变.(对于计算属性，我们不需要定义属性观察者，因为我们可以在计算属性的`setter`中直接观察并响应这种值的变化)\n    * 我们通过设置以下观察方法来定义观察者\n        * `willSet`：在属性值被存储之前设置。此时新属性值作为一个常量参数被传入。该参数名默认为`newValue`，我们可以自己定义该参数名\n        * `didSet`：在新属性值被存储后立即调用。与`willSet`相同，此时传入的是属性的旧值，默认参数名为`oldValue`\n        * `willSet`与`didSet`只有在属性第一次被设置时才会调用，在初始化时，不会去调用这些监听方法\n    * 监听的方式如下:\n\n   ```swift\n   class Person : NSObject {\n      var name : String? {\n          // 可以给newValue自定义名称\n          willSet (new){ // 属性即将改变,还未改变时会调用的方法\n              // 在该方法中有一个默认的系统属性newValue,用于存储值\n          }\n          // 可以给oldValue自定义名称\n          didSet (old) { // 属性值已经改变了,会调用的方法\n              // 在该方法中有一个默认的系统属性oldValue,用于存储旧值\n          }\n      }\n   }\n   ```\n\n#### 3. 类的构造函数\n* 构造函数的介绍\n    * 构造函数类似于OC中的初始化方法:`init`方法\n    * 默认情况下载创建一个类时,必然会调用一个构造函数\n    * 即便是没有编写任何构造函数，编译器也会提供一个默认的构造函数。\n    * 如果是继承自`NSObject`,可以对父类的构造函数进行重写\n* 基本使用\n    * 类的属性必须有值\n    * 如果不是在定义时初始化值,可以在构造函数中赋值\n* 初始化时给属性赋值\n    * 很多时候,我们在创建一个对象时就会给属性赋值\n    * 可以自定义构造函数\n    * **注意**:如果自定义了构造函数,会覆盖init()方法.即不在有默认的构造函数\n* 字典转模型(初始化时传入字典)\n    * 真实创建对象时,更多的是将字典转成模型\n    * 注意\n        * 去字典中取出的是`NSObject`,任意类型.\n        * 可以通过`as!`转成需要的类型,再赋值(不可以直接赋值)\n\n     ```swift\n      class Person: NSObject {\n              var name : String\n              var age : Int\n          \n              // 自定义构造函数,会覆盖init()函数\n              init(dict : [String : NSObject]) {\n                  name = dict[\"name\"] as! String\n                  age = dict[\"age\"] as! Int\n              }\n       }\n\n          // 创建一个Person对象\n          let dict = [\"name\" : \"why\", \"age\" : 18]\n          let p = Person(dict: dict)\n     ```\n\n* 字典转模型(KVC)\n    * 利用KVC字典转模型会更加方便\n    * 注意\n        * KVC并不能保证会给所有的属性赋值\n        * 因此属性需要有默认值\n            * 基本数据类型默认值设置为0\n            * 对象或者结构体类型定义为可选类型即可(可选类型没有赋值前为nil)\n\n      ```swift\n       class Person: NSObject {\n            // 结构体或者类的类型,必须是可选类型.因为不能保证一定会赋值\n            var name : String?\n        \n            // 基本数据类型不能是可选类型,否则KVC无法转化\n            var age : Int = 0\n        \n            // 自定义构造函数,会覆盖init()函数\n            init(dict : [String : NSObject]) {\n                // 必须先初始化对象\n                super.init()\n        \n                // 调用对象的KVC方法字典转模型\n                setValuesForKeysWithDictionary(dict)\n            }\n        }\n        \n       // 创建一个Person对象\n       let dict = [\"name\" : \"why\", \"age\" : 18]\n       let p = Person(dict: dict)\n      ```\n\n#### 4. 类的析构函数\n* Swift 会自动释放不再需要的实例以释放资源\n    * Swift 通过自动引用计数（ARC）处理实例的内存管理\n    * 当引用计数为0时,系统会自动调用析构函数(不可以手动调用)\n    * 通常在析构函数中释放一些资源(如移除通知等操作)\n* 析构函数的写法\n\n```swift\ndeinit {\n// 执行析构过程\n}\n```\n\n\n","slug":"Swift学习笔记02","published":1,"updated":"2017-04-28T08:40:12.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6686xl6000hxe9z1xi23i6o","content":"<h3 id=\"一、类型转换\"><a href=\"#一、类型转换\" class=\"headerlink\" title=\"一、类型转换\"></a>一、类型转换</h3><h4 id=\"1-is-as\"><a href=\"#1-is-as\" class=\"headerlink\" title=\"1. is as\"></a>1. is as</h4><ul>\n<li>is: 判断是否是某一种类型(<code>isKindOfClass</code>)</li>\n<li>as: Swift字符串转OC字符串<code>str as NSString</code></li>\n</ul>\n<h4 id=\"2-as-as\"><a href=\"#2-as-as\" class=\"headerlink\" title=\"2. as? as!\"></a>2. as? as!</h4><ul>\n<li>as?: 将AnyObject转成可选类型,通过判断可选类型是否有值,来决定是否转换成功</li>\n<li>as!: 将AngObject转成具体类型,但是如果不是该类型程勋会崩溃<a id=\"more\"></a>\n</li>\n</ul>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> arr : [<span class=\"type\">AnyObject</span>] = [<span class=\"string\">\"ren\"</span>, <span class=\"number\">20</span>, <span class=\"number\">1.77</span>]</div><div class=\"line\"><span class=\"keyword\">let</span> objc = arr.first</div><div class=\"line\"><span class=\"comment\">// NSObject? 转成 String?</span></div><div class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">let</span> name = objc <span class=\"keyword\">as</span>? <span class=\"type\">String</span> &#123;</div><div class=\"line\"><span class=\"built_in\">print</span>(name)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//不推荐使用,转换不成功会崩溃</span></div><div class=\"line\"><span class=\"keyword\">let</span> name1 = objc <span class=\"keyword\">as</span>! <span class=\"type\">String</span></div></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"二、函数\"><a href=\"#二、函数\" class=\"headerlink\" title=\"二、函数\"></a>二、函数</h3><h4 id=\"1-函数介绍\"><a href=\"#1-函数介绍\" class=\"headerlink\" title=\"1. 函数介绍\"></a>1. 函数介绍</h4><ul>\n<li>函数相当于OC中的方法</li>\n<li>func 是关键字, 多个参数列表之间可以使用逗号分开,没有参数之间写()</li>\n<li>使用箭头<code>-&gt;</code>指向返回值类型</li>\n<li>如果没有返回值类型,返回值类型写<code>Void</code> 也可以不写</li>\n</ul>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> 函数名<span class=\"params\">(参数列表)</span></span> -&gt; 返回值类型 &#123;</div><div class=\"line\">     代码块...</div><div class=\"line\">     <span class=\"keyword\">return</span> 返回值</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"2-常见的函数类型\"><a href=\"#2-常见的函数类型\" class=\"headerlink\" title=\"2. 常见的函数类型\"></a>2. 常见的函数类型</h4><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 1.没有参数,没有返回值</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">about</span><span class=\"params\">()</span></span> -&gt; <span class=\"type\">Void</span> &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"没有参数,没用返回值\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// 调用函数</span></div><div class=\"line\">about()</div><div class=\"line\"><span class=\"comment\">// 简单写法</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">about1</span><span class=\"params\">()</span></span> -&gt; () &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"如果没用返回值,Void可以写成()\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">about2</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"如果没有返回值,后面的内容可以都不写\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 2.有参数,没用返回值</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">callPhone</span><span class=\"params\">(phoneNum : String)</span></span> &#123;</div><div class=\"line\">    </div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 3.没用参数,有返回值</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">readMessage</span><span class=\"params\">()</span></span> -&gt; <span class=\"type\">String</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"返回值\"</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> str = readMessage()</div><div class=\"line\"><span class=\"built_in\">print</span>(str)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 4.有参数,有返回值</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">sum</span><span class=\"params\">(num1 : Int, num2 : Int)</span></span> -&gt; <span class=\"type\">Int</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> num1 + num2</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> result = sum(<span class=\"number\">20</span>, num2: <span class=\"number\">30</span>)</div><div class=\"line\"><span class=\"built_in\">print</span>(result)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 5.有多个返回值的函数</span></div><div class=\"line\"><span class=\"keyword\">let</span> nums = [<span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">8</span>, <span class=\"number\">22</span>, <span class=\"number\">23</span>]</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">getNumCount</span><span class=\"params\">(nums : [Int])</span></span> -&gt; (oddCount : <span class=\"type\">Int</span>, evenCount : <span class=\"type\">Int</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> oddCount = <span class=\"number\">0</span></div><div class=\"line\">    <span class=\"keyword\">var</span> evenCount = <span class=\"number\">0</span></div><div class=\"line\">    <span class=\"keyword\">for</span> num <span class=\"keyword\">in</span> nums &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> num % <span class=\"number\">2</span> == <span class=\"number\">0</span> &#123;</div><div class=\"line\">            oddCount++</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            evenCount++</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> (oddCount, evenCount)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> result = getNumCount(nums)</div><div class=\"line\">result.oddCount</div><div class=\"line\">result.evenCount</div></pre></td></tr></table></figure>\n<h4 id=\"3-函数的使用注意\"><a href=\"#3-函数的使用注意\" class=\"headerlink\" title=\"3. 函数的使用注意\"></a>3. 函数的使用注意</h4><ul>\n<li>注意一: 外部参数和内部参数<ul>\n<li>在函数内部可以看到的参数就是内部参数</li>\n<li>在函数外部可以看到的参数就是外部参数</li>\n<li>默认情况下,从第二个参数开始,参数既是内部参数也是外部参数</li>\n<li>如果第一个参数也想要有外部参数,可以设置标签:<code>在变量名前添加</code></li>\n<li>如果不想要外部参数,可以参参数前加<code>_</code></li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">sum</span><span class=\"params\">(num1 num1 : Int, a num2 : Int, <span class=\"number\">_</span> num3 : Int)</span></span> -&gt; <span class=\"type\">Int</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> num1 + num2 + num3</div><div class=\"line\">&#125;</div><div class=\"line\">sum(num1: <span class=\"number\">10</span>, a: <span class=\"number\">20</span>, <span class=\"number\">30</span>) <span class=\"comment\">// 60</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 方法重载:方法名称相同,但是参数不同,可以称之为方法的重载(了解)</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">sum</span><span class=\"params\">(num1 : Int, num2 : Int)</span></span> -&gt; <span class=\"type\">Int</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> num1 + num2</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>注意二: 默认参数<ul>\n<li>某些情况,如果没有传入具体的参数可以使用默认参数</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">demo</span><span class=\"params\">(name : String = <span class=\"string\">\"默认参数\"</span>)</span></span> &#123;&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>注意三: 可变参数<ul>\n<li>swift中函数的参数可以变化, 它可以接受不确定数量的参数</li>\n<li>这些参数的类型必须相同</li>\n<li>在参数类型后面加<code>...</code> 即可表示可变参数</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">sum</span><span class=\"params\">(nums : Double...)</span></span> -&gt; <span class=\"type\">Double</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> total = <span class=\"number\">0.0</span></div><div class=\"line\">    <span class=\"keyword\">for</span> num <span class=\"keyword\">in</span> muns &#123;</div><div class=\"line\">        total += num</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> total</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>注意四: 引用类型(指针类型)<ul>\n<li>默认情况下, 函数的参数是值传递, 如果想改变外面的变量,则需要传递变量的地址</li>\n<li>通过Swift的<code>inout</code>关键字可以实现</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">10</span></div><div class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"number\">20</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">exchange</span><span class=\"params\">(<span class=\"keyword\">inout</span> a : Int, <span class=\"keyword\">inout</span> b : Int)</span></span> -&gt; <span class=\"type\">Int</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> temp = a</div><div class=\"line\">    a = b</div><div class=\"line\">    b = temp</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// 调用</span></div><div class=\"line\">exchange(&amp;a, b: &amp;b) <span class=\"comment\">// a == 20. b == 10</span></div></pre></td></tr></table></figure>\n<h4 id=\"4-函数的嵌套使用\"><a href=\"#4-函数的嵌套使用\" class=\"headerlink\" title=\"4. 函数的嵌套使用\"></a>4. 函数的嵌套使用</h4><ul>\n<li>swift中函数可以嵌套使用,但不推荐</li>\n</ul>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">test1</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">test2</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"test2\"</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"test1\"</span>)</div><div class=\"line\">    test2() <span class=\"comment\">// test2 必须在test1中调用 因为test2的作用域只在test1中</span></div><div class=\"line\">&#125;</div><div class=\"line\">test1()</div><div class=\"line\"><span class=\"comment\">// 打印结果: </span></div><div class=\"line\"><span class=\"comment\">// test1</span></div><div class=\"line\"><span class=\"comment\">// test2</span></div></pre></td></tr></table></figure>\n<h4 id=\"5-函数的类型\"><a href=\"#5-函数的类型\" class=\"headerlink\" title=\"5. 函数的类型\"></a>5. 函数的类型</h4><ul>\n<li>每个函数都有属于自己的类型,由函数的参数类型和返回值类型组成<ul>\n<li>在下面的例子中定义了两个简单的数学函数: <code>addTwoInts</code> 和 <code>multiplyTwoInts</code></li>\n<li>这两个函数都传入了两个Int类型, 返回一个合适的Int类型</li>\n<li>这两个函数的类型是<code>(Int, Int) -&gt; Int</code></li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">addTwoInts</span><span class=\"params\">(a : Int, b : Int)</span></span> -&gt; <span class=\"type\">Int</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> a + b</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">multiplyTwoInt</span><span class=\"params\">(a : Int, b : Int)</span></span> -&gt; <span class=\"type\">Int</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> a * b</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>抽取两个函数的类型并使用</li>\n</ul>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 定义函数的类型</span></div><div class=\"line\"><span class=\"keyword\">var</span> mathFunction : (<span class=\"type\">Int</span>, <span class=\"type\">Int</span>) -&gt; <span class=\"type\">Int</span> = addTwoInts</div><div class=\"line\"><span class=\"comment\">// 使用函数的名称</span></div><div class=\"line\">mathFunction(<span class=\"number\">10</span>, <span class=\"number\">20</span>) <span class=\"comment\">// 30</span></div><div class=\"line\"><span class=\"comment\">// 给函数的标识符赋值</span></div><div class=\"line\">mathFunction = multiplyTwoInt</div><div class=\"line\">mathFunction(<span class=\"number\">10</span>, <span class=\"number\">20</span>) <span class=\"comment\">// 200</span></div></pre></td></tr></table></figure>\n<ul>\n<li>函数的类型作为方法的参数</li>\n</ul>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">result</span><span class=\"params\">(a : Int, b : Int, method : <span class=\"params\">(Int, Int)</span></span></span> -&gt; <span class=\"type\">Int</span>) &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(method(a, b)) <span class=\"comment\">// 打印结果</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//  调用</span></div><div class=\"line\">result(<span class=\"number\">10</span>, b: <span class=\"number\">20</span>, method: addTwoInts) <span class=\"comment\">// 30</span></div><div class=\"line\">result(<span class=\"number\">10</span>, b: <span class=\"number\">20</span>, method: multiplyTwoInt) <span class=\"comment\">// 200</span></div></pre></td></tr></table></figure>\n<ul>\n<li>函数作为方法的返回值</li>\n</ul>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">test2</span><span class=\"params\">()</span></span> -&gt; ((<span class=\"type\">Int</span>, <span class=\"type\">Int</span>) -&gt; <span class=\"type\">Int</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> addTwoInts</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">let</span> tmpFunc = test2()</div><div class=\"line\">tmpFunc(<span class=\"number\">20</span>, <span class=\"number\">30</span>) <span class=\"comment\">// 50</span></div></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"三、-枚举\"><a href=\"#三、-枚举\" class=\"headerlink\" title=\"三、 枚举\"></a>三、 枚举</h3><h4 id=\"1-基本概念\"><a href=\"#1-基本概念\" class=\"headerlink\" title=\"1. 基本概念\"></a>1. 基本概念</h4><ul>\n<li>概念介绍<ul>\n<li>枚举定义了一个通用类型的一组相关的值,使你可以在你的代码中以一个安全的方式来使用这些值.</li>\n<li>在C/OC中枚举的值只能为整型</li>\n<li>Swift中的枚举更加灵活,它可以提供一个值是字符串,字符,整型或浮点值</li>\n</ul>\n</li>\n<li><p>枚举语法</p>\n <figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> 枚举名 </span>&#123;</div><div class=\"line\">     枚举值</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"2-枚举定义\"><a href=\"#2-枚举定义\" class=\"headerlink\" title=\"2. 枚举定义\"></a>2. 枚举定义</h4><ul>\n<li><p>以下是指南针四个方向的一个例子</p>\n<ul>\n<li><code>case</code>关键字表明新的一行成员值将被定义</li>\n<li><p>与C 和 OC 不一样, Swift的枚举成员在被创建的时候不会被赋一个默认值</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">CompassPoint</span> </span>&#123;</div><div class=\"line\">     <span class=\"keyword\">case</span> <span class=\"type\">North</span></div><div class=\"line\">     <span class=\"keyword\">case</span> <span class=\"type\">South</span></div><div class=\"line\">     <span class=\"keyword\">case</span> <span class=\"type\">East</span></div><div class=\"line\">     <span class=\"keyword\">case</span> <span class=\"type\">West</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>方式二: 多个陈远志可以出现在同一行上</p>\n <figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">CompassPoint</span> </span>&#123;</div><div class=\"line\">     <span class=\"keyword\">case</span> <span class=\"type\">North</span>, <span class=\"type\">South</span>, <span class=\"type\">East</span>, <span class=\"type\">West</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"3-给枚举类型赋值\"><a href=\"#3-给枚举类型赋值\" class=\"headerlink\" title=\"3. 给枚举类型赋值\"></a>3. 给枚举类型赋值</h4><ul>\n<li><p>枚举类型赋值可以是字符串/字符/整型/浮点型</p>\n<ul>\n<li>注意如果有给枚举类型赋值,则必须在枚举类型后面明确说明具体的类型</li>\n</ul>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 方式一</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">CompassPoint</span> : <span class=\"title\">Int</span> </span>&#123;</div><div class=\"line\">     <span class=\"keyword\">case</span> <span class=\"type\">North</span> = <span class=\"number\">1</span></div><div class=\"line\">     <span class=\"keyword\">case</span> <span class=\"type\">South</span> = <span class=\"number\">2</span></div><div class=\"line\">     <span class=\"keyword\">case</span> <span class=\"type\">East</span> = <span class=\"number\">3</span></div><div class=\"line\">     <span class=\"keyword\">case</span> <span class=\"type\">West</span> = <span class=\"number\">4</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 方式二</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">CompassPoint</span> : <span class=\"title\">Int</span> </span>&#123;</div><div class=\"line\">     <span class=\"keyword\">case</span> <span class=\"type\">North</span> = <span class=\"number\">1</span>, <span class=\"type\">South</span>, <span class=\"type\">East</span>, <span class=\"type\">West</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 赋具体值</span></div><div class=\"line\"><span class=\"keyword\">let</span> point = <span class=\"type\">CompassPoint</span>(rawValue : <span class=\"number\">1</span>)</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<hr>\n<h3 id=\"四、结构体\"><a href=\"#四、结构体\" class=\"headerlink\" title=\"四、结构体\"></a>四、结构体</h3><h4 id=\"1-结构体介绍-struct\"><a href=\"#1-结构体介绍-struct\" class=\"headerlink\" title=\"1. 结构体介绍(struct)\"></a>1. 结构体介绍(struct)</h4><ul>\n<li>基本概念<ul>\n<li>结构体是由一系列具有相同类型或不同类型的数据构成的数据集合</li>\n<li>结构体指的是一种数据结构</li>\n<li>结构体是值类型,在方法中传递时是值传递</li>\n</ul>\n</li>\n<li><p>结构体的定义格式</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Location</span> </span>&#123;</div><div class=\"line\">     <span class=\"keyword\">var</span> x : <span class=\"type\">Double</span></div><div class=\"line\">     <span class=\"keyword\">var</span> y : <span class=\"type\">Double</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"2-结构体增强\"><a href=\"#2-结构体增强\" class=\"headerlink\" title=\"2. 结构体增强\"></a>2. 结构体增强</h4><ul>\n<li><p>扩充构造函数</p>\n<ul>\n<li>默认情况下创建的Location时使用Location(x : x值, y : y值)</li>\n<li>但是为了让我们在使用该结构体是更加灵活, swift还可以对构造函数进行个扩充</li>\n<li>扩充的注意点<ul>\n<li>在扩充的构造函数中必须保证成员变量是有值的</li>\n<li>扩充的构造函数会覆盖原有的构造函数</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Location</span> </span>&#123;</div><div class=\"line\">     <span class=\"keyword\">var</span> x : <span class=\"type\">Double</span></div><div class=\"line\">     <span class=\"keyword\">var</span> y : <span class=\"type\">Double</span></div><div class=\"line\"></div><div class=\"line\">     <span class=\"comment\">// 原有的构造函数</span></div><div class=\"line\">     <span class=\"keyword\">init</span>() &#123;</div><div class=\"line\">     &#125;</div><div class=\"line\">   </div><div class=\"line\">     <span class=\"comment\">// 扩充的构造函数</span></div><div class=\"line\">     <span class=\"keyword\">init</span>(x : <span class=\"type\">Double</span>, y : <span class=\"type\">Double</span>) &#123;</div><div class=\"line\">         <span class=\"keyword\">self</span>.x = x</div><div class=\"line\">         <span class=\"keyword\">self</span>.y = y</div><div class=\"line\">     &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">let</span> location = <span class=\"type\">Location</span>(x: <span class=\"number\">100</span>, y: <span class=\"number\">100</span>)</div></pre></td></tr></table></figure>\n</li>\n<li><p>扩充方法</p>\n<ul>\n<li>为了让结构体使用更加灵活,swift的结构体中可以扩充方法</li>\n<li>例子:为了Location结构体扩充两个方法<ul>\n<li>向水平方向移动的方法</li>\n<li>向垂直方向移动的方法</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Location</span> </span>&#123;</div><div class=\"line\">     <span class=\"keyword\">var</span> x : <span class=\"type\">Double</span></div><div class=\"line\">     <span class=\"keyword\">var</span> y : <span class=\"type\">Double</span></div><div class=\"line\"></div><div class=\"line\">     <span class=\"keyword\">init</span>(x : <span class=\"type\">Double</span>, y : <span class=\"type\">Double</span>) &#123;</div><div class=\"line\">         <span class=\"keyword\">self</span>.x = x</div><div class=\"line\">         <span class=\"keyword\">self</span>.y = y</div><div class=\"line\">     &#125;</div><div class=\"line\"></div><div class=\"line\">     <span class=\"keyword\">mutating</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">moveH</span><span class=\"params\">(x : Double)</span></span> &#123;</div><div class=\"line\">         <span class=\"keyword\">self</span>.x += x</div><div class=\"line\">     &#125;</div><div class=\"line\"></div><div class=\"line\">     <span class=\"keyword\">mutating</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">moveV</span><span class=\"params\">(y : Double)</span></span> &#123;</div><div class=\"line\">         <span class=\"keyword\">self</span>.y += y</div><div class=\"line\">     &#125;</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n<hr>\n</li>\n</ul>\n<h3 id=\"五、类的使用\"><a href=\"#五、类的使用\" class=\"headerlink\" title=\"五、类的使用\"></a>五、类的使用</h3><h4 id=\"1-类的介绍和定义\"><a href=\"#1-类的介绍和定义\" class=\"headerlink\" title=\"1. 类的介绍和定义\"></a>1. 类的介绍和定义</h4><ul>\n<li><code>class</code>是Swift中的关键字,用于定义类</li>\n<li><p>注意:</p>\n<ul>\n<li>定义的类可以没有父类,那么该类是rootClass</li>\n<li><p>通常情况下,定义类是,继承NSObject</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> 类名 : <span class=\"title\">superClass</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 类的属性和方法</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"2-类的属性\"><a href=\"#2-类的属性\" class=\"headerlink\" title=\"2. 类的属性\"></a>2. 类的属性</h4><ul>\n<li>swift中类的属性有多种<ul>\n<li>存储属性: 存储实例的常量和变量<ul>\n<li>可以给存储属性提供一个默认值，也可以在初始化方法中对其进行初始化</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>计算属性: 通过某种方式计算出来的属性<ul>\n<li>计算属性并不存储实际的值，而是提供一个getter和一个可选的setter来间接获取和设置其它属性<ul>\n<li>计算属性一般只提供getter方法</li>\n<li>如果只提供getter，而不提供setter，则该计算属性为只读属性,并且可以省略get{}</li>\n</ul>\n</li>\n<li>类属性: 与整个类自身相关的属性<ul>\n<li>所有的类和实例都共有一份类属性.因此在某一处修改之后,该类属性就会被修改</li>\n<li>类属性的设置和修改,需要通过类来完成</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>监听属性的改变</p>\n<ul>\n<li>在OC中我们可以重写<code>set</code>方法来监听属性的改变</li>\n<li>Swift中可以通过属性观察者来监听和响应属性值的变化</li>\n<li>通常是监听存储属性和类属性的改变.(对于计算属性，我们不需要定义属性观察者，因为我们可以在计算属性的<code>setter</code>中直接观察并响应这种值的变化)</li>\n<li>我们通过设置以下观察方法来定义观察者<ul>\n<li><code>willSet</code>：在属性值被存储之前设置。此时新属性值作为一个常量参数被传入。该参数名默认为<code>newValue</code>，我们可以自己定义该参数名</li>\n<li><code>didSet</code>：在新属性值被存储后立即调用。与<code>willSet</code>相同，此时传入的是属性的旧值，默认参数名为<code>oldValue</code></li>\n<li><code>willSet</code>与<code>didSet</code>只有在属性第一次被设置时才会调用，在初始化时，不会去调用这些监听方法</li>\n</ul>\n</li>\n<li><p>监听的方式如下:</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> : <span class=\"title\">NSObject</span> </span>&#123;</div><div class=\"line\">   <span class=\"keyword\">var</span> name : <span class=\"type\">String</span>? &#123;</div><div class=\"line\">       <span class=\"comment\">// 可以给newValue自定义名称</span></div><div class=\"line\">       <span class=\"keyword\">willSet</span> (new)&#123; <span class=\"comment\">// 属性即将改变,还未改变时会调用的方法</span></div><div class=\"line\">           <span class=\"comment\">// 在该方法中有一个默认的系统属性newValue,用于存储值</span></div><div class=\"line\">       &#125;</div><div class=\"line\">       <span class=\"comment\">// 可以给oldValue自定义名称</span></div><div class=\"line\">       <span class=\"keyword\">didSet</span> (old) &#123; <span class=\"comment\">// 属性值已经改变了,会调用的方法</span></div><div class=\"line\">           <span class=\"comment\">// 在该方法中有一个默认的系统属性oldValue,用于存储旧值</span></div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"3-类的构造函数\"><a href=\"#3-类的构造函数\" class=\"headerlink\" title=\"3. 类的构造函数\"></a>3. 类的构造函数</h4><ul>\n<li>构造函数的介绍<ul>\n<li>构造函数类似于OC中的初始化方法:<code>init</code>方法</li>\n<li>默认情况下载创建一个类时,必然会调用一个构造函数</li>\n<li>即便是没有编写任何构造函数，编译器也会提供一个默认的构造函数。</li>\n<li>如果是继承自<code>NSObject</code>,可以对父类的构造函数进行重写</li>\n</ul>\n</li>\n<li>基本使用<ul>\n<li>类的属性必须有值</li>\n<li>如果不是在定义时初始化值,可以在构造函数中赋值</li>\n</ul>\n</li>\n<li>初始化时给属性赋值<ul>\n<li>很多时候,我们在创建一个对象时就会给属性赋值</li>\n<li>可以自定义构造函数</li>\n<li><strong>注意</strong>:如果自定义了构造函数,会覆盖init()方法.即不在有默认的构造函数</li>\n</ul>\n</li>\n<li><p>字典转模型(初始化时传入字典)</p>\n<ul>\n<li>真实创建对象时,更多的是将字典转成模型</li>\n<li><p>注意</p>\n<ul>\n<li>去字典中取出的是<code>NSObject</code>,任意类型.</li>\n<li>可以通过<code>as!</code>转成需要的类型,再赋值(不可以直接赋值)</li>\n</ul>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span>: <span class=\"title\">NSObject</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">var</span> name : <span class=\"type\">String</span></div><div class=\"line\">        <span class=\"keyword\">var</span> age : <span class=\"type\">Int</span></div><div class=\"line\">    </div><div class=\"line\">        <span class=\"comment\">// 自定义构造函数,会覆盖init()函数</span></div><div class=\"line\">        <span class=\"keyword\">init</span>(dict : [<span class=\"type\">String</span> : <span class=\"type\">NSObject</span>]) &#123;</div><div class=\"line\">            name = dict[<span class=\"string\">\"name\"</span>] <span class=\"keyword\">as</span>! <span class=\"type\">String</span></div><div class=\"line\">            age = dict[<span class=\"string\">\"age\"</span>] <span class=\"keyword\">as</span>! <span class=\"type\">Int</span></div><div class=\"line\">        &#125;</div><div class=\"line\"> &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 创建一个Person对象</span></div><div class=\"line\">    <span class=\"keyword\">let</span> dict = [<span class=\"string\">\"name\"</span> : <span class=\"string\">\"why\"</span>, <span class=\"string\">\"age\"</span> : <span class=\"number\">18</span>]</div><div class=\"line\">    <span class=\"keyword\">let</span> p = <span class=\"type\">Person</span>(dict: dict)</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>字典转模型(KVC)</p>\n<ul>\n<li>利用KVC字典转模型会更加方便</li>\n<li><p>注意</p>\n<ul>\n<li>KVC并不能保证会给所有的属性赋值</li>\n<li>因此属性需要有默认值<ul>\n<li>基本数据类型默认值设置为0</li>\n<li>对象或者结构体类型定义为可选类型即可(可选类型没有赋值前为nil)</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span>: <span class=\"title\">NSObject</span> </span>&#123;</div><div class=\"line\">     <span class=\"comment\">// 结构体或者类的类型,必须是可选类型.因为不能保证一定会赋值</span></div><div class=\"line\">     <span class=\"keyword\">var</span> name : <span class=\"type\">String</span>?</div><div class=\"line\"> </div><div class=\"line\">     <span class=\"comment\">// 基本数据类型不能是可选类型,否则KVC无法转化</span></div><div class=\"line\">     <span class=\"keyword\">var</span> age : <span class=\"type\">Int</span> = <span class=\"number\">0</span></div><div class=\"line\"> </div><div class=\"line\">     <span class=\"comment\">// 自定义构造函数,会覆盖init()函数</span></div><div class=\"line\">     <span class=\"keyword\">init</span>(dict : [<span class=\"type\">String</span> : <span class=\"type\">NSObject</span>]) &#123;</div><div class=\"line\">         <span class=\"comment\">// 必须先初始化对象</span></div><div class=\"line\">         <span class=\"keyword\">super</span>.<span class=\"keyword\">init</span>()</div><div class=\"line\"> </div><div class=\"line\">         <span class=\"comment\">// 调用对象的KVC方法字典转模型</span></div><div class=\"line\">         setValuesForKeysWithDictionary(dict)</div><div class=\"line\">     &#125;</div><div class=\"line\"> &#125;</div><div class=\"line\"> </div><div class=\"line\"><span class=\"comment\">// 创建一个Person对象</span></div><div class=\"line\"><span class=\"keyword\">let</span> dict = [<span class=\"string\">\"name\"</span> : <span class=\"string\">\"why\"</span>, <span class=\"string\">\"age\"</span> : <span class=\"number\">18</span>]</div><div class=\"line\"><span class=\"keyword\">let</span> p = <span class=\"type\">Person</span>(dict: dict)</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"4-类的析构函数\"><a href=\"#4-类的析构函数\" class=\"headerlink\" title=\"4. 类的析构函数\"></a>4. 类的析构函数</h4><ul>\n<li>Swift 会自动释放不再需要的实例以释放资源<ul>\n<li>Swift 通过自动引用计数（ARC）处理实例的内存管理</li>\n<li>当引用计数为0时,系统会自动调用析构函数(不可以手动调用)</li>\n<li>通常在析构函数中释放一些资源(如移除通知等操作)</li>\n</ul>\n</li>\n<li>析构函数的写法</li>\n</ul>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">deinit</span> &#123;</div><div class=\"line\"><span class=\"comment\">// 执行析构过程</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h3 id=\"一、类型转换\"><a href=\"#一、类型转换\" class=\"headerlink\" title=\"一、类型转换\"></a>一、类型转换</h3><h4 id=\"1-is-as\"><a href=\"#1-is-as\" class=\"headerlink\" title=\"1. is as\"></a>1. is as</h4><ul>\n<li>is: 判断是否是某一种类型(<code>isKindOfClass</code>)</li>\n<li>as: Swift字符串转OC字符串<code>str as NSString</code></li>\n</ul>\n<h4 id=\"2-as-as\"><a href=\"#2-as-as\" class=\"headerlink\" title=\"2. as? as!\"></a>2. as? as!</h4><ul>\n<li>as?: 将AnyObject转成可选类型,通过判断可选类型是否有值,来决定是否转换成功</li>\n<li>as!: 将AngObject转成具体类型,但是如果不是该类型程勋会崩溃","more":"</li>\n</ul>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> arr : [<span class=\"type\">AnyObject</span>] = [<span class=\"string\">\"ren\"</span>, <span class=\"number\">20</span>, <span class=\"number\">1.77</span>]</div><div class=\"line\"><span class=\"keyword\">let</span> objc = arr.first</div><div class=\"line\"><span class=\"comment\">// NSObject? 转成 String?</span></div><div class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">let</span> name = objc <span class=\"keyword\">as</span>? <span class=\"type\">String</span> &#123;</div><div class=\"line\"><span class=\"built_in\">print</span>(name)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//不推荐使用,转换不成功会崩溃</span></div><div class=\"line\"><span class=\"keyword\">let</span> name1 = objc <span class=\"keyword\">as</span>! <span class=\"type\">String</span></div></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"二、函数\"><a href=\"#二、函数\" class=\"headerlink\" title=\"二、函数\"></a>二、函数</h3><h4 id=\"1-函数介绍\"><a href=\"#1-函数介绍\" class=\"headerlink\" title=\"1. 函数介绍\"></a>1. 函数介绍</h4><ul>\n<li>函数相当于OC中的方法</li>\n<li>func 是关键字, 多个参数列表之间可以使用逗号分开,没有参数之间写()</li>\n<li>使用箭头<code>-&gt;</code>指向返回值类型</li>\n<li>如果没有返回值类型,返回值类型写<code>Void</code> 也可以不写</li>\n</ul>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> 函数名<span class=\"params\">(参数列表)</span></span> -&gt; 返回值类型 &#123;</div><div class=\"line\">     代码块...</div><div class=\"line\">     <span class=\"keyword\">return</span> 返回值</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"2-常见的函数类型\"><a href=\"#2-常见的函数类型\" class=\"headerlink\" title=\"2. 常见的函数类型\"></a>2. 常见的函数类型</h4><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 1.没有参数,没有返回值</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">about</span><span class=\"params\">()</span></span> -&gt; <span class=\"type\">Void</span> &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"没有参数,没用返回值\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// 调用函数</span></div><div class=\"line\">about()</div><div class=\"line\"><span class=\"comment\">// 简单写法</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">about1</span><span class=\"params\">()</span></span> -&gt; () &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"如果没用返回值,Void可以写成()\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">about2</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"如果没有返回值,后面的内容可以都不写\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 2.有参数,没用返回值</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">callPhone</span><span class=\"params\">(phoneNum : String)</span></span> &#123;</div><div class=\"line\">    </div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 3.没用参数,有返回值</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">readMessage</span><span class=\"params\">()</span></span> -&gt; <span class=\"type\">String</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"返回值\"</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> str = readMessage()</div><div class=\"line\"><span class=\"built_in\">print</span>(str)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 4.有参数,有返回值</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">sum</span><span class=\"params\">(num1 : Int, num2 : Int)</span></span> -&gt; <span class=\"type\">Int</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> num1 + num2</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> result = sum(<span class=\"number\">20</span>, num2: <span class=\"number\">30</span>)</div><div class=\"line\"><span class=\"built_in\">print</span>(result)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 5.有多个返回值的函数</span></div><div class=\"line\"><span class=\"keyword\">let</span> nums = [<span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">8</span>, <span class=\"number\">22</span>, <span class=\"number\">23</span>]</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">getNumCount</span><span class=\"params\">(nums : [Int])</span></span> -&gt; (oddCount : <span class=\"type\">Int</span>, evenCount : <span class=\"type\">Int</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> oddCount = <span class=\"number\">0</span></div><div class=\"line\">    <span class=\"keyword\">var</span> evenCount = <span class=\"number\">0</span></div><div class=\"line\">    <span class=\"keyword\">for</span> num <span class=\"keyword\">in</span> nums &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> num % <span class=\"number\">2</span> == <span class=\"number\">0</span> &#123;</div><div class=\"line\">            oddCount++</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            evenCount++</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> (oddCount, evenCount)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> result = getNumCount(nums)</div><div class=\"line\">result.oddCount</div><div class=\"line\">result.evenCount</div></pre></td></tr></table></figure>\n<h4 id=\"3-函数的使用注意\"><a href=\"#3-函数的使用注意\" class=\"headerlink\" title=\"3. 函数的使用注意\"></a>3. 函数的使用注意</h4><ul>\n<li>注意一: 外部参数和内部参数<ul>\n<li>在函数内部可以看到的参数就是内部参数</li>\n<li>在函数外部可以看到的参数就是外部参数</li>\n<li>默认情况下,从第二个参数开始,参数既是内部参数也是外部参数</li>\n<li>如果第一个参数也想要有外部参数,可以设置标签:<code>在变量名前添加</code></li>\n<li>如果不想要外部参数,可以参参数前加<code>_</code></li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">sum</span><span class=\"params\">(num1 num1 : Int, a num2 : Int, <span class=\"number\">_</span> num3 : Int)</span></span> -&gt; <span class=\"type\">Int</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> num1 + num2 + num3</div><div class=\"line\">&#125;</div><div class=\"line\">sum(num1: <span class=\"number\">10</span>, a: <span class=\"number\">20</span>, <span class=\"number\">30</span>) <span class=\"comment\">// 60</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 方法重载:方法名称相同,但是参数不同,可以称之为方法的重载(了解)</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">sum</span><span class=\"params\">(num1 : Int, num2 : Int)</span></span> -&gt; <span class=\"type\">Int</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> num1 + num2</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>注意二: 默认参数<ul>\n<li>某些情况,如果没有传入具体的参数可以使用默认参数</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">demo</span><span class=\"params\">(name : String = <span class=\"string\">\"默认参数\"</span>)</span></span> &#123;&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>注意三: 可变参数<ul>\n<li>swift中函数的参数可以变化, 它可以接受不确定数量的参数</li>\n<li>这些参数的类型必须相同</li>\n<li>在参数类型后面加<code>...</code> 即可表示可变参数</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">sum</span><span class=\"params\">(nums : Double...)</span></span> -&gt; <span class=\"type\">Double</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> total = <span class=\"number\">0.0</span></div><div class=\"line\">    <span class=\"keyword\">for</span> num <span class=\"keyword\">in</span> muns &#123;</div><div class=\"line\">        total += num</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> total</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>注意四: 引用类型(指针类型)<ul>\n<li>默认情况下, 函数的参数是值传递, 如果想改变外面的变量,则需要传递变量的地址</li>\n<li>通过Swift的<code>inout</code>关键字可以实现</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">10</span></div><div class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"number\">20</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">exchange</span><span class=\"params\">(<span class=\"keyword\">inout</span> a : Int, <span class=\"keyword\">inout</span> b : Int)</span></span> -&gt; <span class=\"type\">Int</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> temp = a</div><div class=\"line\">    a = b</div><div class=\"line\">    b = temp</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// 调用</span></div><div class=\"line\">exchange(&amp;a, b: &amp;b) <span class=\"comment\">// a == 20. b == 10</span></div></pre></td></tr></table></figure>\n<h4 id=\"4-函数的嵌套使用\"><a href=\"#4-函数的嵌套使用\" class=\"headerlink\" title=\"4. 函数的嵌套使用\"></a>4. 函数的嵌套使用</h4><ul>\n<li>swift中函数可以嵌套使用,但不推荐</li>\n</ul>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">test1</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">test2</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"test2\"</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"test1\"</span>)</div><div class=\"line\">    test2() <span class=\"comment\">// test2 必须在test1中调用 因为test2的作用域只在test1中</span></div><div class=\"line\">&#125;</div><div class=\"line\">test1()</div><div class=\"line\"><span class=\"comment\">// 打印结果: </span></div><div class=\"line\"><span class=\"comment\">// test1</span></div><div class=\"line\"><span class=\"comment\">// test2</span></div></pre></td></tr></table></figure>\n<h4 id=\"5-函数的类型\"><a href=\"#5-函数的类型\" class=\"headerlink\" title=\"5. 函数的类型\"></a>5. 函数的类型</h4><ul>\n<li>每个函数都有属于自己的类型,由函数的参数类型和返回值类型组成<ul>\n<li>在下面的例子中定义了两个简单的数学函数: <code>addTwoInts</code> 和 <code>multiplyTwoInts</code></li>\n<li>这两个函数都传入了两个Int类型, 返回一个合适的Int类型</li>\n<li>这两个函数的类型是<code>(Int, Int) -&gt; Int</code></li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">addTwoInts</span><span class=\"params\">(a : Int, b : Int)</span></span> -&gt; <span class=\"type\">Int</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> a + b</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">multiplyTwoInt</span><span class=\"params\">(a : Int, b : Int)</span></span> -&gt; <span class=\"type\">Int</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> a * b</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>抽取两个函数的类型并使用</li>\n</ul>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 定义函数的类型</span></div><div class=\"line\"><span class=\"keyword\">var</span> mathFunction : (<span class=\"type\">Int</span>, <span class=\"type\">Int</span>) -&gt; <span class=\"type\">Int</span> = addTwoInts</div><div class=\"line\"><span class=\"comment\">// 使用函数的名称</span></div><div class=\"line\">mathFunction(<span class=\"number\">10</span>, <span class=\"number\">20</span>) <span class=\"comment\">// 30</span></div><div class=\"line\"><span class=\"comment\">// 给函数的标识符赋值</span></div><div class=\"line\">mathFunction = multiplyTwoInt</div><div class=\"line\">mathFunction(<span class=\"number\">10</span>, <span class=\"number\">20</span>) <span class=\"comment\">// 200</span></div></pre></td></tr></table></figure>\n<ul>\n<li>函数的类型作为方法的参数</li>\n</ul>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">result</span><span class=\"params\">(a : Int, b : Int, method : <span class=\"params\">(Int, Int)</span></span></span> -&gt; <span class=\"type\">Int</span>) &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(method(a, b)) <span class=\"comment\">// 打印结果</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//  调用</span></div><div class=\"line\">result(<span class=\"number\">10</span>, b: <span class=\"number\">20</span>, method: addTwoInts) <span class=\"comment\">// 30</span></div><div class=\"line\">result(<span class=\"number\">10</span>, b: <span class=\"number\">20</span>, method: multiplyTwoInt) <span class=\"comment\">// 200</span></div></pre></td></tr></table></figure>\n<ul>\n<li>函数作为方法的返回值</li>\n</ul>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">test2</span><span class=\"params\">()</span></span> -&gt; ((<span class=\"type\">Int</span>, <span class=\"type\">Int</span>) -&gt; <span class=\"type\">Int</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> addTwoInts</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">let</span> tmpFunc = test2()</div><div class=\"line\">tmpFunc(<span class=\"number\">20</span>, <span class=\"number\">30</span>) <span class=\"comment\">// 50</span></div></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"三、-枚举\"><a href=\"#三、-枚举\" class=\"headerlink\" title=\"三、 枚举\"></a>三、 枚举</h3><h4 id=\"1-基本概念\"><a href=\"#1-基本概念\" class=\"headerlink\" title=\"1. 基本概念\"></a>1. 基本概念</h4><ul>\n<li>概念介绍<ul>\n<li>枚举定义了一个通用类型的一组相关的值,使你可以在你的代码中以一个安全的方式来使用这些值.</li>\n<li>在C/OC中枚举的值只能为整型</li>\n<li>Swift中的枚举更加灵活,它可以提供一个值是字符串,字符,整型或浮点值</li>\n</ul>\n</li>\n<li><p>枚举语法</p>\n <figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> 枚举名 </span>&#123;</div><div class=\"line\">     枚举值</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"2-枚举定义\"><a href=\"#2-枚举定义\" class=\"headerlink\" title=\"2. 枚举定义\"></a>2. 枚举定义</h4><ul>\n<li><p>以下是指南针四个方向的一个例子</p>\n<ul>\n<li><code>case</code>关键字表明新的一行成员值将被定义</li>\n<li><p>与C 和 OC 不一样, Swift的枚举成员在被创建的时候不会被赋一个默认值</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">CompassPoint</span> </span>&#123;</div><div class=\"line\">     <span class=\"keyword\">case</span> <span class=\"type\">North</span></div><div class=\"line\">     <span class=\"keyword\">case</span> <span class=\"type\">South</span></div><div class=\"line\">     <span class=\"keyword\">case</span> <span class=\"type\">East</span></div><div class=\"line\">     <span class=\"keyword\">case</span> <span class=\"type\">West</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>方式二: 多个陈远志可以出现在同一行上</p>\n <figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">CompassPoint</span> </span>&#123;</div><div class=\"line\">     <span class=\"keyword\">case</span> <span class=\"type\">North</span>, <span class=\"type\">South</span>, <span class=\"type\">East</span>, <span class=\"type\">West</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"3-给枚举类型赋值\"><a href=\"#3-给枚举类型赋值\" class=\"headerlink\" title=\"3. 给枚举类型赋值\"></a>3. 给枚举类型赋值</h4><ul>\n<li><p>枚举类型赋值可以是字符串/字符/整型/浮点型</p>\n<ul>\n<li>注意如果有给枚举类型赋值,则必须在枚举类型后面明确说明具体的类型</li>\n</ul>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 方式一</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">CompassPoint</span> : <span class=\"title\">Int</span> </span>&#123;</div><div class=\"line\">     <span class=\"keyword\">case</span> <span class=\"type\">North</span> = <span class=\"number\">1</span></div><div class=\"line\">     <span class=\"keyword\">case</span> <span class=\"type\">South</span> = <span class=\"number\">2</span></div><div class=\"line\">     <span class=\"keyword\">case</span> <span class=\"type\">East</span> = <span class=\"number\">3</span></div><div class=\"line\">     <span class=\"keyword\">case</span> <span class=\"type\">West</span> = <span class=\"number\">4</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 方式二</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">CompassPoint</span> : <span class=\"title\">Int</span> </span>&#123;</div><div class=\"line\">     <span class=\"keyword\">case</span> <span class=\"type\">North</span> = <span class=\"number\">1</span>, <span class=\"type\">South</span>, <span class=\"type\">East</span>, <span class=\"type\">West</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 赋具体值</span></div><div class=\"line\"><span class=\"keyword\">let</span> point = <span class=\"type\">CompassPoint</span>(rawValue : <span class=\"number\">1</span>)</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<hr>\n<h3 id=\"四、结构体\"><a href=\"#四、结构体\" class=\"headerlink\" title=\"四、结构体\"></a>四、结构体</h3><h4 id=\"1-结构体介绍-struct\"><a href=\"#1-结构体介绍-struct\" class=\"headerlink\" title=\"1. 结构体介绍(struct)\"></a>1. 结构体介绍(struct)</h4><ul>\n<li>基本概念<ul>\n<li>结构体是由一系列具有相同类型或不同类型的数据构成的数据集合</li>\n<li>结构体指的是一种数据结构</li>\n<li>结构体是值类型,在方法中传递时是值传递</li>\n</ul>\n</li>\n<li><p>结构体的定义格式</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Location</span> </span>&#123;</div><div class=\"line\">     <span class=\"keyword\">var</span> x : <span class=\"type\">Double</span></div><div class=\"line\">     <span class=\"keyword\">var</span> y : <span class=\"type\">Double</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"2-结构体增强\"><a href=\"#2-结构体增强\" class=\"headerlink\" title=\"2. 结构体增强\"></a>2. 结构体增强</h4><ul>\n<li><p>扩充构造函数</p>\n<ul>\n<li>默认情况下创建的Location时使用Location(x : x值, y : y值)</li>\n<li>但是为了让我们在使用该结构体是更加灵活, swift还可以对构造函数进行个扩充</li>\n<li>扩充的注意点<ul>\n<li>在扩充的构造函数中必须保证成员变量是有值的</li>\n<li>扩充的构造函数会覆盖原有的构造函数</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Location</span> </span>&#123;</div><div class=\"line\">     <span class=\"keyword\">var</span> x : <span class=\"type\">Double</span></div><div class=\"line\">     <span class=\"keyword\">var</span> y : <span class=\"type\">Double</span></div><div class=\"line\"></div><div class=\"line\">     <span class=\"comment\">// 原有的构造函数</span></div><div class=\"line\">     <span class=\"keyword\">init</span>() &#123;</div><div class=\"line\">     &#125;</div><div class=\"line\">   </div><div class=\"line\">     <span class=\"comment\">// 扩充的构造函数</span></div><div class=\"line\">     <span class=\"keyword\">init</span>(x : <span class=\"type\">Double</span>, y : <span class=\"type\">Double</span>) &#123;</div><div class=\"line\">         <span class=\"keyword\">self</span>.x = x</div><div class=\"line\">         <span class=\"keyword\">self</span>.y = y</div><div class=\"line\">     &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">let</span> location = <span class=\"type\">Location</span>(x: <span class=\"number\">100</span>, y: <span class=\"number\">100</span>)</div></pre></td></tr></table></figure>\n</li>\n<li><p>扩充方法</p>\n<ul>\n<li>为了让结构体使用更加灵活,swift的结构体中可以扩充方法</li>\n<li>例子:为了Location结构体扩充两个方法<ul>\n<li>向水平方向移动的方法</li>\n<li>向垂直方向移动的方法</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Location</span> </span>&#123;</div><div class=\"line\">     <span class=\"keyword\">var</span> x : <span class=\"type\">Double</span></div><div class=\"line\">     <span class=\"keyword\">var</span> y : <span class=\"type\">Double</span></div><div class=\"line\"></div><div class=\"line\">     <span class=\"keyword\">init</span>(x : <span class=\"type\">Double</span>, y : <span class=\"type\">Double</span>) &#123;</div><div class=\"line\">         <span class=\"keyword\">self</span>.x = x</div><div class=\"line\">         <span class=\"keyword\">self</span>.y = y</div><div class=\"line\">     &#125;</div><div class=\"line\"></div><div class=\"line\">     <span class=\"keyword\">mutating</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">moveH</span><span class=\"params\">(x : Double)</span></span> &#123;</div><div class=\"line\">         <span class=\"keyword\">self</span>.x += x</div><div class=\"line\">     &#125;</div><div class=\"line\"></div><div class=\"line\">     <span class=\"keyword\">mutating</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">moveV</span><span class=\"params\">(y : Double)</span></span> &#123;</div><div class=\"line\">         <span class=\"keyword\">self</span>.y += y</div><div class=\"line\">     &#125;</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n<hr>\n</li>\n</ul>\n<h3 id=\"五、类的使用\"><a href=\"#五、类的使用\" class=\"headerlink\" title=\"五、类的使用\"></a>五、类的使用</h3><h4 id=\"1-类的介绍和定义\"><a href=\"#1-类的介绍和定义\" class=\"headerlink\" title=\"1. 类的介绍和定义\"></a>1. 类的介绍和定义</h4><ul>\n<li><code>class</code>是Swift中的关键字,用于定义类</li>\n<li><p>注意:</p>\n<ul>\n<li>定义的类可以没有父类,那么该类是rootClass</li>\n<li><p>通常情况下,定义类是,继承NSObject</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> 类名 : <span class=\"title\">superClass</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 类的属性和方法</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"2-类的属性\"><a href=\"#2-类的属性\" class=\"headerlink\" title=\"2. 类的属性\"></a>2. 类的属性</h4><ul>\n<li>swift中类的属性有多种<ul>\n<li>存储属性: 存储实例的常量和变量<ul>\n<li>可以给存储属性提供一个默认值，也可以在初始化方法中对其进行初始化</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>计算属性: 通过某种方式计算出来的属性<ul>\n<li>计算属性并不存储实际的值，而是提供一个getter和一个可选的setter来间接获取和设置其它属性<ul>\n<li>计算属性一般只提供getter方法</li>\n<li>如果只提供getter，而不提供setter，则该计算属性为只读属性,并且可以省略get{}</li>\n</ul>\n</li>\n<li>类属性: 与整个类自身相关的属性<ul>\n<li>所有的类和实例都共有一份类属性.因此在某一处修改之后,该类属性就会被修改</li>\n<li>类属性的设置和修改,需要通过类来完成</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>监听属性的改变</p>\n<ul>\n<li>在OC中我们可以重写<code>set</code>方法来监听属性的改变</li>\n<li>Swift中可以通过属性观察者来监听和响应属性值的变化</li>\n<li>通常是监听存储属性和类属性的改变.(对于计算属性，我们不需要定义属性观察者，因为我们可以在计算属性的<code>setter</code>中直接观察并响应这种值的变化)</li>\n<li>我们通过设置以下观察方法来定义观察者<ul>\n<li><code>willSet</code>：在属性值被存储之前设置。此时新属性值作为一个常量参数被传入。该参数名默认为<code>newValue</code>，我们可以自己定义该参数名</li>\n<li><code>didSet</code>：在新属性值被存储后立即调用。与<code>willSet</code>相同，此时传入的是属性的旧值，默认参数名为<code>oldValue</code></li>\n<li><code>willSet</code>与<code>didSet</code>只有在属性第一次被设置时才会调用，在初始化时，不会去调用这些监听方法</li>\n</ul>\n</li>\n<li><p>监听的方式如下:</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> : <span class=\"title\">NSObject</span> </span>&#123;</div><div class=\"line\">   <span class=\"keyword\">var</span> name : <span class=\"type\">String</span>? &#123;</div><div class=\"line\">       <span class=\"comment\">// 可以给newValue自定义名称</span></div><div class=\"line\">       <span class=\"keyword\">willSet</span> (new)&#123; <span class=\"comment\">// 属性即将改变,还未改变时会调用的方法</span></div><div class=\"line\">           <span class=\"comment\">// 在该方法中有一个默认的系统属性newValue,用于存储值</span></div><div class=\"line\">       &#125;</div><div class=\"line\">       <span class=\"comment\">// 可以给oldValue自定义名称</span></div><div class=\"line\">       <span class=\"keyword\">didSet</span> (old) &#123; <span class=\"comment\">// 属性值已经改变了,会调用的方法</span></div><div class=\"line\">           <span class=\"comment\">// 在该方法中有一个默认的系统属性oldValue,用于存储旧值</span></div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"3-类的构造函数\"><a href=\"#3-类的构造函数\" class=\"headerlink\" title=\"3. 类的构造函数\"></a>3. 类的构造函数</h4><ul>\n<li>构造函数的介绍<ul>\n<li>构造函数类似于OC中的初始化方法:<code>init</code>方法</li>\n<li>默认情况下载创建一个类时,必然会调用一个构造函数</li>\n<li>即便是没有编写任何构造函数，编译器也会提供一个默认的构造函数。</li>\n<li>如果是继承自<code>NSObject</code>,可以对父类的构造函数进行重写</li>\n</ul>\n</li>\n<li>基本使用<ul>\n<li>类的属性必须有值</li>\n<li>如果不是在定义时初始化值,可以在构造函数中赋值</li>\n</ul>\n</li>\n<li>初始化时给属性赋值<ul>\n<li>很多时候,我们在创建一个对象时就会给属性赋值</li>\n<li>可以自定义构造函数</li>\n<li><strong>注意</strong>:如果自定义了构造函数,会覆盖init()方法.即不在有默认的构造函数</li>\n</ul>\n</li>\n<li><p>字典转模型(初始化时传入字典)</p>\n<ul>\n<li>真实创建对象时,更多的是将字典转成模型</li>\n<li><p>注意</p>\n<ul>\n<li>去字典中取出的是<code>NSObject</code>,任意类型.</li>\n<li>可以通过<code>as!</code>转成需要的类型,再赋值(不可以直接赋值)</li>\n</ul>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span>: <span class=\"title\">NSObject</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">var</span> name : <span class=\"type\">String</span></div><div class=\"line\">        <span class=\"keyword\">var</span> age : <span class=\"type\">Int</span></div><div class=\"line\">    </div><div class=\"line\">        <span class=\"comment\">// 自定义构造函数,会覆盖init()函数</span></div><div class=\"line\">        <span class=\"keyword\">init</span>(dict : [<span class=\"type\">String</span> : <span class=\"type\">NSObject</span>]) &#123;</div><div class=\"line\">            name = dict[<span class=\"string\">\"name\"</span>] <span class=\"keyword\">as</span>! <span class=\"type\">String</span></div><div class=\"line\">            age = dict[<span class=\"string\">\"age\"</span>] <span class=\"keyword\">as</span>! <span class=\"type\">Int</span></div><div class=\"line\">        &#125;</div><div class=\"line\"> &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 创建一个Person对象</span></div><div class=\"line\">    <span class=\"keyword\">let</span> dict = [<span class=\"string\">\"name\"</span> : <span class=\"string\">\"why\"</span>, <span class=\"string\">\"age\"</span> : <span class=\"number\">18</span>]</div><div class=\"line\">    <span class=\"keyword\">let</span> p = <span class=\"type\">Person</span>(dict: dict)</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>字典转模型(KVC)</p>\n<ul>\n<li>利用KVC字典转模型会更加方便</li>\n<li><p>注意</p>\n<ul>\n<li>KVC并不能保证会给所有的属性赋值</li>\n<li>因此属性需要有默认值<ul>\n<li>基本数据类型默认值设置为0</li>\n<li>对象或者结构体类型定义为可选类型即可(可选类型没有赋值前为nil)</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span>: <span class=\"title\">NSObject</span> </span>&#123;</div><div class=\"line\">     <span class=\"comment\">// 结构体或者类的类型,必须是可选类型.因为不能保证一定会赋值</span></div><div class=\"line\">     <span class=\"keyword\">var</span> name : <span class=\"type\">String</span>?</div><div class=\"line\"> </div><div class=\"line\">     <span class=\"comment\">// 基本数据类型不能是可选类型,否则KVC无法转化</span></div><div class=\"line\">     <span class=\"keyword\">var</span> age : <span class=\"type\">Int</span> = <span class=\"number\">0</span></div><div class=\"line\"> </div><div class=\"line\">     <span class=\"comment\">// 自定义构造函数,会覆盖init()函数</span></div><div class=\"line\">     <span class=\"keyword\">init</span>(dict : [<span class=\"type\">String</span> : <span class=\"type\">NSObject</span>]) &#123;</div><div class=\"line\">         <span class=\"comment\">// 必须先初始化对象</span></div><div class=\"line\">         <span class=\"keyword\">super</span>.<span class=\"keyword\">init</span>()</div><div class=\"line\"> </div><div class=\"line\">         <span class=\"comment\">// 调用对象的KVC方法字典转模型</span></div><div class=\"line\">         setValuesForKeysWithDictionary(dict)</div><div class=\"line\">     &#125;</div><div class=\"line\"> &#125;</div><div class=\"line\"> </div><div class=\"line\"><span class=\"comment\">// 创建一个Person对象</span></div><div class=\"line\"><span class=\"keyword\">let</span> dict = [<span class=\"string\">\"name\"</span> : <span class=\"string\">\"why\"</span>, <span class=\"string\">\"age\"</span> : <span class=\"number\">18</span>]</div><div class=\"line\"><span class=\"keyword\">let</span> p = <span class=\"type\">Person</span>(dict: dict)</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"4-类的析构函数\"><a href=\"#4-类的析构函数\" class=\"headerlink\" title=\"4. 类的析构函数\"></a>4. 类的析构函数</h4><ul>\n<li>Swift 会自动释放不再需要的实例以释放资源<ul>\n<li>Swift 通过自动引用计数（ARC）处理实例的内存管理</li>\n<li>当引用计数为0时,系统会自动调用析构函数(不可以手动调用)</li>\n<li>通常在析构函数中释放一些资源(如移除通知等操作)</li>\n</ul>\n</li>\n<li>析构函数的写法</li>\n</ul>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">deinit</span> &#123;</div><div class=\"line\"><span class=\"comment\">// 执行析构过程</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"title":"Swift学习笔记01","date":"2016-04-23T14:40:24.000Z","_content":"\n### 一、常量&变量\n1. 常量的使用注意\n* 优先使用常量\n* 常量的本质：保存的是内存地址,不可更改,但可以通过内存地址拿到对应的对象,修改对象的属性.\n\n<!-- more -->\n\n### 二、数据类型\n1. 整型与浮点型\n* 整型:`Int`\n* 浮点型:`Double`\n2. 类型推导\n* 如果定义一个标识符时,有直接赋值, 那么可以通过赋值的类型推导出标识符的类型.\n2. 基本运算\n* 相同类型才可以进行运算(没有隐式转换)\n\n### 三、逻辑分支\n1. if的使用\n* if后面的**()**可以省略\n* 没有非0即真的概念,必须有明确的Bool值(flase/true)\n2. 三目运算符\n* 与OC使用一致\n3. `guard`的使用\n\n```swift\n    guard 条件语句 else{\n        // 条件不满足代码\n        break/return/continue/throw\n    }\n     // 条件满足代码\n```\n\n4. switch使用\n* ()可以省略\n* case结束后可以省略break\n* case可以判断多个条件\n* 如果希望case有穿透, 加`fallThrough`\n* 特殊用法:\n     * 判断浮点型\n     * 判断字符串\n     * 判断区间类型\n\n### 四、循环\n1. for循环\n*  方式一\n\n    ```swift\n    for var i= 0; i< 10; i++ {\n        print(i)\n    }\n    ```\n* 方式二\n\n    ```swift\n     for i 0..<10 {\n        prin(i)\n     }\n    ```\n* 方式三\n\n    ```swift\n     for _ 0..<10 {\n        \n     }\n    ```\n2. while/dowhile循环\n* while后面() 可以省略\n* 没有非0即真\n\n### 五、字符串\n1. 定义字符串\n* 定义可变字符串`var str = \"string\"`\n* 定义不可变字符串`let str = \"string\"`\n2. 获取字符串长度\n* `str.characters.count`\n3. 遍历字符串\n\n```swift\n    for c in str.characters {\n        print(c)\n    }\n```\n4. 字符串拼接\n* 两个字符串之间:`str1 + str2`\n* 字符串与标识符之间:`\\(age)`\n* 字符串格式化:`String(format:\"%d %d\",\\ argments:[age1,age2])`\n5. 字符串截取\n* 将String类型转成NSString string as NSString\n\n ```swift\n    let urlString = \"www.yuxiang.ren\"  \n    let header = (urlString as NSString).substringToIndex(3)\n    let footer = (urlString as NSString).substringFromIndex(10)\n    let range = NSMakeRange(4, 5)\n    let middle = (urlString as NSString).substringWithRange(range)\n ```\n* swift的截取方式\n\n ```swift   \n    let toIndex = urlString.startIndex.advancedBy(3)\n    let header1 = urlString.substringToIndex(toIndex)\n\n    let fromIndex = urlString.endIndex.advancedBy(-3)\n    let footer1 = urlString.substringFromIndex(fromIndex)\n\n    let range1 = Range(start: toIndex.advancedBy(1), end: fromIndex.advancedBy(-1))\n    let middle1 = urlString.substringWithRange(range1)\n ```\n\n### 六、数组\n 1. 定义数组\n  * 不可变数组:`let arr = [\"www\", \"shlyren\"]`\n  * 可遍数组:`var arrM = [String]()`\n 2. 遍历数组\n  * `for value in arr{print(valur)}`\n  * `for (index, value) in array.enumerate() {print(index); print(value)}`\n 3. 数组的合并\n  * 相同类型的数组可以现价合并\n\n### 七、字典\n1. 定义字典\n* 不可变字典:`let dict = [\"name\" : \"ren\"]`\n* 可变字典:`var dictM = [String : NSObject]()`\n2. 遍历字典\n* `for key in dict.keys {}`\n* `for value in dict.values {}`\n* `for (key, value) in dict {}`\n3. 合并字典\n* 相同类型之间的字典也不可以合并\n\n### 八 、元组\n1. 使用元组定义数组\n* `let info = (“Not Found”, 404) info.0 info.1`\n* `let info = (errorInfo : “Not Found”, errorCode : 404) info.errorInfoinfo.errorCode`\n* `let (errorInfo, errorCode) = (“Not Found”, 404)`\n\n### 九、可选类型\n1. 定义可选类型\n* `var name : Optional<String> = nil`\n* `var name : String? = nil`\n2. 给可选类型赋值\n* `name = “renyuxaing”`\n3. 从可选类型取值\n* `name! ` 强制解包\n4. 可选类型注意: 如果可选类型中没有值,强制解包会崩溃\n5. 可选绑定\n* `if let tempName = name {} `\n     * 判断name是否有值\n     * 如果有值,对name强制解包并赋值给tempName\n* 简单写法 \n     * `if let name = name {}`\n\n\n","source":"_posts/Swift学习笔记01.md","raw":"---\ntitle: Swift学习笔记01\ndate: 2016-04-23 22:40:24\ncategories: iOS\ntags: Swift\n---\n\n### 一、常量&变量\n1. 常量的使用注意\n* 优先使用常量\n* 常量的本质：保存的是内存地址,不可更改,但可以通过内存地址拿到对应的对象,修改对象的属性.\n\n<!-- more -->\n\n### 二、数据类型\n1. 整型与浮点型\n* 整型:`Int`\n* 浮点型:`Double`\n2. 类型推导\n* 如果定义一个标识符时,有直接赋值, 那么可以通过赋值的类型推导出标识符的类型.\n2. 基本运算\n* 相同类型才可以进行运算(没有隐式转换)\n\n### 三、逻辑分支\n1. if的使用\n* if后面的**()**可以省略\n* 没有非0即真的概念,必须有明确的Bool值(flase/true)\n2. 三目运算符\n* 与OC使用一致\n3. `guard`的使用\n\n```swift\n    guard 条件语句 else{\n        // 条件不满足代码\n        break/return/continue/throw\n    }\n     // 条件满足代码\n```\n\n4. switch使用\n* ()可以省略\n* case结束后可以省略break\n* case可以判断多个条件\n* 如果希望case有穿透, 加`fallThrough`\n* 特殊用法:\n     * 判断浮点型\n     * 判断字符串\n     * 判断区间类型\n\n### 四、循环\n1. for循环\n*  方式一\n\n    ```swift\n    for var i= 0; i< 10; i++ {\n        print(i)\n    }\n    ```\n* 方式二\n\n    ```swift\n     for i 0..<10 {\n        prin(i)\n     }\n    ```\n* 方式三\n\n    ```swift\n     for _ 0..<10 {\n        \n     }\n    ```\n2. while/dowhile循环\n* while后面() 可以省略\n* 没有非0即真\n\n### 五、字符串\n1. 定义字符串\n* 定义可变字符串`var str = \"string\"`\n* 定义不可变字符串`let str = \"string\"`\n2. 获取字符串长度\n* `str.characters.count`\n3. 遍历字符串\n\n```swift\n    for c in str.characters {\n        print(c)\n    }\n```\n4. 字符串拼接\n* 两个字符串之间:`str1 + str2`\n* 字符串与标识符之间:`\\(age)`\n* 字符串格式化:`String(format:\"%d %d\",\\ argments:[age1,age2])`\n5. 字符串截取\n* 将String类型转成NSString string as NSString\n\n ```swift\n    let urlString = \"www.yuxiang.ren\"  \n    let header = (urlString as NSString).substringToIndex(3)\n    let footer = (urlString as NSString).substringFromIndex(10)\n    let range = NSMakeRange(4, 5)\n    let middle = (urlString as NSString).substringWithRange(range)\n ```\n* swift的截取方式\n\n ```swift   \n    let toIndex = urlString.startIndex.advancedBy(3)\n    let header1 = urlString.substringToIndex(toIndex)\n\n    let fromIndex = urlString.endIndex.advancedBy(-3)\n    let footer1 = urlString.substringFromIndex(fromIndex)\n\n    let range1 = Range(start: toIndex.advancedBy(1), end: fromIndex.advancedBy(-1))\n    let middle1 = urlString.substringWithRange(range1)\n ```\n\n### 六、数组\n 1. 定义数组\n  * 不可变数组:`let arr = [\"www\", \"shlyren\"]`\n  * 可遍数组:`var arrM = [String]()`\n 2. 遍历数组\n  * `for value in arr{print(valur)}`\n  * `for (index, value) in array.enumerate() {print(index); print(value)}`\n 3. 数组的合并\n  * 相同类型的数组可以现价合并\n\n### 七、字典\n1. 定义字典\n* 不可变字典:`let dict = [\"name\" : \"ren\"]`\n* 可变字典:`var dictM = [String : NSObject]()`\n2. 遍历字典\n* `for key in dict.keys {}`\n* `for value in dict.values {}`\n* `for (key, value) in dict {}`\n3. 合并字典\n* 相同类型之间的字典也不可以合并\n\n### 八 、元组\n1. 使用元组定义数组\n* `let info = (“Not Found”, 404) info.0 info.1`\n* `let info = (errorInfo : “Not Found”, errorCode : 404) info.errorInfoinfo.errorCode`\n* `let (errorInfo, errorCode) = (“Not Found”, 404)`\n\n### 九、可选类型\n1. 定义可选类型\n* `var name : Optional<String> = nil`\n* `var name : String? = nil`\n2. 给可选类型赋值\n* `name = “renyuxaing”`\n3. 从可选类型取值\n* `name! ` 强制解包\n4. 可选类型注意: 如果可选类型中没有值,强制解包会崩溃\n5. 可选绑定\n* `if let tempName = name {} `\n     * 判断name是否有值\n     * 如果有值,对name强制解包并赋值给tempName\n* 简单写法 \n     * `if let name = name {}`\n\n\n","slug":"Swift学习笔记01","published":1,"updated":"2017-04-28T08:41:48.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6686xl7000jxe9z6tl6i5fc","content":"<h3 id=\"一、常量-amp-变量\"><a href=\"#一、常量-amp-变量\" class=\"headerlink\" title=\"一、常量&amp;变量\"></a>一、常量&amp;变量</h3><ol>\n<li>常量的使用注意</li>\n</ol>\n<ul>\n<li>优先使用常量</li>\n<li>常量的本质：保存的是内存地址,不可更改,但可以通过内存地址拿到对应的对象,修改对象的属性.</li>\n</ul>\n<a id=\"more\"></a>\n<h3 id=\"二、数据类型\"><a href=\"#二、数据类型\" class=\"headerlink\" title=\"二、数据类型\"></a>二、数据类型</h3><ol>\n<li>整型与浮点型</li>\n</ol>\n<ul>\n<li>整型:<code>Int</code></li>\n<li>浮点型:<code>Double</code></li>\n</ul>\n<ol>\n<li>类型推导</li>\n</ol>\n<ul>\n<li>如果定义一个标识符时,有直接赋值, 那么可以通过赋值的类型推导出标识符的类型.</li>\n</ul>\n<ol>\n<li>基本运算</li>\n</ol>\n<ul>\n<li>相同类型才可以进行运算(没有隐式转换)</li>\n</ul>\n<h3 id=\"三、逻辑分支\"><a href=\"#三、逻辑分支\" class=\"headerlink\" title=\"三、逻辑分支\"></a>三、逻辑分支</h3><ol>\n<li>if的使用</li>\n</ol>\n<ul>\n<li>if后面的<strong>()</strong>可以省略</li>\n<li>没有非0即真的概念,必须有明确的Bool值(flase/true)</li>\n</ul>\n<ol>\n<li>三目运算符</li>\n</ol>\n<ul>\n<li>与OC使用一致</li>\n</ul>\n<ol>\n<li><code>guard</code>的使用</li>\n</ol>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">guard</span> 条件语句 <span class=\"keyword\">else</span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 条件不满足代码</span></div><div class=\"line\">    <span class=\"keyword\">break</span>/<span class=\"keyword\">return</span>/<span class=\"keyword\">continue</span>/<span class=\"keyword\">throw</span></div><div class=\"line\">&#125;</div><div class=\"line\"> <span class=\"comment\">// 条件满足代码</span></div></pre></td></tr></table></figure>\n<ol>\n<li>switch使用</li>\n</ol>\n<ul>\n<li>()可以省略</li>\n<li>case结束后可以省略break</li>\n<li>case可以判断多个条件</li>\n<li>如果希望case有穿透, 加<code>fallThrough</code></li>\n<li>特殊用法:<ul>\n<li>判断浮点型</li>\n<li>判断字符串</li>\n<li>判断区间类型</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"四、循环\"><a href=\"#四、循环\" class=\"headerlink\" title=\"四、循环\"></a>四、循环</h3><ol>\n<li>for循环</li>\n</ol>\n<ul>\n<li><p>方式一</p>\n <figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span> <span class=\"keyword\">var</span> i= <span class=\"number\">0</span>; i&lt; <span class=\"number\">10</span>; i++ &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(i)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>方式二</p>\n  <figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span> i <span class=\"number\">0</span>..&lt;<span class=\"number\">10</span> &#123;</div><div class=\"line\">   prin(i)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>方式三</p>\n  <figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span> <span class=\"number\">_</span> <span class=\"number\">0</span>..&lt;<span class=\"number\">10</span> &#123;</div><div class=\"line\">   </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<ol>\n<li>while/dowhile循环</li>\n</ol>\n<ul>\n<li>while后面() 可以省略</li>\n<li>没有非0即真</li>\n</ul>\n<h3 id=\"五、字符串\"><a href=\"#五、字符串\" class=\"headerlink\" title=\"五、字符串\"></a>五、字符串</h3><ol>\n<li>定义字符串</li>\n</ol>\n<ul>\n<li>定义可变字符串<code>var str = &quot;string&quot;</code></li>\n<li>定义不可变字符串<code>let str = &quot;string&quot;</code></li>\n</ul>\n<ol>\n<li>获取字符串长度</li>\n</ol>\n<ul>\n<li><code>str.characters.count</code></li>\n</ul>\n<ol>\n<li>遍历字符串</li>\n</ol>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span> <span class=\"built_in\">c</span> <span class=\"keyword\">in</span> str.characters &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"built_in\">c</span>)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ol>\n<li>字符串拼接</li>\n</ol>\n<ul>\n<li>两个字符串之间:<code>str1 + str2</code></li>\n<li>字符串与标识符之间:<code>\\(age)</code></li>\n<li>字符串格式化:<code>String(format:&quot;%d %d&quot;,\\ argments:[age1,age2])</code></li>\n</ul>\n<ol>\n<li>字符串截取</li>\n</ol>\n<ul>\n<li><p>将String类型转成NSString string as NSString</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> urlString = <span class=\"string\">\"www.yuxiang.ren\"</span>  </div><div class=\"line\"><span class=\"keyword\">let</span> header = (urlString <span class=\"keyword\">as</span> <span class=\"type\">NSString</span>).substringToIndex(<span class=\"number\">3</span>)</div><div class=\"line\"><span class=\"keyword\">let</span> footer = (urlString <span class=\"keyword\">as</span> <span class=\"type\">NSString</span>).substringFromIndex(<span class=\"number\">10</span>)</div><div class=\"line\"><span class=\"keyword\">let</span> range = <span class=\"type\">NSMakeRange</span>(<span class=\"number\">4</span>, <span class=\"number\">5</span>)</div><div class=\"line\"><span class=\"keyword\">let</span> middle = (urlString <span class=\"keyword\">as</span> <span class=\"type\">NSString</span>).substringWithRange(range)</div></pre></td></tr></table></figure>\n</li>\n<li><p>swift的截取方式</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> toIndex = urlString.startIndex.advancedBy(<span class=\"number\">3</span>)</div><div class=\"line\"><span class=\"keyword\">let</span> header1 = urlString.substringToIndex(toIndex)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> fromIndex = urlString.endIndex.advancedBy(-<span class=\"number\">3</span>)</div><div class=\"line\"><span class=\"keyword\">let</span> footer1 = urlString.substringFromIndex(fromIndex)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> range1 = <span class=\"type\">Range</span>(start: toIndex.advancedBy(<span class=\"number\">1</span>), end: fromIndex.advancedBy(-<span class=\"number\">1</span>))</div><div class=\"line\"><span class=\"keyword\">let</span> middle1 = urlString.substringWithRange(range1)</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"六、数组\"><a href=\"#六、数组\" class=\"headerlink\" title=\"六、数组\"></a>六、数组</h3><ol>\n<li>定义数组<ul>\n<li>不可变数组:<code>let arr = [&quot;www&quot;, &quot;shlyren&quot;]</code></li>\n<li>可遍数组:<code>var arrM = [String]()</code></li>\n</ul>\n</li>\n<li>遍历数组<ul>\n<li><code>for value in arr{print(valur)}</code></li>\n<li><code>for (index, value) in array.enumerate() {print(index); print(value)}</code></li>\n</ul>\n</li>\n<li>数组的合并<ul>\n<li>相同类型的数组可以现价合并</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"七、字典\"><a href=\"#七、字典\" class=\"headerlink\" title=\"七、字典\"></a>七、字典</h3><ol>\n<li>定义字典</li>\n</ol>\n<ul>\n<li>不可变字典:<code>let dict = [&quot;name&quot; : &quot;ren&quot;]</code></li>\n<li>可变字典:<code>var dictM = [String : NSObject]()</code></li>\n</ul>\n<ol>\n<li>遍历字典</li>\n</ol>\n<ul>\n<li><code>for key in dict.keys {}</code></li>\n<li><code>for value in dict.values {}</code></li>\n<li><code>for (key, value) in dict {}</code></li>\n</ul>\n<ol>\n<li>合并字典</li>\n</ol>\n<ul>\n<li>相同类型之间的字典也不可以合并</li>\n</ul>\n<h3 id=\"八-、元组\"><a href=\"#八-、元组\" class=\"headerlink\" title=\"八 、元组\"></a>八 、元组</h3><ol>\n<li>使用元组定义数组</li>\n</ol>\n<ul>\n<li><code>let info = (“Not Found”, 404) info.0 info.1</code></li>\n<li><code>let info = (errorInfo : “Not Found”, errorCode : 404) info.errorInfoinfo.errorCode</code></li>\n<li><code>let (errorInfo, errorCode) = (“Not Found”, 404)</code></li>\n</ul>\n<h3 id=\"九、可选类型\"><a href=\"#九、可选类型\" class=\"headerlink\" title=\"九、可选类型\"></a>九、可选类型</h3><ol>\n<li>定义可选类型</li>\n</ol>\n<ul>\n<li><code>var name : Optional&lt;String&gt; = nil</code></li>\n<li><code>var name : String? = nil</code></li>\n</ul>\n<ol>\n<li>给可选类型赋值</li>\n</ol>\n<ul>\n<li><code>name = “renyuxaing”</code></li>\n</ul>\n<ol>\n<li>从可选类型取值</li>\n</ol>\n<ul>\n<li><code>name!</code> 强制解包</li>\n</ul>\n<ol>\n<li>可选类型注意: 如果可选类型中没有值,强制解包会崩溃</li>\n<li>可选绑定</li>\n</ol>\n<ul>\n<li><code>if let tempName = name {}</code><ul>\n<li>判断name是否有值</li>\n<li>如果有值,对name强制解包并赋值给tempName</li>\n</ul>\n</li>\n<li>简单写法 <ul>\n<li><code>if let name = name {}</code></li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h3 id=\"一、常量-amp-变量\"><a href=\"#一、常量-amp-变量\" class=\"headerlink\" title=\"一、常量&amp;变量\"></a>一、常量&amp;变量</h3><ol>\n<li>常量的使用注意</li>\n</ol>\n<ul>\n<li>优先使用常量</li>\n<li>常量的本质：保存的是内存地址,不可更改,但可以通过内存地址拿到对应的对象,修改对象的属性.</li>\n</ul>","more":"<h3 id=\"二、数据类型\"><a href=\"#二、数据类型\" class=\"headerlink\" title=\"二、数据类型\"></a>二、数据类型</h3><ol>\n<li>整型与浮点型</li>\n</ol>\n<ul>\n<li>整型:<code>Int</code></li>\n<li>浮点型:<code>Double</code></li>\n</ul>\n<ol>\n<li>类型推导</li>\n</ol>\n<ul>\n<li>如果定义一个标识符时,有直接赋值, 那么可以通过赋值的类型推导出标识符的类型.</li>\n</ul>\n<ol>\n<li>基本运算</li>\n</ol>\n<ul>\n<li>相同类型才可以进行运算(没有隐式转换)</li>\n</ul>\n<h3 id=\"三、逻辑分支\"><a href=\"#三、逻辑分支\" class=\"headerlink\" title=\"三、逻辑分支\"></a>三、逻辑分支</h3><ol>\n<li>if的使用</li>\n</ol>\n<ul>\n<li>if后面的<strong>()</strong>可以省略</li>\n<li>没有非0即真的概念,必须有明确的Bool值(flase/true)</li>\n</ul>\n<ol>\n<li>三目运算符</li>\n</ol>\n<ul>\n<li>与OC使用一致</li>\n</ul>\n<ol>\n<li><code>guard</code>的使用</li>\n</ol>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">guard</span> 条件语句 <span class=\"keyword\">else</span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 条件不满足代码</span></div><div class=\"line\">    <span class=\"keyword\">break</span>/<span class=\"keyword\">return</span>/<span class=\"keyword\">continue</span>/<span class=\"keyword\">throw</span></div><div class=\"line\">&#125;</div><div class=\"line\"> <span class=\"comment\">// 条件满足代码</span></div></pre></td></tr></table></figure>\n<ol>\n<li>switch使用</li>\n</ol>\n<ul>\n<li>()可以省略</li>\n<li>case结束后可以省略break</li>\n<li>case可以判断多个条件</li>\n<li>如果希望case有穿透, 加<code>fallThrough</code></li>\n<li>特殊用法:<ul>\n<li>判断浮点型</li>\n<li>判断字符串</li>\n<li>判断区间类型</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"四、循环\"><a href=\"#四、循环\" class=\"headerlink\" title=\"四、循环\"></a>四、循环</h3><ol>\n<li>for循环</li>\n</ol>\n<ul>\n<li><p>方式一</p>\n <figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span> <span class=\"keyword\">var</span> i= <span class=\"number\">0</span>; i&lt; <span class=\"number\">10</span>; i++ &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(i)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>方式二</p>\n  <figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span> i <span class=\"number\">0</span>..&lt;<span class=\"number\">10</span> &#123;</div><div class=\"line\">   prin(i)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>方式三</p>\n  <figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span> <span class=\"number\">_</span> <span class=\"number\">0</span>..&lt;<span class=\"number\">10</span> &#123;</div><div class=\"line\">   </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<ol>\n<li>while/dowhile循环</li>\n</ol>\n<ul>\n<li>while后面() 可以省略</li>\n<li>没有非0即真</li>\n</ul>\n<h3 id=\"五、字符串\"><a href=\"#五、字符串\" class=\"headerlink\" title=\"五、字符串\"></a>五、字符串</h3><ol>\n<li>定义字符串</li>\n</ol>\n<ul>\n<li>定义可变字符串<code>var str = &quot;string&quot;</code></li>\n<li>定义不可变字符串<code>let str = &quot;string&quot;</code></li>\n</ul>\n<ol>\n<li>获取字符串长度</li>\n</ol>\n<ul>\n<li><code>str.characters.count</code></li>\n</ul>\n<ol>\n<li>遍历字符串</li>\n</ol>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span> <span class=\"built_in\">c</span> <span class=\"keyword\">in</span> str.characters &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"built_in\">c</span>)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ol>\n<li>字符串拼接</li>\n</ol>\n<ul>\n<li>两个字符串之间:<code>str1 + str2</code></li>\n<li>字符串与标识符之间:<code>\\(age)</code></li>\n<li>字符串格式化:<code>String(format:&quot;%d %d&quot;,\\ argments:[age1,age2])</code></li>\n</ul>\n<ol>\n<li>字符串截取</li>\n</ol>\n<ul>\n<li><p>将String类型转成NSString string as NSString</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> urlString = <span class=\"string\">\"www.yuxiang.ren\"</span>  </div><div class=\"line\"><span class=\"keyword\">let</span> header = (urlString <span class=\"keyword\">as</span> <span class=\"type\">NSString</span>).substringToIndex(<span class=\"number\">3</span>)</div><div class=\"line\"><span class=\"keyword\">let</span> footer = (urlString <span class=\"keyword\">as</span> <span class=\"type\">NSString</span>).substringFromIndex(<span class=\"number\">10</span>)</div><div class=\"line\"><span class=\"keyword\">let</span> range = <span class=\"type\">NSMakeRange</span>(<span class=\"number\">4</span>, <span class=\"number\">5</span>)</div><div class=\"line\"><span class=\"keyword\">let</span> middle = (urlString <span class=\"keyword\">as</span> <span class=\"type\">NSString</span>).substringWithRange(range)</div></pre></td></tr></table></figure>\n</li>\n<li><p>swift的截取方式</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> toIndex = urlString.startIndex.advancedBy(<span class=\"number\">3</span>)</div><div class=\"line\"><span class=\"keyword\">let</span> header1 = urlString.substringToIndex(toIndex)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> fromIndex = urlString.endIndex.advancedBy(-<span class=\"number\">3</span>)</div><div class=\"line\"><span class=\"keyword\">let</span> footer1 = urlString.substringFromIndex(fromIndex)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> range1 = <span class=\"type\">Range</span>(start: toIndex.advancedBy(<span class=\"number\">1</span>), end: fromIndex.advancedBy(-<span class=\"number\">1</span>))</div><div class=\"line\"><span class=\"keyword\">let</span> middle1 = urlString.substringWithRange(range1)</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"六、数组\"><a href=\"#六、数组\" class=\"headerlink\" title=\"六、数组\"></a>六、数组</h3><ol>\n<li>定义数组<ul>\n<li>不可变数组:<code>let arr = [&quot;www&quot;, &quot;shlyren&quot;]</code></li>\n<li>可遍数组:<code>var arrM = [String]()</code></li>\n</ul>\n</li>\n<li>遍历数组<ul>\n<li><code>for value in arr{print(valur)}</code></li>\n<li><code>for (index, value) in array.enumerate() {print(index); print(value)}</code></li>\n</ul>\n</li>\n<li>数组的合并<ul>\n<li>相同类型的数组可以现价合并</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"七、字典\"><a href=\"#七、字典\" class=\"headerlink\" title=\"七、字典\"></a>七、字典</h3><ol>\n<li>定义字典</li>\n</ol>\n<ul>\n<li>不可变字典:<code>let dict = [&quot;name&quot; : &quot;ren&quot;]</code></li>\n<li>可变字典:<code>var dictM = [String : NSObject]()</code></li>\n</ul>\n<ol>\n<li>遍历字典</li>\n</ol>\n<ul>\n<li><code>for key in dict.keys {}</code></li>\n<li><code>for value in dict.values {}</code></li>\n<li><code>for (key, value) in dict {}</code></li>\n</ul>\n<ol>\n<li>合并字典</li>\n</ol>\n<ul>\n<li>相同类型之间的字典也不可以合并</li>\n</ul>\n<h3 id=\"八-、元组\"><a href=\"#八-、元组\" class=\"headerlink\" title=\"八 、元组\"></a>八 、元组</h3><ol>\n<li>使用元组定义数组</li>\n</ol>\n<ul>\n<li><code>let info = (“Not Found”, 404) info.0 info.1</code></li>\n<li><code>let info = (errorInfo : “Not Found”, errorCode : 404) info.errorInfoinfo.errorCode</code></li>\n<li><code>let (errorInfo, errorCode) = (“Not Found”, 404)</code></li>\n</ul>\n<h3 id=\"九、可选类型\"><a href=\"#九、可选类型\" class=\"headerlink\" title=\"九、可选类型\"></a>九、可选类型</h3><ol>\n<li>定义可选类型</li>\n</ol>\n<ul>\n<li><code>var name : Optional&lt;String&gt; = nil</code></li>\n<li><code>var name : String? = nil</code></li>\n</ul>\n<ol>\n<li>给可选类型赋值</li>\n</ol>\n<ul>\n<li><code>name = “renyuxaing”</code></li>\n</ul>\n<ol>\n<li>从可选类型取值</li>\n</ol>\n<ul>\n<li><code>name!</code> 强制解包</li>\n</ul>\n<ol>\n<li>可选类型注意: 如果可选类型中没有值,强制解包会崩溃</li>\n<li>可选绑定</li>\n</ol>\n<ul>\n<li><code>if let tempName = name {}</code><ul>\n<li>判断name是否有值</li>\n<li>如果有值,对name强制解包并赋值给tempName</li>\n</ul>\n</li>\n<li>简单写法 <ul>\n<li><code>if let name = name {}</code></li>\n</ul>\n</li>\n</ul>"},{"title":"Swift学习笔记03","date":"2016-04-26T10:08:29.000Z","_content":"\n## 一、三大特性\n### 1. 封装，继承， 多态\n* 多态产生的三大条件\n    * 必须有继承\n    * 必须有重写\n    * 父类指针指向子类对象\n* 如果子类对父类的方法不满意， 可以对福列的方法进行重写\n    * 在Swift中如果对弗雷德方法进行个重写,必须在`func`前加`override`\n\n<!-- more -->\n\n### 2. 重载\n* 重载的使用场景\n    * 参数的类型不同\n    * 参数的个数不同\n\n---\n\n## 二、自动引用计数\n### 1. 工作机制\n* 当有一个强指针指向某一个对象是, 该对象的引用计数会+1\n* 当该强指针消失时,引用计数会-1\n* 当引用计数为0时,该对象会被系统回收\n\n### 2. 循环引用\n* 与OC一样,Swift在开发中经常会出现循环引用的问题\n* 解决方法,Swift提供了两种方法\n    * `weak`: 和OC中的`__weak`一样,当指向的对象销毁时,会自动将指针指向`nil`\n    * `unowned`: 和OC中的`__unsafe_unretained`一样,当指向的对象销毁时,指针依然指向之前的对象,会导致野指针错误\n\n---\n\n## 三、可选链\n### 1. 可选链的概念\n* 它的可选性体现于请求或调用的目标当前可能为空\n    * 如果可选的目标有值，那么调用就会成功\n    * 如果可选的目标为空，则这种调用会返回空\n* 多次调用被链接在一起形成一个链，如果任何一个节点为空将导致整个链失效。\n\n### 2. 可选链的使用\n* 在可选类型后面放一个问号,可以定义一个可选链\n* 这一点很像在可选值后面放一个叹号来强制解包\n    * 他们的主要区别在于当可选值为空时可选链即刻失效\n    * 然而一般的强制解析将会引发运行时的错误\n* 因为可选链的结果可能为空,也可能有值,因此它的返回值是一个可选类型\n    * 可以通过判断返回值是否有值来判断是否调用成功\n        * 有值,表示调用成功\n        * 为空,表示调用失败\n\n---\n\n## 四、协议\n### 1. 协议的格式\n* 协议的定义与类,结构体,枚举的定义都非常相似\n\n```swift\nprotocol SomeProtocol {\n    // 协议方法\n}\n```\n* 遵守协议的格式\n\n```swift\nclass SomeClass: SomeSuperClass, FirstProtocol,  AnotherProtocol {\n    // 类的内容\n    // 实现协议中的方法\n}\n```\n\n### 2. 协议的基本使用\n* 定义协议和遵守协议\n\n```swift\n// 1.定义协议\nprotocol SportProtocol {\n    func playBasketball()\n    func playFootball()\n}\n// 2.遵守协议 注意:默认情况下在swift中所有的协议方法都是必须实现的,如果不实现,则编译器会报错\nclass Person : SportProtocol {\n    var name : String?\n    var age : Int = 0\n\n    // 实现协议中的方法\n    func playBasketball() {\n        print(\"人在打篮球\")\n    }\n    func playFootball() {\n        print(\"人在踢足球\")\n    }\n}\n```\n\n* 协议之间的继承\n\n```swift\nprotocol CrazySportProtocol {\n    func jumping()\n}\n\nprotocol SportProtocol : CrazySportProtocol {\n    func playBasketball()\n    func playFootball()\n}\n```\n\n### 3. 代理设计模式\n```swift\nprotocol BuyTicketProtocol {\n    func buyTicket()\n}\n\nclass Person {\n    // 1.定义协议属性\n    var delegate : BuyTicketProtocol\n    // 2.自定义构造函数\n    init (delegate : BuyTicketProtocol) {\n        self.delegate = delegate\n    }\n    // 3.行为\n    func goToBeijing() {\n        delegate.buyTicket()\n    }\n}\n\nclass HuangNiu: BuyTicketProtocol {\n    func buyTicket() {\n        print(\"买了一张火车票\")\n    }\n}\nlet p = Person(delegate: HuangNiu())\np.goToBeijing()\n```\n\n### 4. 协议中方法的可选\n* Swift中的协议默认为必须实现,如果不实现则直接报错\n* 要想跟OC一样将协议中的方法设置为可选,则需要特殊操作\n\n```swift\n// 1.定义协议\n@objc \nprotocol SportProtocol {\n    func playBasketball()\n    optional func playFootball()\n}\n\n// 2.遵守协议\nclass Person : SportProtocol {\n    var name : String?\n    var age : Int = 0\n\n    // 实现协议中的方法\n    @objc func playBasketball() {\n        print(\"人在打篮球\")\n    }\n}\n```\n\n---\n\n## 五、闭包\n### 1. 闭包的介绍\n* 闭包和OC中的block非常相似\n    * OC中的block是匿名的函数\n    * Swift中的闭包是特殊的函数\n    * block和闭包都经常用于回调\n\n### 2. 闭包的写法\n* 类型:**(形参列表)->(返回值)**\n\n```swift\n// 定义\nfunc test(finished : (parameter : String) -> ()){\n   finished(parameter : \"block参数\")\n}\n   \n// 调用\ntest({ (parameter) -> () in\n    print(\"block传过来的参数:\\(parameter)\")\n})\n```\n\n### 3. 闭包的简写\n* 如果闭包没有写参数, 没有返回值,闭包的参数可以不写\n\n```swift\ntest({\n    // 代码块\n})\n```\n* 尾随闭包写法:\n    * 如果闭包是函数的最后一个参数,则可以将闭包卸载()后面\n    * 如果函数只有一个参数,并且这个参数是闭包,那么()可以不写\n\n```swift\n// 闭包是函数的最后一个参数\ntest(){\n    // 代码块\n}\n\n//函数只有一个参数,并且这个参数是闭包\ntest {\n    // 代码块\n}\n```\n\n### 4. 闭包导致的循环引用解决方案\n* 方案一:\n    * 使用`weak` 对当前控制器使用弱引用\n    * 但是因为`self`可能有值也可能没有值,因此`weakSelf`是一个可选类型,在真正使用时可以对其强制解包(该处强制解包没有问题,因为控制器一定存在,否则无法调用所在函数)\n\n```swift\n weak var weakSelf = self\n```\n* 方案二(常用):\n    * 和方案一类型,只是书写方式更加简单\n    * 可以写在闭包中,并且在闭包中用到的self都是弱引用\n\n```swift\ntest({[weak self] (parameter) -> () in\n    print(\"block传过来的参数:\\(parameter)\")\n})\n```\n\n* 方案三:\n    * 使用关键字`unowned`\n    * 从行为上来说 `unowned` 更像OC中的 `unsafe_unretained`\n    * `unowned`表示:即使它原来引用的对象被释放了，仍然会保持对被已经释放了的对象的一个 \"无效的\" 引用，它不能是`Optional`值，也不会被指向nil\n\n```swift\ntest({[unowned self] (parameter) -> () in\n    print(\"block传过来的参数:\\(parameter)\")\n})\n```\n\n---\n\n## 六、懒加载\n### 1. 懒加载的介绍\n* 苹果的设计思想:希望所有的对象在使用时才真正加载到内存中)\n* 和OC不同的是Swift有专门的关键字来实现懒加载\n* `lazy`关键字可以用于定义某一个属性懒加载\n\n### 2. 懒加载的使用\n* 格式: 在属性前用`lazy`修饰\n\n```swift\n// 苹果官方写法: 创建的时候可以设置一些属性\nlazy var btn1 : UIButton = {\n    let tempBtn = UIButton()\n    tempBtn.setTitle(\"按钮\" forState:.Normal)\n    return tmpBtn\n}()\n    \n// 简单写法: 只是创建对象\nlazy var btn1 : UIButton = UIButton()\n```\n\n---\n\n## 七、常见注释\n### 1. 单行注释\n```swift\n// 注释\n```\n\n### 2. 多行行注释\n* Swift中`/* */`可以嵌套使用\n\n```swift\n/*\n  注释\n   /* 注释 */\n*/\n```\n\n### 3. 文档注释\n```swift\n/// 注释\n```\n\n### 4. 分组注释\n```swift\n// MARK:- 带有分割线\n// MARK: 不带分割线\n```\n\n---\n\n## 八、访问权限\n### 1. Swift中的访问权限\n* Swift中的访问控制模型基于模块的源文件这两个概念\n    * `internal`: 在本模块中可以进行访问\n    * `private`: 在当前源文件(项目)可以访问\n    * `public`: 在其他模块中可以访问\n\n---\n\n## 九、异常处理\n### 1. 异常的介绍\n* 只要在编程,就一定会遇到错误处理的问题\n* Swift在设计的时候就尽可能的让开发者感知错误,明确处理错误\n    * 比如: 只有使用个`Optional`才能处理空值\n* 描述一个错误\n    * 在Swift中, 任何一个遵守`ErrorType protocol`的类型，都可以用于描述错误。\n    * `ErrorType`是一个空的`protocol`, 它唯一的功能，就是告诉Swift编译器，某个类型用来表示一个错误。\n    * 通常，我们使用一个`enum`来定义各种错误的可能性\n\n### 2. 异常的示例\n* 假如想要读取一个文件中的内容,按照OC的逻辑我们可以这样来模拟\n    * 当调用方法获取结果为`nil`时,你并不能确定到底参数了什么错误得到了`nil`\n\n```swift\nfunc readFileContent(filePath : String) -> String? {\n    // 1.filePath为\"\"\n    if filePath == \"\" {\n        return nil\n    }\n    // 2.filePath有值,但是没有对应的文件\n    if filePath != \"/User/Desktop/123.plist\" {\n        return nil\n    }\n    // 3.取出其中的内容\n    return \"123\"\n}\n\nreadFileContent(\"abc\")\n```\n\n* 使用异常对上述方法的改进\n\n```swift\n// 1.定义异常\nenum FileReadError : ErrorType {\n    case FileISNull\n    case FileNotFound\n}\n\n// 2.改进方法,让方法抛出异常\nfunc readFileContent(filePath : String) throws -> String {\n    // 1.filePath为\"\"\n    if filePath == \"\" {\n        throw FileReadError.FileISNull\n    }\n\n    // 2.filepath有值,但是没有对应的文件\n    if filePath != \"/User/Desktop/123.plist\" {\n\n        throw FileReadError.FileISNull\n    }\n\n    // 3.取出其中的内容\n    return \"123\"\n}\n```\n\n### 3. 异常处理的三种方式\n```swift\n// 1. try方式,需要手动处理异常\ndo {\n    let result = try readFileContent(\"abc\")\n} catch {\n    print(error)\n}\n\n// 2. try?方式,不处理异常,如果出现了异常,则返回一个nil.没有异常,则返回对应的值\n// 最终返回结果为一个可选类型\nlet result = try? readFileContent(\"abc\")\n\n// 3. try!方法,告诉系统该方法没有异常.\n// 注意:如果出现了异常,则程序会崩溃\ntry! readFileContent(\"abc\")\n```\n\n---\n\n## 十、OC、Swift混编\n### 1. Swift调用OC\n* 创建桥接文件\n* 配置桥接文件\n    * 步骤图\n      ![](https://yuxiang.ren/images/images/配置桥接文件.png)\n\n### 2. OC调用Swift代码\n* 导入**项目名称-Swift.h**\n* Swift中的所有类以及方法和属性必须使用`public`修饰\n\n\n","source":"_posts/Swift学习笔记03.md","raw":"---\ntitle: Swift学习笔记03\ndate: 2016-04-26 18:08:29\ncategories: iOS\ntags: [Swift]\n---\n\n## 一、三大特性\n### 1. 封装，继承， 多态\n* 多态产生的三大条件\n    * 必须有继承\n    * 必须有重写\n    * 父类指针指向子类对象\n* 如果子类对父类的方法不满意， 可以对福列的方法进行重写\n    * 在Swift中如果对弗雷德方法进行个重写,必须在`func`前加`override`\n\n<!-- more -->\n\n### 2. 重载\n* 重载的使用场景\n    * 参数的类型不同\n    * 参数的个数不同\n\n---\n\n## 二、自动引用计数\n### 1. 工作机制\n* 当有一个强指针指向某一个对象是, 该对象的引用计数会+1\n* 当该强指针消失时,引用计数会-1\n* 当引用计数为0时,该对象会被系统回收\n\n### 2. 循环引用\n* 与OC一样,Swift在开发中经常会出现循环引用的问题\n* 解决方法,Swift提供了两种方法\n    * `weak`: 和OC中的`__weak`一样,当指向的对象销毁时,会自动将指针指向`nil`\n    * `unowned`: 和OC中的`__unsafe_unretained`一样,当指向的对象销毁时,指针依然指向之前的对象,会导致野指针错误\n\n---\n\n## 三、可选链\n### 1. 可选链的概念\n* 它的可选性体现于请求或调用的目标当前可能为空\n    * 如果可选的目标有值，那么调用就会成功\n    * 如果可选的目标为空，则这种调用会返回空\n* 多次调用被链接在一起形成一个链，如果任何一个节点为空将导致整个链失效。\n\n### 2. 可选链的使用\n* 在可选类型后面放一个问号,可以定义一个可选链\n* 这一点很像在可选值后面放一个叹号来强制解包\n    * 他们的主要区别在于当可选值为空时可选链即刻失效\n    * 然而一般的强制解析将会引发运行时的错误\n* 因为可选链的结果可能为空,也可能有值,因此它的返回值是一个可选类型\n    * 可以通过判断返回值是否有值来判断是否调用成功\n        * 有值,表示调用成功\n        * 为空,表示调用失败\n\n---\n\n## 四、协议\n### 1. 协议的格式\n* 协议的定义与类,结构体,枚举的定义都非常相似\n\n```swift\nprotocol SomeProtocol {\n    // 协议方法\n}\n```\n* 遵守协议的格式\n\n```swift\nclass SomeClass: SomeSuperClass, FirstProtocol,  AnotherProtocol {\n    // 类的内容\n    // 实现协议中的方法\n}\n```\n\n### 2. 协议的基本使用\n* 定义协议和遵守协议\n\n```swift\n// 1.定义协议\nprotocol SportProtocol {\n    func playBasketball()\n    func playFootball()\n}\n// 2.遵守协议 注意:默认情况下在swift中所有的协议方法都是必须实现的,如果不实现,则编译器会报错\nclass Person : SportProtocol {\n    var name : String?\n    var age : Int = 0\n\n    // 实现协议中的方法\n    func playBasketball() {\n        print(\"人在打篮球\")\n    }\n    func playFootball() {\n        print(\"人在踢足球\")\n    }\n}\n```\n\n* 协议之间的继承\n\n```swift\nprotocol CrazySportProtocol {\n    func jumping()\n}\n\nprotocol SportProtocol : CrazySportProtocol {\n    func playBasketball()\n    func playFootball()\n}\n```\n\n### 3. 代理设计模式\n```swift\nprotocol BuyTicketProtocol {\n    func buyTicket()\n}\n\nclass Person {\n    // 1.定义协议属性\n    var delegate : BuyTicketProtocol\n    // 2.自定义构造函数\n    init (delegate : BuyTicketProtocol) {\n        self.delegate = delegate\n    }\n    // 3.行为\n    func goToBeijing() {\n        delegate.buyTicket()\n    }\n}\n\nclass HuangNiu: BuyTicketProtocol {\n    func buyTicket() {\n        print(\"买了一张火车票\")\n    }\n}\nlet p = Person(delegate: HuangNiu())\np.goToBeijing()\n```\n\n### 4. 协议中方法的可选\n* Swift中的协议默认为必须实现,如果不实现则直接报错\n* 要想跟OC一样将协议中的方法设置为可选,则需要特殊操作\n\n```swift\n// 1.定义协议\n@objc \nprotocol SportProtocol {\n    func playBasketball()\n    optional func playFootball()\n}\n\n// 2.遵守协议\nclass Person : SportProtocol {\n    var name : String?\n    var age : Int = 0\n\n    // 实现协议中的方法\n    @objc func playBasketball() {\n        print(\"人在打篮球\")\n    }\n}\n```\n\n---\n\n## 五、闭包\n### 1. 闭包的介绍\n* 闭包和OC中的block非常相似\n    * OC中的block是匿名的函数\n    * Swift中的闭包是特殊的函数\n    * block和闭包都经常用于回调\n\n### 2. 闭包的写法\n* 类型:**(形参列表)->(返回值)**\n\n```swift\n// 定义\nfunc test(finished : (parameter : String) -> ()){\n   finished(parameter : \"block参数\")\n}\n   \n// 调用\ntest({ (parameter) -> () in\n    print(\"block传过来的参数:\\(parameter)\")\n})\n```\n\n### 3. 闭包的简写\n* 如果闭包没有写参数, 没有返回值,闭包的参数可以不写\n\n```swift\ntest({\n    // 代码块\n})\n```\n* 尾随闭包写法:\n    * 如果闭包是函数的最后一个参数,则可以将闭包卸载()后面\n    * 如果函数只有一个参数,并且这个参数是闭包,那么()可以不写\n\n```swift\n// 闭包是函数的最后一个参数\ntest(){\n    // 代码块\n}\n\n//函数只有一个参数,并且这个参数是闭包\ntest {\n    // 代码块\n}\n```\n\n### 4. 闭包导致的循环引用解决方案\n* 方案一:\n    * 使用`weak` 对当前控制器使用弱引用\n    * 但是因为`self`可能有值也可能没有值,因此`weakSelf`是一个可选类型,在真正使用时可以对其强制解包(该处强制解包没有问题,因为控制器一定存在,否则无法调用所在函数)\n\n```swift\n weak var weakSelf = self\n```\n* 方案二(常用):\n    * 和方案一类型,只是书写方式更加简单\n    * 可以写在闭包中,并且在闭包中用到的self都是弱引用\n\n```swift\ntest({[weak self] (parameter) -> () in\n    print(\"block传过来的参数:\\(parameter)\")\n})\n```\n\n* 方案三:\n    * 使用关键字`unowned`\n    * 从行为上来说 `unowned` 更像OC中的 `unsafe_unretained`\n    * `unowned`表示:即使它原来引用的对象被释放了，仍然会保持对被已经释放了的对象的一个 \"无效的\" 引用，它不能是`Optional`值，也不会被指向nil\n\n```swift\ntest({[unowned self] (parameter) -> () in\n    print(\"block传过来的参数:\\(parameter)\")\n})\n```\n\n---\n\n## 六、懒加载\n### 1. 懒加载的介绍\n* 苹果的设计思想:希望所有的对象在使用时才真正加载到内存中)\n* 和OC不同的是Swift有专门的关键字来实现懒加载\n* `lazy`关键字可以用于定义某一个属性懒加载\n\n### 2. 懒加载的使用\n* 格式: 在属性前用`lazy`修饰\n\n```swift\n// 苹果官方写法: 创建的时候可以设置一些属性\nlazy var btn1 : UIButton = {\n    let tempBtn = UIButton()\n    tempBtn.setTitle(\"按钮\" forState:.Normal)\n    return tmpBtn\n}()\n    \n// 简单写法: 只是创建对象\nlazy var btn1 : UIButton = UIButton()\n```\n\n---\n\n## 七、常见注释\n### 1. 单行注释\n```swift\n// 注释\n```\n\n### 2. 多行行注释\n* Swift中`/* */`可以嵌套使用\n\n```swift\n/*\n  注释\n   /* 注释 */\n*/\n```\n\n### 3. 文档注释\n```swift\n/// 注释\n```\n\n### 4. 分组注释\n```swift\n// MARK:- 带有分割线\n// MARK: 不带分割线\n```\n\n---\n\n## 八、访问权限\n### 1. Swift中的访问权限\n* Swift中的访问控制模型基于模块的源文件这两个概念\n    * `internal`: 在本模块中可以进行访问\n    * `private`: 在当前源文件(项目)可以访问\n    * `public`: 在其他模块中可以访问\n\n---\n\n## 九、异常处理\n### 1. 异常的介绍\n* 只要在编程,就一定会遇到错误处理的问题\n* Swift在设计的时候就尽可能的让开发者感知错误,明确处理错误\n    * 比如: 只有使用个`Optional`才能处理空值\n* 描述一个错误\n    * 在Swift中, 任何一个遵守`ErrorType protocol`的类型，都可以用于描述错误。\n    * `ErrorType`是一个空的`protocol`, 它唯一的功能，就是告诉Swift编译器，某个类型用来表示一个错误。\n    * 通常，我们使用一个`enum`来定义各种错误的可能性\n\n### 2. 异常的示例\n* 假如想要读取一个文件中的内容,按照OC的逻辑我们可以这样来模拟\n    * 当调用方法获取结果为`nil`时,你并不能确定到底参数了什么错误得到了`nil`\n\n```swift\nfunc readFileContent(filePath : String) -> String? {\n    // 1.filePath为\"\"\n    if filePath == \"\" {\n        return nil\n    }\n    // 2.filePath有值,但是没有对应的文件\n    if filePath != \"/User/Desktop/123.plist\" {\n        return nil\n    }\n    // 3.取出其中的内容\n    return \"123\"\n}\n\nreadFileContent(\"abc\")\n```\n\n* 使用异常对上述方法的改进\n\n```swift\n// 1.定义异常\nenum FileReadError : ErrorType {\n    case FileISNull\n    case FileNotFound\n}\n\n// 2.改进方法,让方法抛出异常\nfunc readFileContent(filePath : String) throws -> String {\n    // 1.filePath为\"\"\n    if filePath == \"\" {\n        throw FileReadError.FileISNull\n    }\n\n    // 2.filepath有值,但是没有对应的文件\n    if filePath != \"/User/Desktop/123.plist\" {\n\n        throw FileReadError.FileISNull\n    }\n\n    // 3.取出其中的内容\n    return \"123\"\n}\n```\n\n### 3. 异常处理的三种方式\n```swift\n// 1. try方式,需要手动处理异常\ndo {\n    let result = try readFileContent(\"abc\")\n} catch {\n    print(error)\n}\n\n// 2. try?方式,不处理异常,如果出现了异常,则返回一个nil.没有异常,则返回对应的值\n// 最终返回结果为一个可选类型\nlet result = try? readFileContent(\"abc\")\n\n// 3. try!方法,告诉系统该方法没有异常.\n// 注意:如果出现了异常,则程序会崩溃\ntry! readFileContent(\"abc\")\n```\n\n---\n\n## 十、OC、Swift混编\n### 1. Swift调用OC\n* 创建桥接文件\n* 配置桥接文件\n    * 步骤图\n      ![](https://yuxiang.ren/images/images/配置桥接文件.png)\n\n### 2. OC调用Swift代码\n* 导入**项目名称-Swift.h**\n* Swift中的所有类以及方法和属性必须使用`public`修饰\n\n\n","slug":"Swift学习笔记03","published":1,"updated":"2017-04-28T08:40:17.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6686xl9000nxe9zz6yucg5z","content":"<h2 id=\"一、三大特性\"><a href=\"#一、三大特性\" class=\"headerlink\" title=\"一、三大特性\"></a>一、三大特性</h2><h3 id=\"1-封装，继承，-多态\"><a href=\"#1-封装，继承，-多态\" class=\"headerlink\" title=\"1. 封装，继承， 多态\"></a>1. 封装，继承， 多态</h3><ul>\n<li>多态产生的三大条件<ul>\n<li>必须有继承</li>\n<li>必须有重写</li>\n<li>父类指针指向子类对象</li>\n</ul>\n</li>\n<li>如果子类对父类的方法不满意， 可以对福列的方法进行重写<ul>\n<li>在Swift中如果对弗雷德方法进行个重写,必须在<code>func</code>前加<code>override</code></li>\n</ul>\n</li>\n</ul>\n<a id=\"more\"></a>\n<h3 id=\"2-重载\"><a href=\"#2-重载\" class=\"headerlink\" title=\"2. 重载\"></a>2. 重载</h3><ul>\n<li>重载的使用场景<ul>\n<li>参数的类型不同</li>\n<li>参数的个数不同</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"二、自动引用计数\"><a href=\"#二、自动引用计数\" class=\"headerlink\" title=\"二、自动引用计数\"></a>二、自动引用计数</h2><h3 id=\"1-工作机制\"><a href=\"#1-工作机制\" class=\"headerlink\" title=\"1. 工作机制\"></a>1. 工作机制</h3><ul>\n<li>当有一个强指针指向某一个对象是, 该对象的引用计数会+1</li>\n<li>当该强指针消失时,引用计数会-1</li>\n<li>当引用计数为0时,该对象会被系统回收</li>\n</ul>\n<h3 id=\"2-循环引用\"><a href=\"#2-循环引用\" class=\"headerlink\" title=\"2. 循环引用\"></a>2. 循环引用</h3><ul>\n<li>与OC一样,Swift在开发中经常会出现循环引用的问题</li>\n<li>解决方法,Swift提供了两种方法<ul>\n<li><code>weak</code>: 和OC中的<code>__weak</code>一样,当指向的对象销毁时,会自动将指针指向<code>nil</code></li>\n<li><code>unowned</code>: 和OC中的<code>__unsafe_unretained</code>一样,当指向的对象销毁时,指针依然指向之前的对象,会导致野指针错误</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"三、可选链\"><a href=\"#三、可选链\" class=\"headerlink\" title=\"三、可选链\"></a>三、可选链</h2><h3 id=\"1-可选链的概念\"><a href=\"#1-可选链的概念\" class=\"headerlink\" title=\"1. 可选链的概念\"></a>1. 可选链的概念</h3><ul>\n<li>它的可选性体现于请求或调用的目标当前可能为空<ul>\n<li>如果可选的目标有值，那么调用就会成功</li>\n<li>如果可选的目标为空，则这种调用会返回空</li>\n</ul>\n</li>\n<li>多次调用被链接在一起形成一个链，如果任何一个节点为空将导致整个链失效。</li>\n</ul>\n<h3 id=\"2-可选链的使用\"><a href=\"#2-可选链的使用\" class=\"headerlink\" title=\"2. 可选链的使用\"></a>2. 可选链的使用</h3><ul>\n<li>在可选类型后面放一个问号,可以定义一个可选链</li>\n<li>这一点很像在可选值后面放一个叹号来强制解包<ul>\n<li>他们的主要区别在于当可选值为空时可选链即刻失效</li>\n<li>然而一般的强制解析将会引发运行时的错误</li>\n</ul>\n</li>\n<li>因为可选链的结果可能为空,也可能有值,因此它的返回值是一个可选类型<ul>\n<li>可以通过判断返回值是否有值来判断是否调用成功<ul>\n<li>有值,表示调用成功</li>\n<li>为空,表示调用失败</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"四、协议\"><a href=\"#四、协议\" class=\"headerlink\" title=\"四、协议\"></a>四、协议</h2><h3 id=\"1-协议的格式\"><a href=\"#1-协议的格式\" class=\"headerlink\" title=\"1. 协议的格式\"></a>1. 协议的格式</h3><ul>\n<li>协议的定义与类,结构体,枚举的定义都非常相似</li>\n</ul>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">protocol</span> <span class=\"title\">SomeProtocol</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 协议方法</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>遵守协议的格式</li>\n</ul>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SomeClass</span>: <span class=\"title\">SomeSuperClass</span>, <span class=\"title\">FirstProtocol</span>,  <span class=\"title\">AnotherProtocol</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 类的内容</span></div><div class=\"line\">    <span class=\"comment\">// 实现协议中的方法</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"2-协议的基本使用\"><a href=\"#2-协议的基本使用\" class=\"headerlink\" title=\"2. 协议的基本使用\"></a>2. 协议的基本使用</h3><ul>\n<li>定义协议和遵守协议</li>\n</ul>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 1.定义协议</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">protocol</span> <span class=\"title\">SportProtocol</span> </span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">playBasketball</span><span class=\"params\">()</span></span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">playFootball</span><span class=\"params\">()</span></span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// 2.遵守协议 注意:默认情况下在swift中所有的协议方法都是必须实现的,如果不实现,则编译器会报错</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> : <span class=\"title\">SportProtocol</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> name : <span class=\"type\">String</span>?</div><div class=\"line\">    <span class=\"keyword\">var</span> age : <span class=\"type\">Int</span> = <span class=\"number\">0</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 实现协议中的方法</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">playBasketball</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"人在打篮球\"</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">playFootball</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"人在踢足球\"</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>协议之间的继承</li>\n</ul>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">protocol</span> <span class=\"title\">CrazySportProtocol</span> </span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">jumping</span><span class=\"params\">()</span></span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">protocol</span> <span class=\"title\">SportProtocol</span> : <span class=\"title\">CrazySportProtocol</span> </span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">playBasketball</span><span class=\"params\">()</span></span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">playFootball</span><span class=\"params\">()</span></span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"3-代理设计模式\"><a href=\"#3-代理设计模式\" class=\"headerlink\" title=\"3. 代理设计模式\"></a>3. 代理设计模式</h3><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">protocol</span> <span class=\"title\">BuyTicketProtocol</span> </span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">buyTicket</span><span class=\"params\">()</span></span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 1.定义协议属性</span></div><div class=\"line\">    <span class=\"keyword\">var</span> delegate : <span class=\"type\">BuyTicketProtocol</span></div><div class=\"line\">    <span class=\"comment\">// 2.自定义构造函数</span></div><div class=\"line\">    <span class=\"keyword\">init</span> (delegate : <span class=\"type\">BuyTicketProtocol</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">self</span>.delegate = delegate</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">// 3.行为</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">goToBeijing</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">        delegate.buyTicket()</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HuangNiu</span>: <span class=\"title\">BuyTicketProtocol</span> </span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">buyTicket</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"买了一张火车票\"</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">let</span> p = <span class=\"type\">Person</span>(delegate: <span class=\"type\">HuangNiu</span>())</div><div class=\"line\">p.goToBeijing()</div></pre></td></tr></table></figure>\n<h3 id=\"4-协议中方法的可选\"><a href=\"#4-协议中方法的可选\" class=\"headerlink\" title=\"4. 协议中方法的可选\"></a>4. 协议中方法的可选</h3><ul>\n<li>Swift中的协议默认为必须实现,如果不实现则直接报错</li>\n<li>要想跟OC一样将协议中的方法设置为可选,则需要特殊操作</li>\n</ul>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 1.定义协议</span></div><div class=\"line\"><span class=\"meta\">@objc</span> </div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">protocol</span> <span class=\"title\">SportProtocol</span> </span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">playBasketball</span><span class=\"params\">()</span></span></div><div class=\"line\">    <span class=\"keyword\">optional</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">playFootball</span><span class=\"params\">()</span></span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 2.遵守协议</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> : <span class=\"title\">SportProtocol</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> name : <span class=\"type\">String</span>?</div><div class=\"line\">    <span class=\"keyword\">var</span> age : <span class=\"type\">Int</span> = <span class=\"number\">0</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 实现协议中的方法</span></div><div class=\"line\">    <span class=\"meta\">@objc</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">playBasketball</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"人在打篮球\"</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"五、闭包\"><a href=\"#五、闭包\" class=\"headerlink\" title=\"五、闭包\"></a>五、闭包</h2><h3 id=\"1-闭包的介绍\"><a href=\"#1-闭包的介绍\" class=\"headerlink\" title=\"1. 闭包的介绍\"></a>1. 闭包的介绍</h3><ul>\n<li>闭包和OC中的block非常相似<ul>\n<li>OC中的block是匿名的函数</li>\n<li>Swift中的闭包是特殊的函数</li>\n<li>block和闭包都经常用于回调</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-闭包的写法\"><a href=\"#2-闭包的写法\" class=\"headerlink\" title=\"2. 闭包的写法\"></a>2. 闭包的写法</h3><ul>\n<li>类型:<strong>(形参列表)-&gt;(返回值)</strong></li>\n</ul>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 定义</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">test</span><span class=\"params\">(finished : <span class=\"params\">(parameter : String)</span></span></span> -&gt; ())&#123;</div><div class=\"line\">   finished(parameter : <span class=\"string\">\"block参数\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\">   </div><div class=\"line\"><span class=\"comment\">// 调用</span></div><div class=\"line\">test(&#123; (parameter) -&gt; () <span class=\"keyword\">in</span></div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"block传过来的参数:<span class=\"subst\">\\(parameter)</span>\"</span>)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<h3 id=\"3-闭包的简写\"><a href=\"#3-闭包的简写\" class=\"headerlink\" title=\"3. 闭包的简写\"></a>3. 闭包的简写</h3><ul>\n<li>如果闭包没有写参数, 没有返回值,闭包的参数可以不写</li>\n</ul>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">test(&#123;</div><div class=\"line\">    <span class=\"comment\">// 代码块</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<ul>\n<li>尾随闭包写法:<ul>\n<li>如果闭包是函数的最后一个参数,则可以将闭包卸载()后面</li>\n<li>如果函数只有一个参数,并且这个参数是闭包,那么()可以不写</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 闭包是函数的最后一个参数</span></div><div class=\"line\">test()&#123;</div><div class=\"line\">    <span class=\"comment\">// 代码块</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//函数只有一个参数,并且这个参数是闭包</span></div><div class=\"line\">test &#123;</div><div class=\"line\">    <span class=\"comment\">// 代码块</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"4-闭包导致的循环引用解决方案\"><a href=\"#4-闭包导致的循环引用解决方案\" class=\"headerlink\" title=\"4. 闭包导致的循环引用解决方案\"></a>4. 闭包导致的循环引用解决方案</h3><ul>\n<li>方案一:<ul>\n<li>使用<code>weak</code> 对当前控制器使用弱引用</li>\n<li>但是因为<code>self</code>可能有值也可能没有值,因此<code>weakSelf</code>是一个可选类型,在真正使用时可以对其强制解包(该处强制解包没有问题,因为控制器一定存在,否则无法调用所在函数)</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">weak</span> <span class=\"keyword\">var</span> weakSelf = <span class=\"keyword\">self</span></div></pre></td></tr></table></figure>\n<ul>\n<li>方案二(常用):<ul>\n<li>和方案一类型,只是书写方式更加简单</li>\n<li>可以写在闭包中,并且在闭包中用到的self都是弱引用</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">test(&#123;[<span class=\"keyword\">weak</span> <span class=\"keyword\">self</span>] (parameter) -&gt; () <span class=\"keyword\">in</span></div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"block传过来的参数:<span class=\"subst\">\\(parameter)</span>\"</span>)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<ul>\n<li>方案三:<ul>\n<li>使用关键字<code>unowned</code></li>\n<li>从行为上来说 <code>unowned</code> 更像OC中的 <code>unsafe_unretained</code></li>\n<li><code>unowned</code>表示:即使它原来引用的对象被释放了，仍然会保持对被已经释放了的对象的一个 “无效的” 引用，它不能是<code>Optional</code>值，也不会被指向nil</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">test(&#123;[<span class=\"keyword\">unowned</span> <span class=\"keyword\">self</span>] (parameter) -&gt; () <span class=\"keyword\">in</span></div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"block传过来的参数:<span class=\"subst\">\\(parameter)</span>\"</span>)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"六、懒加载\"><a href=\"#六、懒加载\" class=\"headerlink\" title=\"六、懒加载\"></a>六、懒加载</h2><h3 id=\"1-懒加载的介绍\"><a href=\"#1-懒加载的介绍\" class=\"headerlink\" title=\"1. 懒加载的介绍\"></a>1. 懒加载的介绍</h3><ul>\n<li>苹果的设计思想:希望所有的对象在使用时才真正加载到内存中)</li>\n<li>和OC不同的是Swift有专门的关键字来实现懒加载</li>\n<li><code>lazy</code>关键字可以用于定义某一个属性懒加载</li>\n</ul>\n<h3 id=\"2-懒加载的使用\"><a href=\"#2-懒加载的使用\" class=\"headerlink\" title=\"2. 懒加载的使用\"></a>2. 懒加载的使用</h3><ul>\n<li>格式: 在属性前用<code>lazy</code>修饰</li>\n</ul>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 苹果官方写法: 创建的时候可以设置一些属性</span></div><div class=\"line\"><span class=\"built_in\">lazy</span> <span class=\"keyword\">var</span> btn1 : <span class=\"type\">UIButton</span> = &#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> tempBtn = <span class=\"type\">UIButton</span>()</div><div class=\"line\">    tempBtn.setTitle(<span class=\"string\">\"按钮\"</span> forState:.<span class=\"type\">Normal</span>)</div><div class=\"line\">    <span class=\"keyword\">return</span> tmpBtn</div><div class=\"line\">&#125;()</div><div class=\"line\">    </div><div class=\"line\"><span class=\"comment\">// 简单写法: 只是创建对象</span></div><div class=\"line\"><span class=\"built_in\">lazy</span> <span class=\"keyword\">var</span> btn1 : <span class=\"type\">UIButton</span> = <span class=\"type\">UIButton</span>()</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"七、常见注释\"><a href=\"#七、常见注释\" class=\"headerlink\" title=\"七、常见注释\"></a>七、常见注释</h2><h3 id=\"1-单行注释\"><a href=\"#1-单行注释\" class=\"headerlink\" title=\"1. 单行注释\"></a>1. 单行注释</h3><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 注释</span></div></pre></td></tr></table></figure>\n<h3 id=\"2-多行行注释\"><a href=\"#2-多行行注释\" class=\"headerlink\" title=\"2. 多行行注释\"></a>2. 多行行注释</h3><ul>\n<li>Swift中<code>/* */</code>可以嵌套使用</li>\n</ul>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/*</span></div><div class=\"line\">  注释</div><div class=\"line\">   <span class=\"comment\">/* 注释 */</span></div><div class=\"line\">*/</div></pre></td></tr></table></figure>\n<h3 id=\"3-文档注释\"><a href=\"#3-文档注释\" class=\"headerlink\" title=\"3. 文档注释\"></a>3. 文档注释</h3><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/// 注释</span></div></pre></td></tr></table></figure>\n<h3 id=\"4-分组注释\"><a href=\"#4-分组注释\" class=\"headerlink\" title=\"4. 分组注释\"></a>4. 分组注释</h3><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// MARK:- 带有分割线</span></div><div class=\"line\"><span class=\"comment\">// MARK: 不带分割线</span></div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"八、访问权限\"><a href=\"#八、访问权限\" class=\"headerlink\" title=\"八、访问权限\"></a>八、访问权限</h2><h3 id=\"1-Swift中的访问权限\"><a href=\"#1-Swift中的访问权限\" class=\"headerlink\" title=\"1. Swift中的访问权限\"></a>1. Swift中的访问权限</h3><ul>\n<li>Swift中的访问控制模型基于模块的源文件这两个概念<ul>\n<li><code>internal</code>: 在本模块中可以进行访问</li>\n<li><code>private</code>: 在当前源文件(项目)可以访问</li>\n<li><code>public</code>: 在其他模块中可以访问</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"九、异常处理\"><a href=\"#九、异常处理\" class=\"headerlink\" title=\"九、异常处理\"></a>九、异常处理</h2><h3 id=\"1-异常的介绍\"><a href=\"#1-异常的介绍\" class=\"headerlink\" title=\"1. 异常的介绍\"></a>1. 异常的介绍</h3><ul>\n<li>只要在编程,就一定会遇到错误处理的问题</li>\n<li>Swift在设计的时候就尽可能的让开发者感知错误,明确处理错误<ul>\n<li>比如: 只有使用个<code>Optional</code>才能处理空值</li>\n</ul>\n</li>\n<li>描述一个错误<ul>\n<li>在Swift中, 任何一个遵守<code>ErrorType protocol</code>的类型，都可以用于描述错误。</li>\n<li><code>ErrorType</code>是一个空的<code>protocol</code>, 它唯一的功能，就是告诉Swift编译器，某个类型用来表示一个错误。</li>\n<li>通常，我们使用一个<code>enum</code>来定义各种错误的可能性</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-异常的示例\"><a href=\"#2-异常的示例\" class=\"headerlink\" title=\"2. 异常的示例\"></a>2. 异常的示例</h3><ul>\n<li>假如想要读取一个文件中的内容,按照OC的逻辑我们可以这样来模拟<ul>\n<li>当调用方法获取结果为<code>nil</code>时,你并不能确定到底参数了什么错误得到了<code>nil</code></li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">readFileContent</span><span class=\"params\">(filePath : String)</span></span> -&gt; <span class=\"type\">String</span>? &#123;</div><div class=\"line\">    <span class=\"comment\">// 1.filePath为\"\"</span></div><div class=\"line\">    <span class=\"keyword\">if</span> filePath == <span class=\"string\">\"\"</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">// 2.filePath有值,但是没有对应的文件</span></div><div class=\"line\">    <span class=\"keyword\">if</span> filePath != <span class=\"string\">\"/User/Desktop/123.plist\"</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">// 3.取出其中的内容</span></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"123\"</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">readFileContent(<span class=\"string\">\"abc\"</span>)</div></pre></td></tr></table></figure>\n<ul>\n<li>使用异常对上述方法的改进</li>\n</ul>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 1.定义异常</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">FileReadError</span> : <span class=\"title\">ErrorType</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">case</span> <span class=\"type\">FileISNull</span></div><div class=\"line\">    <span class=\"keyword\">case</span> <span class=\"type\">FileNotFound</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 2.改进方法,让方法抛出异常</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">readFileContent</span><span class=\"params\">(filePath : String)</span></span> <span class=\"keyword\">throws</span> -&gt; <span class=\"type\">String</span> &#123;</div><div class=\"line\">    <span class=\"comment\">// 1.filePath为\"\"</span></div><div class=\"line\">    <span class=\"keyword\">if</span> filePath == <span class=\"string\">\"\"</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"type\">FileReadError</span>.<span class=\"type\">FileISNull</span></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 2.filepath有值,但是没有对应的文件</span></div><div class=\"line\">    <span class=\"keyword\">if</span> filePath != <span class=\"string\">\"/User/Desktop/123.plist\"</span> &#123;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"type\">FileReadError</span>.<span class=\"type\">FileISNull</span></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 3.取出其中的内容</span></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"123\"</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"3-异常处理的三种方式\"><a href=\"#3-异常处理的三种方式\" class=\"headerlink\" title=\"3. 异常处理的三种方式\"></a>3. 异常处理的三种方式</h3><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 1. try方式,需要手动处理异常</span></div><div class=\"line\"><span class=\"keyword\">do</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> result = <span class=\"keyword\">try</span> readFileContent(<span class=\"string\">\"abc\"</span>)</div><div class=\"line\">&#125; <span class=\"keyword\">catch</span> &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(error)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 2. try?方式,不处理异常,如果出现了异常,则返回一个nil.没有异常,则返回对应的值</span></div><div class=\"line\"><span class=\"comment\">// 最终返回结果为一个可选类型</span></div><div class=\"line\"><span class=\"keyword\">let</span> result = <span class=\"keyword\">try</span>? readFileContent(<span class=\"string\">\"abc\"</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 3. try!方法,告诉系统该方法没有异常.</span></div><div class=\"line\"><span class=\"comment\">// 注意:如果出现了异常,则程序会崩溃</span></div><div class=\"line\"><span class=\"keyword\">try</span>! readFileContent(<span class=\"string\">\"abc\"</span>)</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"十、OC、Swift混编\"><a href=\"#十、OC、Swift混编\" class=\"headerlink\" title=\"十、OC、Swift混编\"></a>十、OC、Swift混编</h2><h3 id=\"1-Swift调用OC\"><a href=\"#1-Swift调用OC\" class=\"headerlink\" title=\"1. Swift调用OC\"></a>1. Swift调用OC</h3><ul>\n<li>创建桥接文件</li>\n<li>配置桥接文件<ul>\n<li>步骤图<br><img src=\"https://yuxiang.ren/images/images/配置桥接文件.png\" alt=\"\"></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-OC调用Swift代码\"><a href=\"#2-OC调用Swift代码\" class=\"headerlink\" title=\"2. OC调用Swift代码\"></a>2. OC调用Swift代码</h3><ul>\n<li>导入<strong>项目名称-Swift.h</strong></li>\n<li>Swift中的所有类以及方法和属性必须使用<code>public</code>修饰</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"一、三大特性\"><a href=\"#一、三大特性\" class=\"headerlink\" title=\"一、三大特性\"></a>一、三大特性</h2><h3 id=\"1-封装，继承，-多态\"><a href=\"#1-封装，继承，-多态\" class=\"headerlink\" title=\"1. 封装，继承， 多态\"></a>1. 封装，继承， 多态</h3><ul>\n<li>多态产生的三大条件<ul>\n<li>必须有继承</li>\n<li>必须有重写</li>\n<li>父类指针指向子类对象</li>\n</ul>\n</li>\n<li>如果子类对父类的方法不满意， 可以对福列的方法进行重写<ul>\n<li>在Swift中如果对弗雷德方法进行个重写,必须在<code>func</code>前加<code>override</code></li>\n</ul>\n</li>\n</ul>","more":"<h3 id=\"2-重载\"><a href=\"#2-重载\" class=\"headerlink\" title=\"2. 重载\"></a>2. 重载</h3><ul>\n<li>重载的使用场景<ul>\n<li>参数的类型不同</li>\n<li>参数的个数不同</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"二、自动引用计数\"><a href=\"#二、自动引用计数\" class=\"headerlink\" title=\"二、自动引用计数\"></a>二、自动引用计数</h2><h3 id=\"1-工作机制\"><a href=\"#1-工作机制\" class=\"headerlink\" title=\"1. 工作机制\"></a>1. 工作机制</h3><ul>\n<li>当有一个强指针指向某一个对象是, 该对象的引用计数会+1</li>\n<li>当该强指针消失时,引用计数会-1</li>\n<li>当引用计数为0时,该对象会被系统回收</li>\n</ul>\n<h3 id=\"2-循环引用\"><a href=\"#2-循环引用\" class=\"headerlink\" title=\"2. 循环引用\"></a>2. 循环引用</h3><ul>\n<li>与OC一样,Swift在开发中经常会出现循环引用的问题</li>\n<li>解决方法,Swift提供了两种方法<ul>\n<li><code>weak</code>: 和OC中的<code>__weak</code>一样,当指向的对象销毁时,会自动将指针指向<code>nil</code></li>\n<li><code>unowned</code>: 和OC中的<code>__unsafe_unretained</code>一样,当指向的对象销毁时,指针依然指向之前的对象,会导致野指针错误</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"三、可选链\"><a href=\"#三、可选链\" class=\"headerlink\" title=\"三、可选链\"></a>三、可选链</h2><h3 id=\"1-可选链的概念\"><a href=\"#1-可选链的概念\" class=\"headerlink\" title=\"1. 可选链的概念\"></a>1. 可选链的概念</h3><ul>\n<li>它的可选性体现于请求或调用的目标当前可能为空<ul>\n<li>如果可选的目标有值，那么调用就会成功</li>\n<li>如果可选的目标为空，则这种调用会返回空</li>\n</ul>\n</li>\n<li>多次调用被链接在一起形成一个链，如果任何一个节点为空将导致整个链失效。</li>\n</ul>\n<h3 id=\"2-可选链的使用\"><a href=\"#2-可选链的使用\" class=\"headerlink\" title=\"2. 可选链的使用\"></a>2. 可选链的使用</h3><ul>\n<li>在可选类型后面放一个问号,可以定义一个可选链</li>\n<li>这一点很像在可选值后面放一个叹号来强制解包<ul>\n<li>他们的主要区别在于当可选值为空时可选链即刻失效</li>\n<li>然而一般的强制解析将会引发运行时的错误</li>\n</ul>\n</li>\n<li>因为可选链的结果可能为空,也可能有值,因此它的返回值是一个可选类型<ul>\n<li>可以通过判断返回值是否有值来判断是否调用成功<ul>\n<li>有值,表示调用成功</li>\n<li>为空,表示调用失败</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"四、协议\"><a href=\"#四、协议\" class=\"headerlink\" title=\"四、协议\"></a>四、协议</h2><h3 id=\"1-协议的格式\"><a href=\"#1-协议的格式\" class=\"headerlink\" title=\"1. 协议的格式\"></a>1. 协议的格式</h3><ul>\n<li>协议的定义与类,结构体,枚举的定义都非常相似</li>\n</ul>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">protocol</span> <span class=\"title\">SomeProtocol</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 协议方法</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>遵守协议的格式</li>\n</ul>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SomeClass</span>: <span class=\"title\">SomeSuperClass</span>, <span class=\"title\">FirstProtocol</span>,  <span class=\"title\">AnotherProtocol</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 类的内容</span></div><div class=\"line\">    <span class=\"comment\">// 实现协议中的方法</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"2-协议的基本使用\"><a href=\"#2-协议的基本使用\" class=\"headerlink\" title=\"2. 协议的基本使用\"></a>2. 协议的基本使用</h3><ul>\n<li>定义协议和遵守协议</li>\n</ul>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 1.定义协议</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">protocol</span> <span class=\"title\">SportProtocol</span> </span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">playBasketball</span><span class=\"params\">()</span></span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">playFootball</span><span class=\"params\">()</span></span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// 2.遵守协议 注意:默认情况下在swift中所有的协议方法都是必须实现的,如果不实现,则编译器会报错</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> : <span class=\"title\">SportProtocol</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> name : <span class=\"type\">String</span>?</div><div class=\"line\">    <span class=\"keyword\">var</span> age : <span class=\"type\">Int</span> = <span class=\"number\">0</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 实现协议中的方法</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">playBasketball</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"人在打篮球\"</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">playFootball</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"人在踢足球\"</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>协议之间的继承</li>\n</ul>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">protocol</span> <span class=\"title\">CrazySportProtocol</span> </span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">jumping</span><span class=\"params\">()</span></span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">protocol</span> <span class=\"title\">SportProtocol</span> : <span class=\"title\">CrazySportProtocol</span> </span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">playBasketball</span><span class=\"params\">()</span></span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">playFootball</span><span class=\"params\">()</span></span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"3-代理设计模式\"><a href=\"#3-代理设计模式\" class=\"headerlink\" title=\"3. 代理设计模式\"></a>3. 代理设计模式</h3><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">protocol</span> <span class=\"title\">BuyTicketProtocol</span> </span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">buyTicket</span><span class=\"params\">()</span></span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 1.定义协议属性</span></div><div class=\"line\">    <span class=\"keyword\">var</span> delegate : <span class=\"type\">BuyTicketProtocol</span></div><div class=\"line\">    <span class=\"comment\">// 2.自定义构造函数</span></div><div class=\"line\">    <span class=\"keyword\">init</span> (delegate : <span class=\"type\">BuyTicketProtocol</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">self</span>.delegate = delegate</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">// 3.行为</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">goToBeijing</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">        delegate.buyTicket()</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HuangNiu</span>: <span class=\"title\">BuyTicketProtocol</span> </span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">buyTicket</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"买了一张火车票\"</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">let</span> p = <span class=\"type\">Person</span>(delegate: <span class=\"type\">HuangNiu</span>())</div><div class=\"line\">p.goToBeijing()</div></pre></td></tr></table></figure>\n<h3 id=\"4-协议中方法的可选\"><a href=\"#4-协议中方法的可选\" class=\"headerlink\" title=\"4. 协议中方法的可选\"></a>4. 协议中方法的可选</h3><ul>\n<li>Swift中的协议默认为必须实现,如果不实现则直接报错</li>\n<li>要想跟OC一样将协议中的方法设置为可选,则需要特殊操作</li>\n</ul>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 1.定义协议</span></div><div class=\"line\"><span class=\"meta\">@objc</span> </div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">protocol</span> <span class=\"title\">SportProtocol</span> </span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">playBasketball</span><span class=\"params\">()</span></span></div><div class=\"line\">    <span class=\"keyword\">optional</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">playFootball</span><span class=\"params\">()</span></span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 2.遵守协议</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> : <span class=\"title\">SportProtocol</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> name : <span class=\"type\">String</span>?</div><div class=\"line\">    <span class=\"keyword\">var</span> age : <span class=\"type\">Int</span> = <span class=\"number\">0</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 实现协议中的方法</span></div><div class=\"line\">    <span class=\"meta\">@objc</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">playBasketball</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"人在打篮球\"</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"五、闭包\"><a href=\"#五、闭包\" class=\"headerlink\" title=\"五、闭包\"></a>五、闭包</h2><h3 id=\"1-闭包的介绍\"><a href=\"#1-闭包的介绍\" class=\"headerlink\" title=\"1. 闭包的介绍\"></a>1. 闭包的介绍</h3><ul>\n<li>闭包和OC中的block非常相似<ul>\n<li>OC中的block是匿名的函数</li>\n<li>Swift中的闭包是特殊的函数</li>\n<li>block和闭包都经常用于回调</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-闭包的写法\"><a href=\"#2-闭包的写法\" class=\"headerlink\" title=\"2. 闭包的写法\"></a>2. 闭包的写法</h3><ul>\n<li>类型:<strong>(形参列表)-&gt;(返回值)</strong></li>\n</ul>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 定义</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">test</span><span class=\"params\">(finished : <span class=\"params\">(parameter : String)</span></span></span> -&gt; ())&#123;</div><div class=\"line\">   finished(parameter : <span class=\"string\">\"block参数\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\">   </div><div class=\"line\"><span class=\"comment\">// 调用</span></div><div class=\"line\">test(&#123; (parameter) -&gt; () <span class=\"keyword\">in</span></div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"block传过来的参数:<span class=\"subst\">\\(parameter)</span>\"</span>)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<h3 id=\"3-闭包的简写\"><a href=\"#3-闭包的简写\" class=\"headerlink\" title=\"3. 闭包的简写\"></a>3. 闭包的简写</h3><ul>\n<li>如果闭包没有写参数, 没有返回值,闭包的参数可以不写</li>\n</ul>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">test(&#123;</div><div class=\"line\">    <span class=\"comment\">// 代码块</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<ul>\n<li>尾随闭包写法:<ul>\n<li>如果闭包是函数的最后一个参数,则可以将闭包卸载()后面</li>\n<li>如果函数只有一个参数,并且这个参数是闭包,那么()可以不写</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 闭包是函数的最后一个参数</span></div><div class=\"line\">test()&#123;</div><div class=\"line\">    <span class=\"comment\">// 代码块</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//函数只有一个参数,并且这个参数是闭包</span></div><div class=\"line\">test &#123;</div><div class=\"line\">    <span class=\"comment\">// 代码块</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"4-闭包导致的循环引用解决方案\"><a href=\"#4-闭包导致的循环引用解决方案\" class=\"headerlink\" title=\"4. 闭包导致的循环引用解决方案\"></a>4. 闭包导致的循环引用解决方案</h3><ul>\n<li>方案一:<ul>\n<li>使用<code>weak</code> 对当前控制器使用弱引用</li>\n<li>但是因为<code>self</code>可能有值也可能没有值,因此<code>weakSelf</code>是一个可选类型,在真正使用时可以对其强制解包(该处强制解包没有问题,因为控制器一定存在,否则无法调用所在函数)</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">weak</span> <span class=\"keyword\">var</span> weakSelf = <span class=\"keyword\">self</span></div></pre></td></tr></table></figure>\n<ul>\n<li>方案二(常用):<ul>\n<li>和方案一类型,只是书写方式更加简单</li>\n<li>可以写在闭包中,并且在闭包中用到的self都是弱引用</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">test(&#123;[<span class=\"keyword\">weak</span> <span class=\"keyword\">self</span>] (parameter) -&gt; () <span class=\"keyword\">in</span></div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"block传过来的参数:<span class=\"subst\">\\(parameter)</span>\"</span>)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<ul>\n<li>方案三:<ul>\n<li>使用关键字<code>unowned</code></li>\n<li>从行为上来说 <code>unowned</code> 更像OC中的 <code>unsafe_unretained</code></li>\n<li><code>unowned</code>表示:即使它原来引用的对象被释放了，仍然会保持对被已经释放了的对象的一个 “无效的” 引用，它不能是<code>Optional</code>值，也不会被指向nil</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">test(&#123;[<span class=\"keyword\">unowned</span> <span class=\"keyword\">self</span>] (parameter) -&gt; () <span class=\"keyword\">in</span></div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"block传过来的参数:<span class=\"subst\">\\(parameter)</span>\"</span>)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"六、懒加载\"><a href=\"#六、懒加载\" class=\"headerlink\" title=\"六、懒加载\"></a>六、懒加载</h2><h3 id=\"1-懒加载的介绍\"><a href=\"#1-懒加载的介绍\" class=\"headerlink\" title=\"1. 懒加载的介绍\"></a>1. 懒加载的介绍</h3><ul>\n<li>苹果的设计思想:希望所有的对象在使用时才真正加载到内存中)</li>\n<li>和OC不同的是Swift有专门的关键字来实现懒加载</li>\n<li><code>lazy</code>关键字可以用于定义某一个属性懒加载</li>\n</ul>\n<h3 id=\"2-懒加载的使用\"><a href=\"#2-懒加载的使用\" class=\"headerlink\" title=\"2. 懒加载的使用\"></a>2. 懒加载的使用</h3><ul>\n<li>格式: 在属性前用<code>lazy</code>修饰</li>\n</ul>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 苹果官方写法: 创建的时候可以设置一些属性</span></div><div class=\"line\"><span class=\"built_in\">lazy</span> <span class=\"keyword\">var</span> btn1 : <span class=\"type\">UIButton</span> = &#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> tempBtn = <span class=\"type\">UIButton</span>()</div><div class=\"line\">    tempBtn.setTitle(<span class=\"string\">\"按钮\"</span> forState:.<span class=\"type\">Normal</span>)</div><div class=\"line\">    <span class=\"keyword\">return</span> tmpBtn</div><div class=\"line\">&#125;()</div><div class=\"line\">    </div><div class=\"line\"><span class=\"comment\">// 简单写法: 只是创建对象</span></div><div class=\"line\"><span class=\"built_in\">lazy</span> <span class=\"keyword\">var</span> btn1 : <span class=\"type\">UIButton</span> = <span class=\"type\">UIButton</span>()</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"七、常见注释\"><a href=\"#七、常见注释\" class=\"headerlink\" title=\"七、常见注释\"></a>七、常见注释</h2><h3 id=\"1-单行注释\"><a href=\"#1-单行注释\" class=\"headerlink\" title=\"1. 单行注释\"></a>1. 单行注释</h3><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 注释</span></div></pre></td></tr></table></figure>\n<h3 id=\"2-多行行注释\"><a href=\"#2-多行行注释\" class=\"headerlink\" title=\"2. 多行行注释\"></a>2. 多行行注释</h3><ul>\n<li>Swift中<code>/* */</code>可以嵌套使用</li>\n</ul>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/*</span></div><div class=\"line\">  注释</div><div class=\"line\">   <span class=\"comment\">/* 注释 */</span></div><div class=\"line\">*/</div></pre></td></tr></table></figure>\n<h3 id=\"3-文档注释\"><a href=\"#3-文档注释\" class=\"headerlink\" title=\"3. 文档注释\"></a>3. 文档注释</h3><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/// 注释</span></div></pre></td></tr></table></figure>\n<h3 id=\"4-分组注释\"><a href=\"#4-分组注释\" class=\"headerlink\" title=\"4. 分组注释\"></a>4. 分组注释</h3><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// MARK:- 带有分割线</span></div><div class=\"line\"><span class=\"comment\">// MARK: 不带分割线</span></div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"八、访问权限\"><a href=\"#八、访问权限\" class=\"headerlink\" title=\"八、访问权限\"></a>八、访问权限</h2><h3 id=\"1-Swift中的访问权限\"><a href=\"#1-Swift中的访问权限\" class=\"headerlink\" title=\"1. Swift中的访问权限\"></a>1. Swift中的访问权限</h3><ul>\n<li>Swift中的访问控制模型基于模块的源文件这两个概念<ul>\n<li><code>internal</code>: 在本模块中可以进行访问</li>\n<li><code>private</code>: 在当前源文件(项目)可以访问</li>\n<li><code>public</code>: 在其他模块中可以访问</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"九、异常处理\"><a href=\"#九、异常处理\" class=\"headerlink\" title=\"九、异常处理\"></a>九、异常处理</h2><h3 id=\"1-异常的介绍\"><a href=\"#1-异常的介绍\" class=\"headerlink\" title=\"1. 异常的介绍\"></a>1. 异常的介绍</h3><ul>\n<li>只要在编程,就一定会遇到错误处理的问题</li>\n<li>Swift在设计的时候就尽可能的让开发者感知错误,明确处理错误<ul>\n<li>比如: 只有使用个<code>Optional</code>才能处理空值</li>\n</ul>\n</li>\n<li>描述一个错误<ul>\n<li>在Swift中, 任何一个遵守<code>ErrorType protocol</code>的类型，都可以用于描述错误。</li>\n<li><code>ErrorType</code>是一个空的<code>protocol</code>, 它唯一的功能，就是告诉Swift编译器，某个类型用来表示一个错误。</li>\n<li>通常，我们使用一个<code>enum</code>来定义各种错误的可能性</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-异常的示例\"><a href=\"#2-异常的示例\" class=\"headerlink\" title=\"2. 异常的示例\"></a>2. 异常的示例</h3><ul>\n<li>假如想要读取一个文件中的内容,按照OC的逻辑我们可以这样来模拟<ul>\n<li>当调用方法获取结果为<code>nil</code>时,你并不能确定到底参数了什么错误得到了<code>nil</code></li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">readFileContent</span><span class=\"params\">(filePath : String)</span></span> -&gt; <span class=\"type\">String</span>? &#123;</div><div class=\"line\">    <span class=\"comment\">// 1.filePath为\"\"</span></div><div class=\"line\">    <span class=\"keyword\">if</span> filePath == <span class=\"string\">\"\"</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">// 2.filePath有值,但是没有对应的文件</span></div><div class=\"line\">    <span class=\"keyword\">if</span> filePath != <span class=\"string\">\"/User/Desktop/123.plist\"</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">// 3.取出其中的内容</span></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"123\"</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">readFileContent(<span class=\"string\">\"abc\"</span>)</div></pre></td></tr></table></figure>\n<ul>\n<li>使用异常对上述方法的改进</li>\n</ul>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 1.定义异常</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">FileReadError</span> : <span class=\"title\">ErrorType</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">case</span> <span class=\"type\">FileISNull</span></div><div class=\"line\">    <span class=\"keyword\">case</span> <span class=\"type\">FileNotFound</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 2.改进方法,让方法抛出异常</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">readFileContent</span><span class=\"params\">(filePath : String)</span></span> <span class=\"keyword\">throws</span> -&gt; <span class=\"type\">String</span> &#123;</div><div class=\"line\">    <span class=\"comment\">// 1.filePath为\"\"</span></div><div class=\"line\">    <span class=\"keyword\">if</span> filePath == <span class=\"string\">\"\"</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"type\">FileReadError</span>.<span class=\"type\">FileISNull</span></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 2.filepath有值,但是没有对应的文件</span></div><div class=\"line\">    <span class=\"keyword\">if</span> filePath != <span class=\"string\">\"/User/Desktop/123.plist\"</span> &#123;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"type\">FileReadError</span>.<span class=\"type\">FileISNull</span></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 3.取出其中的内容</span></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"123\"</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"3-异常处理的三种方式\"><a href=\"#3-异常处理的三种方式\" class=\"headerlink\" title=\"3. 异常处理的三种方式\"></a>3. 异常处理的三种方式</h3><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 1. try方式,需要手动处理异常</span></div><div class=\"line\"><span class=\"keyword\">do</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> result = <span class=\"keyword\">try</span> readFileContent(<span class=\"string\">\"abc\"</span>)</div><div class=\"line\">&#125; <span class=\"keyword\">catch</span> &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(error)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 2. try?方式,不处理异常,如果出现了异常,则返回一个nil.没有异常,则返回对应的值</span></div><div class=\"line\"><span class=\"comment\">// 最终返回结果为一个可选类型</span></div><div class=\"line\"><span class=\"keyword\">let</span> result = <span class=\"keyword\">try</span>? readFileContent(<span class=\"string\">\"abc\"</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 3. try!方法,告诉系统该方法没有异常.</span></div><div class=\"line\"><span class=\"comment\">// 注意:如果出现了异常,则程序会崩溃</span></div><div class=\"line\"><span class=\"keyword\">try</span>! readFileContent(<span class=\"string\">\"abc\"</span>)</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"十、OC、Swift混编\"><a href=\"#十、OC、Swift混编\" class=\"headerlink\" title=\"十、OC、Swift混编\"></a>十、OC、Swift混编</h2><h3 id=\"1-Swift调用OC\"><a href=\"#1-Swift调用OC\" class=\"headerlink\" title=\"1. Swift调用OC\"></a>1. Swift调用OC</h3><ul>\n<li>创建桥接文件</li>\n<li>配置桥接文件<ul>\n<li>步骤图<br><img src=\"https://yuxiang.ren/images/images/配置桥接文件.png\" alt=\"\"></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-OC调用Swift代码\"><a href=\"#2-OC调用Swift代码\" class=\"headerlink\" title=\"2. OC调用Swift代码\"></a>2. OC调用Swift代码</h3><ul>\n<li>导入<strong>项目名称-Swift.h</strong></li>\n<li>Swift中的所有类以及方法和属性必须使用<code>public</code>修饰</li>\n</ul>"},{"title":"Terminal命令之wget用法","date":"2017-04-27T08:09:45.000Z","_content":"\n\n\n wget : 一款下载命令\n\n1. 支持断点下传功能\n2. 同时支持FTP和HTTP下载方式\n3. 支持代理服务器\n4. 设置方便简单\n5. 程序小，完全免费\n6. 安装: `brew install wget`\n\nwget语法: wget<参数> 文件url\n\n<!-- more -->\n\n# 下载http/ftp站点\n\n1. `wget url`: 下载url页面\n2. `wget -r url`: 递归下载url页面\n3. `wget -p url`: 下载url页面下的所有资源\n\n# 下载文件\n\n1. `wget -c url`: 断点续传下载文件\n2. 批量下载:\n   * 如果有多个文件需要下载，那么可以生成一个文件，把每个文件的URL写一行，例如生成文件**download.txt**,\n   * `wget -i download.txt`: 下载文件用所有的url\n3. 选择下载\n   * `wget -m -regect=gif url`\n   * 上面命令表示:  下载url下所有文件, 胡虐.git类型文件\n\n\n\n\n\n\n","source":"_posts/Terminal命令之wget用法.md","raw":"---\ntitle: Terminal命令之wget用法\ndate: 2017-04-27 16:09:45\ncategories: 命令\ntags: 命令\n---\n\n\n\n wget : 一款下载命令\n\n1. 支持断点下传功能\n2. 同时支持FTP和HTTP下载方式\n3. 支持代理服务器\n4. 设置方便简单\n5. 程序小，完全免费\n6. 安装: `brew install wget`\n\nwget语法: wget<参数> 文件url\n\n<!-- more -->\n\n# 下载http/ftp站点\n\n1. `wget url`: 下载url页面\n2. `wget -r url`: 递归下载url页面\n3. `wget -p url`: 下载url页面下的所有资源\n\n# 下载文件\n\n1. `wget -c url`: 断点续传下载文件\n2. 批量下载:\n   * 如果有多个文件需要下载，那么可以生成一个文件，把每个文件的URL写一行，例如生成文件**download.txt**,\n   * `wget -i download.txt`: 下载文件用所有的url\n3. 选择下载\n   * `wget -m -regect=gif url`\n   * 上面命令表示:  下载url下所有文件, 胡虐.git类型文件\n\n\n\n\n\n\n","slug":"Terminal命令之wget用法","published":1,"updated":"2017-04-27T08:21:52.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6686xla000pxe9z4qbove1i","content":"<p> wget : 一款下载命令</p>\n<ol>\n<li>支持断点下传功能</li>\n<li>同时支持FTP和HTTP下载方式</li>\n<li>支持代理服务器</li>\n<li>设置方便简单</li>\n<li>程序小，完全免费</li>\n<li>安装: <code>brew install wget</code></li>\n</ol>\n<p>wget语法: wget&lt;参数&gt; 文件url</p>\n<a id=\"more\"></a>\n<h1 id=\"下载http-ftp站点\"><a href=\"#下载http-ftp站点\" class=\"headerlink\" title=\"下载http/ftp站点\"></a>下载http/ftp站点</h1><ol>\n<li><code>wget url</code>: 下载url页面</li>\n<li><code>wget -r url</code>: 递归下载url页面</li>\n<li><code>wget -p url</code>: 下载url页面下的所有资源</li>\n</ol>\n<h1 id=\"下载文件\"><a href=\"#下载文件\" class=\"headerlink\" title=\"下载文件\"></a>下载文件</h1><ol>\n<li><code>wget -c url</code>: 断点续传下载文件</li>\n<li>批量下载:<ul>\n<li>如果有多个文件需要下载，那么可以生成一个文件，把每个文件的URL写一行，例如生成文件<strong>download.txt</strong>,</li>\n<li><code>wget -i download.txt</code>: 下载文件用所有的url</li>\n</ul>\n</li>\n<li>选择下载<ul>\n<li><code>wget -m -regect=gif url</code></li>\n<li>上面命令表示:  下载url下所有文件, 胡虐.git类型文件</li>\n</ul>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"<p> wget : 一款下载命令</p>\n<ol>\n<li>支持断点下传功能</li>\n<li>同时支持FTP和HTTP下载方式</li>\n<li>支持代理服务器</li>\n<li>设置方便简单</li>\n<li>程序小，完全免费</li>\n<li>安装: <code>brew install wget</code></li>\n</ol>\n<p>wget语法: wget&lt;参数&gt; 文件url</p>","more":"<h1 id=\"下载http-ftp站点\"><a href=\"#下载http-ftp站点\" class=\"headerlink\" title=\"下载http/ftp站点\"></a>下载http/ftp站点</h1><ol>\n<li><code>wget url</code>: 下载url页面</li>\n<li><code>wget -r url</code>: 递归下载url页面</li>\n<li><code>wget -p url</code>: 下载url页面下的所有资源</li>\n</ol>\n<h1 id=\"下载文件\"><a href=\"#下载文件\" class=\"headerlink\" title=\"下载文件\"></a>下载文件</h1><ol>\n<li><code>wget -c url</code>: 断点续传下载文件</li>\n<li>批量下载:<ul>\n<li>如果有多个文件需要下载，那么可以生成一个文件，把每个文件的URL写一行，例如生成文件<strong>download.txt</strong>,</li>\n<li><code>wget -i download.txt</code>: 下载文件用所有的url</li>\n</ul>\n</li>\n<li>选择下载<ul>\n<li><code>wget -m -regect=gif url</code></li>\n<li>上面命令表示:  下载url下所有文件, 胡虐.git类型文件</li>\n</ul>\n</li>\n</ol>"},{"title":"重写UIScrollView分类dealloc错误","date":"2016-12-06T01:25:01.000Z","_content":"\n> [UIScrollView _systemGestureStateChanged:]: message sent to deallocated instance> 错误解决方法\n> [UITableViewWrapperView _systemGestureStateChanged] 解决亦是如此\n\n今天一个朋友自己的程序出现了一个bug, 不知道怎么解决, 他把报错内容给我, 报错内容如下:\n\n<img src=\"https://ww4.sinaimg.cn/large/65e4f1e6gw1fagsd983rsj21g60ggjyt.jpg\" width = \"600\"/>\n就是普通的僵尸对象错误, 可是解决就不是那么简单了...\n\n我翻边了各大国内过外网站, 终于再一个不显眼的地方看到了大致是因为在`UIScrollView`分类重写了`dealloc`方法导致.\n\n<!-- more -->\n\n于是我去项目里看一下`UIScrollView`的分类. 果真, 这个第三方重写了`dealoc`, 把它注释掉果然没有出现僵尸对象了.\n\n可是问题又来了,这个分类是在`dealloc`里移除监听的\n<img src=\"https://ww4.sinaimg.cn/large/65e4f1e6gw1fagsjlodobj20qw04ywfe.jpg\" width = \"500\"/>\n\n我想到了`MJRefresh`使用的也是同样的原理, 于是我去看了他的代码,他是再这里移除监听的\n<img src=\"https://ww4.sinaimg.cn/large/65e4f1e6gw1fagsl6oopij210a07yacr.jpg\" width = \"500\"/>\n\n那我们就学着他\n<img src=\"https://ww4.sinaimg.cn/large/65e4f1e6gw1fagslu9vecj20zk0ba41t.jpg\" width = \"500\"/>\n\n重新运行程序, 问题解决.\n\n然而, 又有新的问题出现, 就是通知移除的问题, 为了彻底解决自己写了个.\n代码地址:https://github.com/shlyren/ZYScaleHeader\n\n","source":"_posts/UIScrollView-Category-error-message-with-deallocated-instance.md","raw":"---\ntitle: 重写UIScrollView分类dealloc错误\ndate: 2016-12-06 09:25:01\ncategories: error\ntags: [Xcode, error]\n---\n\n> [UIScrollView _systemGestureStateChanged:]: message sent to deallocated instance> 错误解决方法\n> [UITableViewWrapperView _systemGestureStateChanged] 解决亦是如此\n\n今天一个朋友自己的程序出现了一个bug, 不知道怎么解决, 他把报错内容给我, 报错内容如下:\n\n<img src=\"https://ww4.sinaimg.cn/large/65e4f1e6gw1fagsd983rsj21g60ggjyt.jpg\" width = \"600\"/>\n就是普通的僵尸对象错误, 可是解决就不是那么简单了...\n\n我翻边了各大国内过外网站, 终于再一个不显眼的地方看到了大致是因为在`UIScrollView`分类重写了`dealloc`方法导致.\n\n<!-- more -->\n\n于是我去项目里看一下`UIScrollView`的分类. 果真, 这个第三方重写了`dealoc`, 把它注释掉果然没有出现僵尸对象了.\n\n可是问题又来了,这个分类是在`dealloc`里移除监听的\n<img src=\"https://ww4.sinaimg.cn/large/65e4f1e6gw1fagsjlodobj20qw04ywfe.jpg\" width = \"500\"/>\n\n我想到了`MJRefresh`使用的也是同样的原理, 于是我去看了他的代码,他是再这里移除监听的\n<img src=\"https://ww4.sinaimg.cn/large/65e4f1e6gw1fagsl6oopij210a07yacr.jpg\" width = \"500\"/>\n\n那我们就学着他\n<img src=\"https://ww4.sinaimg.cn/large/65e4f1e6gw1fagslu9vecj20zk0ba41t.jpg\" width = \"500\"/>\n\n重新运行程序, 问题解决.\n\n然而, 又有新的问题出现, 就是通知移除的问题, 为了彻底解决自己写了个.\n代码地址:https://github.com/shlyren/ZYScaleHeader\n\n","slug":"UIScrollView-Category-error-message-with-deallocated-instance","published":1,"updated":"2017-04-13T07:51:46.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6686xlc000txe9zdripquqh","content":"<blockquote>\n<p>[UIScrollView _systemGestureStateChanged:]: message sent to deallocated instance&gt; 错误解决方法<br>[UITableViewWrapperView _systemGestureStateChanged] 解决亦是如此</p>\n</blockquote>\n<p>今天一个朋友自己的程序出现了一个bug, 不知道怎么解决, 他把报错内容给我, 报错内容如下:</p>\n<p><img src=\"https://ww4.sinaimg.cn/large/65e4f1e6gw1fagsd983rsj21g60ggjyt.jpg\" width=\"600\"><br>就是普通的僵尸对象错误, 可是解决就不是那么简单了…</p>\n<p>我翻边了各大国内过外网站, 终于再一个不显眼的地方看到了大致是因为在<code>UIScrollView</code>分类重写了<code>dealloc</code>方法导致.</p>\n<a id=\"more\"></a>\n<p>于是我去项目里看一下<code>UIScrollView</code>的分类. 果真, 这个第三方重写了<code>dealoc</code>, 把它注释掉果然没有出现僵尸对象了.</p>\n<p>可是问题又来了,这个分类是在<code>dealloc</code>里移除监听的<br><img src=\"https://ww4.sinaimg.cn/large/65e4f1e6gw1fagsjlodobj20qw04ywfe.jpg\" width=\"500\"></p>\n<p>我想到了<code>MJRefresh</code>使用的也是同样的原理, 于是我去看了他的代码,他是再这里移除监听的<br><img src=\"https://ww4.sinaimg.cn/large/65e4f1e6gw1fagsl6oopij210a07yacr.jpg\" width=\"500\"></p>\n<p>那我们就学着他<br><img src=\"https://ww4.sinaimg.cn/large/65e4f1e6gw1fagslu9vecj20zk0ba41t.jpg\" width=\"500\"></p>\n<p>重新运行程序, 问题解决.</p>\n<p>然而, 又有新的问题出现, 就是通知移除的问题, 为了彻底解决自己写了个.<br>代码地址:<a href=\"https://github.com/shlyren/ZYScaleHeader\" target=\"_blank\" rel=\"external\">https://github.com/shlyren/ZYScaleHeader</a></p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>[UIScrollView _systemGestureStateChanged:]: message sent to deallocated instance&gt; 错误解决方法<br>[UITableViewWrapperView _systemGestureStateChanged] 解决亦是如此</p>\n</blockquote>\n<p>今天一个朋友自己的程序出现了一个bug, 不知道怎么解决, 他把报错内容给我, 报错内容如下:</p>\n<p><img src=\"https://ww4.sinaimg.cn/large/65e4f1e6gw1fagsd983rsj21g60ggjyt.jpg\" width=\"600\"><br>就是普通的僵尸对象错误, 可是解决就不是那么简单了…</p>\n<p>我翻边了各大国内过外网站, 终于再一个不显眼的地方看到了大致是因为在<code>UIScrollView</code>分类重写了<code>dealloc</code>方法导致.</p>","more":"<p>于是我去项目里看一下<code>UIScrollView</code>的分类. 果真, 这个第三方重写了<code>dealoc</code>, 把它注释掉果然没有出现僵尸对象了.</p>\n<p>可是问题又来了,这个分类是在<code>dealloc</code>里移除监听的<br><img src=\"https://ww4.sinaimg.cn/large/65e4f1e6gw1fagsjlodobj20qw04ywfe.jpg\" width=\"500\"></p>\n<p>我想到了<code>MJRefresh</code>使用的也是同样的原理, 于是我去看了他的代码,他是再这里移除监听的<br><img src=\"https://ww4.sinaimg.cn/large/65e4f1e6gw1fagsl6oopij210a07yacr.jpg\" width=\"500\"></p>\n<p>那我们就学着他<br><img src=\"https://ww4.sinaimg.cn/large/65e4f1e6gw1fagslu9vecj20zk0ba41t.jpg\" width=\"500\"></p>\n<p>重新运行程序, 问题解决.</p>\n<p>然而, 又有新的问题出现, 就是通知移除的问题, 为了彻底解决自己写了个.<br>代码地址:<a href=\"https://github.com/shlyren/ZYScaleHeader\" target=\"_blank\" rel=\"external\">https://github.com/shlyren/ZYScaleHeader</a></p>"},{"title":"Ubuntu更新Nginx服务","date":"2017-03-30T07:25:03.000Z","_content":"\nUbuntu 官方自带的 nginx 版本非常低。我安装的默认版本是1.4.6。如果需要更好的性能和功能，那么需要将 nginx 升级到最新版。目前最新版稳定版为 1.10.1，mainline 开发版是 1.11。\n\n<!-- more -->\n\n### 一. 确定Ubuntu版本号\n\n1. 登录服务器\n\n2. 使用`lsb_release -a`查看版本号 返回结果如下\n\n   ```ruby\n   No LSB modules are available.\n   Distributor ID:\tUbuntu\n   Description:\tUbuntu 14.04.4 LTS\n   Release:\t14.04 #ubuntu 的版本\n   Codename:\ttrusty #代码号\n   ```\n\n   * 常用的 14.04 是 trusty ，12.04 是 precise ，14.10 是 utopic ，16.04 是 xenial。\n\n### 二. 下载安装 nginx 官方服务器的验证 key\n\n1. `wget http://nginx.org/keys/nginx_signing.key`\n2. `apt-key add nginx_signing.key`\n\n### 三. 添加官方 nginx 地址源\n\n1. 编辑 `/etc/apt/sources.list.d/nginx.list` 文档。\n\n2. 在里面添加或修改:\n\n   ```ruby\n   #开发版\n   deb http://nginx.org/packages/mainline/ubuntu/ `代码号` nginx\n   deb-src http://nginx.org/packages/mainline/ubuntu/ `代码号` nginx\n\n   #稳定版\n   deb http://nginx.org/packages/debian/ `代码号` nginx\n   deb-src http://nginx.org/packages/debian/ `代码号` ngin\n   ```\n\n   ​\n\n   * 其中**代码号**部分换成第一步查到的参数，mainline 根据你的需要选择 `mainline` 或是 `stable`（如果你更看重稳定性的话),比如我的 **Ubuntu 14.04**版安装\n\n     * **mainline开发版**为：\n\n       ```ruby\n       deb http://nginx.org/packages/mainline/ubuntu/ trusty nginx\n       deb-src http://nginx.org/packages/mainline/ubuntu/ trusty nginx\n       ```\n\n\n     * **Stable 稳定版**为：\n\n       ```ruby\n       deb http://nginx.org/packages/ubuntu/ trusty nginx\n       deb-src http://nginx.org/packages/ubuntu/ trusty nginx\n       ```\n\n### 四. 更新Nginx\n\n1. 安装命令:\n\n   ```Shell\n   sudo apt-get update && apt-get install nginx\n   ```\n\n2. 升级命令\n\n   ```shell\n   sudo apt-get update && apt-get upgrade nginx\n   ```\n\n   * 如果出错，则可能你需要先删除旧的 nginx，再进行上一步骤新装处理。\n     删除旧 nginx 的命令：\n\n     ```shell\n     apt-get remove nginx nginx-common nginx-core\n     ```\n\n* 如果出现以下提醒:\n\n  ```ruby\n  Configuration file '/etc/nginx/nginx.conf'\n   ==> Modified (by you or by a script) since installation.\n   ==> Package distributor has shipped an updated version.\n     What would you like to do about it ?  Your options are:\n      Y or I  : install the package maintainer's version\n      N or O  : keep your currently-installed version\n        D     : show the differences between the versions\n        Z     : start a shell to examine the situation\n   The default action is to keep your current version.\n  *** nginx.conf (Y/I/N/O/D/Z) [default=N]\n  ```\n\n  * 选择N(默认)即可\n\n最后使用命令`nginx -v`查看当前的nginx版本如果是`nginx version: nginx/1.10.1`表示升级成功","source":"_posts/Ubuntu更新Nginx服务.md","raw":"---\ntitle: Ubuntu更新Nginx服务\ndate: 2017-03-30 15:25:03\ncategories: 教程\ntags: [教程]\n---\n\nUbuntu 官方自带的 nginx 版本非常低。我安装的默认版本是1.4.6。如果需要更好的性能和功能，那么需要将 nginx 升级到最新版。目前最新版稳定版为 1.10.1，mainline 开发版是 1.11。\n\n<!-- more -->\n\n### 一. 确定Ubuntu版本号\n\n1. 登录服务器\n\n2. 使用`lsb_release -a`查看版本号 返回结果如下\n\n   ```ruby\n   No LSB modules are available.\n   Distributor ID:\tUbuntu\n   Description:\tUbuntu 14.04.4 LTS\n   Release:\t14.04 #ubuntu 的版本\n   Codename:\ttrusty #代码号\n   ```\n\n   * 常用的 14.04 是 trusty ，12.04 是 precise ，14.10 是 utopic ，16.04 是 xenial。\n\n### 二. 下载安装 nginx 官方服务器的验证 key\n\n1. `wget http://nginx.org/keys/nginx_signing.key`\n2. `apt-key add nginx_signing.key`\n\n### 三. 添加官方 nginx 地址源\n\n1. 编辑 `/etc/apt/sources.list.d/nginx.list` 文档。\n\n2. 在里面添加或修改:\n\n   ```ruby\n   #开发版\n   deb http://nginx.org/packages/mainline/ubuntu/ `代码号` nginx\n   deb-src http://nginx.org/packages/mainline/ubuntu/ `代码号` nginx\n\n   #稳定版\n   deb http://nginx.org/packages/debian/ `代码号` nginx\n   deb-src http://nginx.org/packages/debian/ `代码号` ngin\n   ```\n\n   ​\n\n   * 其中**代码号**部分换成第一步查到的参数，mainline 根据你的需要选择 `mainline` 或是 `stable`（如果你更看重稳定性的话),比如我的 **Ubuntu 14.04**版安装\n\n     * **mainline开发版**为：\n\n       ```ruby\n       deb http://nginx.org/packages/mainline/ubuntu/ trusty nginx\n       deb-src http://nginx.org/packages/mainline/ubuntu/ trusty nginx\n       ```\n\n\n     * **Stable 稳定版**为：\n\n       ```ruby\n       deb http://nginx.org/packages/ubuntu/ trusty nginx\n       deb-src http://nginx.org/packages/ubuntu/ trusty nginx\n       ```\n\n### 四. 更新Nginx\n\n1. 安装命令:\n\n   ```Shell\n   sudo apt-get update && apt-get install nginx\n   ```\n\n2. 升级命令\n\n   ```shell\n   sudo apt-get update && apt-get upgrade nginx\n   ```\n\n   * 如果出错，则可能你需要先删除旧的 nginx，再进行上一步骤新装处理。\n     删除旧 nginx 的命令：\n\n     ```shell\n     apt-get remove nginx nginx-common nginx-core\n     ```\n\n* 如果出现以下提醒:\n\n  ```ruby\n  Configuration file '/etc/nginx/nginx.conf'\n   ==> Modified (by you or by a script) since installation.\n   ==> Package distributor has shipped an updated version.\n     What would you like to do about it ?  Your options are:\n      Y or I  : install the package maintainer's version\n      N or O  : keep your currently-installed version\n        D     : show the differences between the versions\n        Z     : start a shell to examine the situation\n   The default action is to keep your current version.\n  *** nginx.conf (Y/I/N/O/D/Z) [default=N]\n  ```\n\n  * 选择N(默认)即可\n\n最后使用命令`nginx -v`查看当前的nginx版本如果是`nginx version: nginx/1.10.1`表示升级成功","slug":"Ubuntu更新Nginx服务","published":1,"updated":"2017-04-28T08:40:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6686xld000vxe9z3g8rqlkh","content":"<p>Ubuntu 官方自带的 nginx 版本非常低。我安装的默认版本是1.4.6。如果需要更好的性能和功能，那么需要将 nginx 升级到最新版。目前最新版稳定版为 1.10.1，mainline 开发版是 1.11。</p>\n<a id=\"more\"></a>\n<h3 id=\"一-确定Ubuntu版本号\"><a href=\"#一-确定Ubuntu版本号\" class=\"headerlink\" title=\"一. 确定Ubuntu版本号\"></a>一. 确定Ubuntu版本号</h3><ol>\n<li><p>登录服务器</p>\n</li>\n<li><p>使用<code>lsb_release -a</code>查看版本号 返回结果如下</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">No LSB modules are available.</div><div class=\"line\">Distributor <span class=\"symbol\">ID:</span>\tUbuntu</div><div class=\"line\"><span class=\"symbol\">Description:</span>\tUbuntu <span class=\"number\">14.04</span>.<span class=\"number\">4</span> LTS</div><div class=\"line\"><span class=\"symbol\">Release:</span>\t<span class=\"number\">14.04</span> <span class=\"comment\">#ubuntu 的版本</span></div><div class=\"line\"><span class=\"symbol\">Codename:</span>\ttrusty <span class=\"comment\">#代码号</span></div></pre></td></tr></table></figure>\n<ul>\n<li>常用的 14.04 是 trusty ，12.04 是 precise ，14.10 是 utopic ，16.04 是 xenial。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"二-下载安装-nginx-官方服务器的验证-key\"><a href=\"#二-下载安装-nginx-官方服务器的验证-key\" class=\"headerlink\" title=\"二. 下载安装 nginx 官方服务器的验证 key\"></a>二. 下载安装 nginx 官方服务器的验证 key</h3><ol>\n<li><code>wget http://nginx.org/keys/nginx_signing.key</code></li>\n<li><code>apt-key add nginx_signing.key</code></li>\n</ol>\n<h3 id=\"三-添加官方-nginx-地址源\"><a href=\"#三-添加官方-nginx-地址源\" class=\"headerlink\" title=\"三. 添加官方 nginx 地址源\"></a>三. 添加官方 nginx 地址源</h3><ol>\n<li><p>编辑 <code>/etc/apt/sources.list.d/nginx.list</code> 文档。</p>\n</li>\n<li><p>在里面添加或修改:</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">#开发版</div><div class=\"line\">deb http://nginx.org/packages/mainline/ubuntu/ `代码号` nginx</div><div class=\"line\">deb-src http://nginx.org/packages/mainline/ubuntu/ `代码号` nginx</div><div class=\"line\"></div><div class=\"line\">#稳定版</div><div class=\"line\">deb http://nginx.org/packages/debian/ `代码号` nginx</div><div class=\"line\">deb-src http://nginx.org/packages/debian/ `代码号` ngin</div></pre></td></tr></table></figure>\n<p>​</p>\n<ul>\n<li><p>其中<strong>代码号</strong>部分换成第一步查到的参数，mainline 根据你的需要选择 <code>mainline</code> 或是 <code>stable</code>（如果你更看重稳定性的话),比如我的 <strong>Ubuntu 14.04</strong>版安装</p>\n<ul>\n<li><p><strong>mainline开发版</strong>为：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">deb http://nginx.org/packages/mainline/ubuntu/ trusty nginx</div><div class=\"line\">deb-src http://nginx.org/packages/mainline/ubuntu/ trusty nginx</div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>Stable 稳定版</strong>为：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">deb <span class=\"symbol\">http:</span>/<span class=\"regexp\">/nginx.org/packages</span><span class=\"regexp\">/ubuntu/</span> trusty nginx</div><div class=\"line\">deb-src <span class=\"symbol\">http:</span>/<span class=\"regexp\">/nginx.org/packages</span><span class=\"regexp\">/ubuntu/</span> trusty nginx</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"四-更新Nginx\"><a href=\"#四-更新Nginx\" class=\"headerlink\" title=\"四. 更新Nginx\"></a>四. 更新Nginx</h3><ol>\n<li><p>安装命令:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo apt-get update &amp;&amp; apt-get install nginx</div></pre></td></tr></table></figure>\n</li>\n<li><p>升级命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo apt-get update &amp;&amp; apt-get upgrade nginx</div></pre></td></tr></table></figure>\n<ul>\n<li><p>如果出错，则可能你需要先删除旧的 nginx，再进行上一步骤新装处理。<br>删除旧 nginx 的命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">apt-get remove nginx nginx-common nginx-core</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ol>\n<ul>\n<li><p>如果出现以下提醒:</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">Configuration file <span class=\"string\">'/etc/nginx/nginx.conf'</span></div><div class=\"line\"> ==&gt; Modified (by you <span class=\"keyword\">or</span> by a script) since installation.</div><div class=\"line\"> ==&gt; Package distributor has shipped an updated version.</div><div class=\"line\">   What would you like to <span class=\"keyword\">do</span> about it ?  Your options <span class=\"symbol\">are:</span></div><div class=\"line\">    Y <span class=\"keyword\">or</span> I  : install the package maintainer<span class=\"string\">'s version</span></div><div class=\"line\">    N or O  : keep your currently-installed version</div><div class=\"line\">      D     : show the differences between the versions</div><div class=\"line\">      Z     : start a shell to examine the situation</div><div class=\"line\"> The default action is to keep your current version.</div><div class=\"line\">*** nginx.conf (Y/I/N/O/D/Z) [default=N]</div></pre></td></tr></table></figure>\n<ul>\n<li>选择N(默认)即可</li>\n</ul>\n</li>\n</ul>\n<p>最后使用命令<code>nginx -v</code>查看当前的nginx版本如果是<code>nginx version: nginx/1.10.1</code>表示升级成功</p>\n","site":{"data":{}},"excerpt":"<p>Ubuntu 官方自带的 nginx 版本非常低。我安装的默认版本是1.4.6。如果需要更好的性能和功能，那么需要将 nginx 升级到最新版。目前最新版稳定版为 1.10.1，mainline 开发版是 1.11。</p>","more":"<h3 id=\"一-确定Ubuntu版本号\"><a href=\"#一-确定Ubuntu版本号\" class=\"headerlink\" title=\"一. 确定Ubuntu版本号\"></a>一. 确定Ubuntu版本号</h3><ol>\n<li><p>登录服务器</p>\n</li>\n<li><p>使用<code>lsb_release -a</code>查看版本号 返回结果如下</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">No LSB modules are available.</div><div class=\"line\">Distributor <span class=\"symbol\">ID:</span>\tUbuntu</div><div class=\"line\"><span class=\"symbol\">Description:</span>\tUbuntu <span class=\"number\">14.04</span>.<span class=\"number\">4</span> LTS</div><div class=\"line\"><span class=\"symbol\">Release:</span>\t<span class=\"number\">14.04</span> <span class=\"comment\">#ubuntu 的版本</span></div><div class=\"line\"><span class=\"symbol\">Codename:</span>\ttrusty <span class=\"comment\">#代码号</span></div></pre></td></tr></table></figure>\n<ul>\n<li>常用的 14.04 是 trusty ，12.04 是 precise ，14.10 是 utopic ，16.04 是 xenial。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"二-下载安装-nginx-官方服务器的验证-key\"><a href=\"#二-下载安装-nginx-官方服务器的验证-key\" class=\"headerlink\" title=\"二. 下载安装 nginx 官方服务器的验证 key\"></a>二. 下载安装 nginx 官方服务器的验证 key</h3><ol>\n<li><code>wget http://nginx.org/keys/nginx_signing.key</code></li>\n<li><code>apt-key add nginx_signing.key</code></li>\n</ol>\n<h3 id=\"三-添加官方-nginx-地址源\"><a href=\"#三-添加官方-nginx-地址源\" class=\"headerlink\" title=\"三. 添加官方 nginx 地址源\"></a>三. 添加官方 nginx 地址源</h3><ol>\n<li><p>编辑 <code>/etc/apt/sources.list.d/nginx.list</code> 文档。</p>\n</li>\n<li><p>在里面添加或修改:</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">#开发版</div><div class=\"line\">deb http://nginx.org/packages/mainline/ubuntu/ `代码号` nginx</div><div class=\"line\">deb-src http://nginx.org/packages/mainline/ubuntu/ `代码号` nginx</div><div class=\"line\"></div><div class=\"line\">#稳定版</div><div class=\"line\">deb http://nginx.org/packages/debian/ `代码号` nginx</div><div class=\"line\">deb-src http://nginx.org/packages/debian/ `代码号` ngin</div></pre></td></tr></table></figure>\n<p>​</p>\n<ul>\n<li><p>其中<strong>代码号</strong>部分换成第一步查到的参数，mainline 根据你的需要选择 <code>mainline</code> 或是 <code>stable</code>（如果你更看重稳定性的话),比如我的 <strong>Ubuntu 14.04</strong>版安装</p>\n<ul>\n<li><p><strong>mainline开发版</strong>为：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">deb http://nginx.org/packages/mainline/ubuntu/ trusty nginx</div><div class=\"line\">deb-src http://nginx.org/packages/mainline/ubuntu/ trusty nginx</div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>Stable 稳定版</strong>为：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">deb <span class=\"symbol\">http:</span>/<span class=\"regexp\">/nginx.org/packages</span><span class=\"regexp\">/ubuntu/</span> trusty nginx</div><div class=\"line\">deb-src <span class=\"symbol\">http:</span>/<span class=\"regexp\">/nginx.org/packages</span><span class=\"regexp\">/ubuntu/</span> trusty nginx</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"四-更新Nginx\"><a href=\"#四-更新Nginx\" class=\"headerlink\" title=\"四. 更新Nginx\"></a>四. 更新Nginx</h3><ol>\n<li><p>安装命令:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo apt-get update &amp;&amp; apt-get install nginx</div></pre></td></tr></table></figure>\n</li>\n<li><p>升级命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo apt-get update &amp;&amp; apt-get upgrade nginx</div></pre></td></tr></table></figure>\n<ul>\n<li><p>如果出错，则可能你需要先删除旧的 nginx，再进行上一步骤新装处理。<br>删除旧 nginx 的命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">apt-get remove nginx nginx-common nginx-core</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ol>\n<ul>\n<li><p>如果出现以下提醒:</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">Configuration file <span class=\"string\">'/etc/nginx/nginx.conf'</span></div><div class=\"line\"> ==&gt; Modified (by you <span class=\"keyword\">or</span> by a script) since installation.</div><div class=\"line\"> ==&gt; Package distributor has shipped an updated version.</div><div class=\"line\">   What would you like to <span class=\"keyword\">do</span> about it ?  Your options <span class=\"symbol\">are:</span></div><div class=\"line\">    Y <span class=\"keyword\">or</span> I  : install the package maintainer<span class=\"string\">'s version</span></div><div class=\"line\">    N or O  : keep your currently-installed version</div><div class=\"line\">      D     : show the differences between the versions</div><div class=\"line\">      Z     : start a shell to examine the situation</div><div class=\"line\"> The default action is to keep your current version.</div><div class=\"line\">*** nginx.conf (Y/I/N/O/D/Z) [default=N]</div></pre></td></tr></table></figure>\n<ul>\n<li>选择N(默认)即可</li>\n</ul>\n</li>\n</ul>\n<p>最后使用命令<code>nginx -v</code>查看当前的nginx版本如果是<code>nginx version: nginx/1.10.1</code>表示升级成功</p>"},{"title":"android-基本概念","date":"2017-03-24T01:23:22.000Z","_content":"\n\n\nAndroid的一些基本的概念, 名词解释等.....\n\n## 1. 安卓的五种布局\n\n1. 线性布局, 分水平布局和垂直布局, \n2. 相对布局, \n3. 帧布局\n4. 表格布局\n5. 绝对布局\n\n<!-- more -->\n\n## 2. 数据存储的几种方式\n\n1. 保存到文件\n2. SQLite数据库存储\n3. 内容提供者\n4. sharedpreferences保存数据\n5. 网络\n\n## 3. 文件的权限\n\n1. `MODE_PRIVATE`: 私有模式, 只能被应用本身访问,写入内容会覆盖远内容, 如果要追加, 可以使用`MODE_APPEND`, 为默认操作模式\n\n2. `MODE_APPEND`: 该模式下会检测文件是否存在, 存在就往文件里最佳, 否则就穿件新的文件\n\n3. `MODE_WOELD_READABLE`、`MODE_WORLD_WRITEABLE`用来控制其他应用是否有权限读写该文件\n\n   * `MODE_WORLD_READABLE`: 表示当前文件可以被其他应用读取;\n\n   * `MODE_WORLD_WRITEABLE`: 表示当前文件可以被其他应用写入;\n\n   * 如果希望文件被其他应用读写,可以传入:\n\n     ```java\n     openFileOutput(\"文件名\", Context.MODE_WORLD_READABLE + Context.MODE_WORLD_WEITEABLE);\n     ```\n\n* Android 有一套自己的安全模型, 但应用程序(.apk)再安装时系统会分给他一个userid, 当该应用要去访问其他应用资源文件时, 就需要userid匹配. 默认情况下,任何应用穿件的文件 sharedpreferences,数据库,都应该试试有的(位于/data/data/<package name>/files), 其他程序无法访问, 除非再创建的时指定了`Context.MODE_WORLD_READABLE`或者`Context.MODE_WORLD_WRITEABLE`.\n\n## 4. 四大组件\n\n1. Activity: 用于表现功能。\n2. Service: 后台运行服务，不提供界面呈现\n3. BroadcastReceiver: 用于接收广播。\n4. 内容提供商:支持在多个应用中存储和读取数据，相当于`数据库`","source":"_posts/android-基本概念.md","raw":"---\ntitle: android-基本概念\ndate: 2017-03-24 09:23:22\ncategories: Android\ntags: Android\n---\n\n\n\nAndroid的一些基本的概念, 名词解释等.....\n\n## 1. 安卓的五种布局\n\n1. 线性布局, 分水平布局和垂直布局, \n2. 相对布局, \n3. 帧布局\n4. 表格布局\n5. 绝对布局\n\n<!-- more -->\n\n## 2. 数据存储的几种方式\n\n1. 保存到文件\n2. SQLite数据库存储\n3. 内容提供者\n4. sharedpreferences保存数据\n5. 网络\n\n## 3. 文件的权限\n\n1. `MODE_PRIVATE`: 私有模式, 只能被应用本身访问,写入内容会覆盖远内容, 如果要追加, 可以使用`MODE_APPEND`, 为默认操作模式\n\n2. `MODE_APPEND`: 该模式下会检测文件是否存在, 存在就往文件里最佳, 否则就穿件新的文件\n\n3. `MODE_WOELD_READABLE`、`MODE_WORLD_WRITEABLE`用来控制其他应用是否有权限读写该文件\n\n   * `MODE_WORLD_READABLE`: 表示当前文件可以被其他应用读取;\n\n   * `MODE_WORLD_WRITEABLE`: 表示当前文件可以被其他应用写入;\n\n   * 如果希望文件被其他应用读写,可以传入:\n\n     ```java\n     openFileOutput(\"文件名\", Context.MODE_WORLD_READABLE + Context.MODE_WORLD_WEITEABLE);\n     ```\n\n* Android 有一套自己的安全模型, 但应用程序(.apk)再安装时系统会分给他一个userid, 当该应用要去访问其他应用资源文件时, 就需要userid匹配. 默认情况下,任何应用穿件的文件 sharedpreferences,数据库,都应该试试有的(位于/data/data/<package name>/files), 其他程序无法访问, 除非再创建的时指定了`Context.MODE_WORLD_READABLE`或者`Context.MODE_WORLD_WRITEABLE`.\n\n## 4. 四大组件\n\n1. Activity: 用于表现功能。\n2. Service: 后台运行服务，不提供界面呈现\n3. BroadcastReceiver: 用于接收广播。\n4. 内容提供商:支持在多个应用中存储和读取数据，相当于`数据库`","slug":"android-基本概念","published":1,"updated":"2017-04-21T09:10:56.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6686xlu000zxe9ze6lati9s","content":"<p>Android的一些基本的概念, 名词解释等…..</p>\n<h2 id=\"1-安卓的五种布局\"><a href=\"#1-安卓的五种布局\" class=\"headerlink\" title=\"1. 安卓的五种布局\"></a>1. 安卓的五种布局</h2><ol>\n<li>线性布局, 分水平布局和垂直布局, </li>\n<li>相对布局, </li>\n<li>帧布局</li>\n<li>表格布局</li>\n<li>绝对布局</li>\n</ol>\n<a id=\"more\"></a>\n<h2 id=\"2-数据存储的几种方式\"><a href=\"#2-数据存储的几种方式\" class=\"headerlink\" title=\"2. 数据存储的几种方式\"></a>2. 数据存储的几种方式</h2><ol>\n<li>保存到文件</li>\n<li>SQLite数据库存储</li>\n<li>内容提供者</li>\n<li>sharedpreferences保存数据</li>\n<li>网络</li>\n</ol>\n<h2 id=\"3-文件的权限\"><a href=\"#3-文件的权限\" class=\"headerlink\" title=\"3. 文件的权限\"></a>3. 文件的权限</h2><ol>\n<li><p><code>MODE_PRIVATE</code>: 私有模式, 只能被应用本身访问,写入内容会覆盖远内容, 如果要追加, 可以使用<code>MODE_APPEND</code>, 为默认操作模式</p>\n</li>\n<li><p><code>MODE_APPEND</code>: 该模式下会检测文件是否存在, 存在就往文件里最佳, 否则就穿件新的文件</p>\n</li>\n<li><p><code>MODE_WOELD_READABLE</code>、<code>MODE_WORLD_WRITEABLE</code>用来控制其他应用是否有权限读写该文件</p>\n<ul>\n<li><p><code>MODE_WORLD_READABLE</code>: 表示当前文件可以被其他应用读取;</p>\n</li>\n<li><p><code>MODE_WORLD_WRITEABLE</code>: 表示当前文件可以被其他应用写入;</p>\n</li>\n<li><p>如果希望文件被其他应用读写,可以传入:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">openFileOutput(<span class=\"string\">\"文件名\"</span>, Context.MODE_WORLD_READABLE + Context.MODE_WORLD_WEITEABLE);</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ol>\n<ul>\n<li>Android 有一套自己的安全模型, 但应用程序(.apk)再安装时系统会分给他一个userid, 当该应用要去访问其他应用资源文件时, 就需要userid匹配. 默认情况下,任何应用穿件的文件 sharedpreferences,数据库,都应该试试有的(位于/data/data/<package name=\"\">/files), 其他程序无法访问, 除非再创建的时指定了<code>Context.MODE_WORLD_READABLE</code>或者<code>Context.MODE_WORLD_WRITEABLE</code>.</package></li>\n</ul>\n<h2 id=\"4-四大组件\"><a href=\"#4-四大组件\" class=\"headerlink\" title=\"4. 四大组件\"></a>4. 四大组件</h2><ol>\n<li>Activity: 用于表现功能。</li>\n<li>Service: 后台运行服务，不提供界面呈现</li>\n<li>BroadcastReceiver: 用于接收广播。</li>\n<li>内容提供商:支持在多个应用中存储和读取数据，相当于<code>数据库</code></li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>Android的一些基本的概念, 名词解释等…..</p>\n<h2 id=\"1-安卓的五种布局\"><a href=\"#1-安卓的五种布局\" class=\"headerlink\" title=\"1. 安卓的五种布局\"></a>1. 安卓的五种布局</h2><ol>\n<li>线性布局, 分水平布局和垂直布局, </li>\n<li>相对布局, </li>\n<li>帧布局</li>\n<li>表格布局</li>\n<li>绝对布局</li>\n</ol>","more":"<h2 id=\"2-数据存储的几种方式\"><a href=\"#2-数据存储的几种方式\" class=\"headerlink\" title=\"2. 数据存储的几种方式\"></a>2. 数据存储的几种方式</h2><ol>\n<li>保存到文件</li>\n<li>SQLite数据库存储</li>\n<li>内容提供者</li>\n<li>sharedpreferences保存数据</li>\n<li>网络</li>\n</ol>\n<h2 id=\"3-文件的权限\"><a href=\"#3-文件的权限\" class=\"headerlink\" title=\"3. 文件的权限\"></a>3. 文件的权限</h2><ol>\n<li><p><code>MODE_PRIVATE</code>: 私有模式, 只能被应用本身访问,写入内容会覆盖远内容, 如果要追加, 可以使用<code>MODE_APPEND</code>, 为默认操作模式</p>\n</li>\n<li><p><code>MODE_APPEND</code>: 该模式下会检测文件是否存在, 存在就往文件里最佳, 否则就穿件新的文件</p>\n</li>\n<li><p><code>MODE_WOELD_READABLE</code>、<code>MODE_WORLD_WRITEABLE</code>用来控制其他应用是否有权限读写该文件</p>\n<ul>\n<li><p><code>MODE_WORLD_READABLE</code>: 表示当前文件可以被其他应用读取;</p>\n</li>\n<li><p><code>MODE_WORLD_WRITEABLE</code>: 表示当前文件可以被其他应用写入;</p>\n</li>\n<li><p>如果希望文件被其他应用读写,可以传入:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">openFileOutput(<span class=\"string\">\"文件名\"</span>, Context.MODE_WORLD_READABLE + Context.MODE_WORLD_WEITEABLE);</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ol>\n<ul>\n<li>Android 有一套自己的安全模型, 但应用程序(.apk)再安装时系统会分给他一个userid, 当该应用要去访问其他应用资源文件时, 就需要userid匹配. 默认情况下,任何应用穿件的文件 sharedpreferences,数据库,都应该试试有的(位于/data/data/<package name=\"\">/files), 其他程序无法访问, 除非再创建的时指定了<code>Context.MODE_WORLD_READABLE</code>或者<code>Context.MODE_WORLD_WRITEABLE</code>.</package></li>\n</ul>\n<h2 id=\"4-四大组件\"><a href=\"#4-四大组件\" class=\"headerlink\" title=\"4. 四大组件\"></a>4. 四大组件</h2><ol>\n<li>Activity: 用于表现功能。</li>\n<li>Service: 后台运行服务，不提供界面呈现</li>\n<li>BroadcastReceiver: 用于接收广播。</li>\n<li>内容提供商:支持在多个应用中存储和读取数据，相当于<code>数据库</code></li>\n</ol>"},{"title":"const,static,extern简介","date":"2016-03-26T11:30:15.000Z","_content":"\n## const与宏的区别(面试题):\n1. `const`简介:之前常用的字符串常量,一般是抽成宏,但是苹果不推荐我们抽成宏,推荐我们使用const常量.  \n   主要是因为以下四点:\n   * `编译时刻`:**宏**是预编译,**const**是编译阶段.\n      * `编译检查`:**宏**不做检查,不会报编译错误,只是替换,**const**会编译检查,会报编译错误.\n      * `宏的好处`:宏能定义一些函数,方法,const不能.\n      * `宏的坏处`:使用大量红,容易造成编译时间久,每次都需要重新替换.\n\n<!-- more -->\n　　**注意:**很多blog都说使用宏会消耗很多内存,但我这验证并不会生成很多内存,宏定义的是常量,常量都放在常量区,只会产生一份内存.\n​    \n## const\n1. **const作用**:const的作用是用来限制类型的.\n* const仅仅用来修饰右边的变量(基本数据类型p,指针变量*p);\n* 被const修饰的变量是只读的.\n2. const基本使用\n\n ```objc\n - (void)viewDidLoad {\n    [super viewDidLoad];\n    int a = 1;\n    a = 20;\n    const int b = 20; // b:只读变量\n    int const b = 20; // b:只读变量\n    b = 1;  // 不允许修改值\n    \n    // const:修饰指针变量*p，带*的变量，就是指针变量.\n    // 定义一个指向int类型的指针变量，指向a的地址\n    int *p = &a;\n    int c = 10;\n    p = &c;// 允许修改p指向的地址，\n    *p = 20;  // 允许修改p访问内存空间的值\n    \n    // 两种方式一样,const修饰指针变量访问的内存空间，修饰的是右边*p1，\n    const int *p1; // *p1：常量 p1:变量\n    int const *p1; // *p1：常量 p1:变量\n\n    // const修饰指针变量p1\n    int * const p1; // *p1:变量 p1:常量\n\n    // 两种方式一样,第一个const修饰*p1 第二个const修饰 p1\n    const int * const p1; // *p1：常量 p1：常量\n    int const * const p1;  // *p1：常量 p1：常量\n }\n ```\n\n3. const开发中的使用场景\n* 当一个方法参数只读\n* 定义只读全局变量\n\n ```objc\n    // 定义只读全局常量\n    NSString * const str  = @\"123\";\n    // 当一个方法的参数，只读.\n    - (void)test:(NSString * const)name;\n    // 指针只读,不能通过指针修改值\n    - (void)test1:(int const *)a;\n    // 基本数据类型只读\n    - (void)test2:(int const)a;\n ```\n\n## static和extern的简单使用\n1. **static作用**\n* 修饰局部变量:\n     1. 延长局部变量的什么周期:程序结束才会销毁\n     2. 局部变量只会生成一份内存,只会初始化一次.\n* 修饰全局变量\n     1. 只能在本文件中访问,修改全局变量的作用域,生命周期不会改.\n2. **extern作用**\n* 只是用来获取全局变量(包括全局静态变量)的值, 不能用于定义变量.\n3. **entern原理**\n* 现在当前文件查找有没有全局变量,没有找到,才会其他文件查找.\n4. 代码演示\n ```objc\n    int a = 20;// 全局变量：只有一份内存，所有文件共享，与extern联合使用。\n    static int age = 20;// static修饰全局变量\n\n    - (void)test\n    {\n         // static修饰局部变量\n        static int age = 0;\n        age++;\n        NSLog(@\"%d\",age);\n    }\n\n    - (void)viewDidLoad {\n        [super viewDidLoad];\n        [self test];\n\n        extern int age;\n        NSLog(@\"%d\",age);\n    }\n ```\n\n## static与const联合使用\n1. **static与const作用:**声明一个只读的静态变量\n2. **开发场景:**在`一个文件中`经常使用的字符串常量,可以使用static与const组合.\n* 开发中常用static修饰全局变量,只改变作用域\n* 为什么要改变全局变量作用域? 防止重复声明全局变量。\n* 开发中声明的全局变量，有些不希望外界改动，只允许读取。比如一个基本数据类型不希望别人改动\n ```objc\n // 声明一个静态的全局只读常量\n static const int a = 20;\n // 开发中经常拿到key修改值，因此用const修饰key,表示key只读，不允许修改。\n static  NSString * const key = @\"name\";\n // 如果 const修饰 *key1,表示*key1只读，key1还是能改变。\n static  NSString const *key1 = @\"name\";\n ```\n\n## extern与const联合使用\n1. 开发使用场景:\n* 在**多个文件中**经常使用的同一个字符串常量,可以使用extern与const组合\n2. 原因:\n* **static与const组合**:在每个文件中都需要定义一份静态全局变量.\n* **entern与const组合**:只需定义一份全局变量,多个文件共享.\n3. 示例代码\n ```objc\n // .h文件中\n extern NSString * const nameKey = @\"name\";\n //.m文件中\n NSString * const nameKey = @\"name\";\n ```\n\n\n","source":"_posts/const-static-extern简介.md","raw":"---\ntitle: 'const,static,extern简介'\ndate: 2016-03-26 19:30:15\ncategories: iOS\ntags: Objective-C\n---\n\n## const与宏的区别(面试题):\n1. `const`简介:之前常用的字符串常量,一般是抽成宏,但是苹果不推荐我们抽成宏,推荐我们使用const常量.  \n   主要是因为以下四点:\n   * `编译时刻`:**宏**是预编译,**const**是编译阶段.\n      * `编译检查`:**宏**不做检查,不会报编译错误,只是替换,**const**会编译检查,会报编译错误.\n      * `宏的好处`:宏能定义一些函数,方法,const不能.\n      * `宏的坏处`:使用大量红,容易造成编译时间久,每次都需要重新替换.\n\n<!-- more -->\n　　**注意:**很多blog都说使用宏会消耗很多内存,但我这验证并不会生成很多内存,宏定义的是常量,常量都放在常量区,只会产生一份内存.\n​    \n## const\n1. **const作用**:const的作用是用来限制类型的.\n* const仅仅用来修饰右边的变量(基本数据类型p,指针变量*p);\n* 被const修饰的变量是只读的.\n2. const基本使用\n\n ```objc\n - (void)viewDidLoad {\n    [super viewDidLoad];\n    int a = 1;\n    a = 20;\n    const int b = 20; // b:只读变量\n    int const b = 20; // b:只读变量\n    b = 1;  // 不允许修改值\n    \n    // const:修饰指针变量*p，带*的变量，就是指针变量.\n    // 定义一个指向int类型的指针变量，指向a的地址\n    int *p = &a;\n    int c = 10;\n    p = &c;// 允许修改p指向的地址，\n    *p = 20;  // 允许修改p访问内存空间的值\n    \n    // 两种方式一样,const修饰指针变量访问的内存空间，修饰的是右边*p1，\n    const int *p1; // *p1：常量 p1:变量\n    int const *p1; // *p1：常量 p1:变量\n\n    // const修饰指针变量p1\n    int * const p1; // *p1:变量 p1:常量\n\n    // 两种方式一样,第一个const修饰*p1 第二个const修饰 p1\n    const int * const p1; // *p1：常量 p1：常量\n    int const * const p1;  // *p1：常量 p1：常量\n }\n ```\n\n3. const开发中的使用场景\n* 当一个方法参数只读\n* 定义只读全局变量\n\n ```objc\n    // 定义只读全局常量\n    NSString * const str  = @\"123\";\n    // 当一个方法的参数，只读.\n    - (void)test:(NSString * const)name;\n    // 指针只读,不能通过指针修改值\n    - (void)test1:(int const *)a;\n    // 基本数据类型只读\n    - (void)test2:(int const)a;\n ```\n\n## static和extern的简单使用\n1. **static作用**\n* 修饰局部变量:\n     1. 延长局部变量的什么周期:程序结束才会销毁\n     2. 局部变量只会生成一份内存,只会初始化一次.\n* 修饰全局变量\n     1. 只能在本文件中访问,修改全局变量的作用域,生命周期不会改.\n2. **extern作用**\n* 只是用来获取全局变量(包括全局静态变量)的值, 不能用于定义变量.\n3. **entern原理**\n* 现在当前文件查找有没有全局变量,没有找到,才会其他文件查找.\n4. 代码演示\n ```objc\n    int a = 20;// 全局变量：只有一份内存，所有文件共享，与extern联合使用。\n    static int age = 20;// static修饰全局变量\n\n    - (void)test\n    {\n         // static修饰局部变量\n        static int age = 0;\n        age++;\n        NSLog(@\"%d\",age);\n    }\n\n    - (void)viewDidLoad {\n        [super viewDidLoad];\n        [self test];\n\n        extern int age;\n        NSLog(@\"%d\",age);\n    }\n ```\n\n## static与const联合使用\n1. **static与const作用:**声明一个只读的静态变量\n2. **开发场景:**在`一个文件中`经常使用的字符串常量,可以使用static与const组合.\n* 开发中常用static修饰全局变量,只改变作用域\n* 为什么要改变全局变量作用域? 防止重复声明全局变量。\n* 开发中声明的全局变量，有些不希望外界改动，只允许读取。比如一个基本数据类型不希望别人改动\n ```objc\n // 声明一个静态的全局只读常量\n static const int a = 20;\n // 开发中经常拿到key修改值，因此用const修饰key,表示key只读，不允许修改。\n static  NSString * const key = @\"name\";\n // 如果 const修饰 *key1,表示*key1只读，key1还是能改变。\n static  NSString const *key1 = @\"name\";\n ```\n\n## extern与const联合使用\n1. 开发使用场景:\n* 在**多个文件中**经常使用的同一个字符串常量,可以使用extern与const组合\n2. 原因:\n* **static与const组合**:在每个文件中都需要定义一份静态全局变量.\n* **entern与const组合**:只需定义一份全局变量,多个文件共享.\n3. 示例代码\n ```objc\n // .h文件中\n extern NSString * const nameKey = @\"name\";\n //.m文件中\n NSString * const nameKey = @\"name\";\n ```\n\n\n","slug":"const-static-extern简介","published":1,"updated":"2017-04-28T08:42:01.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6686xlx0011xe9zhc0mbycx","content":"<h2 id=\"const与宏的区别-面试题\"><a href=\"#const与宏的区别-面试题\" class=\"headerlink\" title=\"const与宏的区别(面试题):\"></a>const与宏的区别(面试题):</h2><ol>\n<li><code>const</code>简介:之前常用的字符串常量,一般是抽成宏,但是苹果不推荐我们抽成宏,推荐我们使用const常量.<br>主要是因为以下四点:<ul>\n<li><code>编译时刻</code>:<strong>宏</strong>是预编译,<strong>const</strong>是编译阶段.<ul>\n<li><code>编译检查</code>:<strong>宏</strong>不做检查,不会报编译错误,只是替换,<strong>const</strong>会编译检查,会报编译错误.</li>\n<li><code>宏的好处</code>:宏能定义一些函数,方法,const不能.</li>\n<li><code>宏的坏处</code>:使用大量红,容易造成编译时间久,每次都需要重新替换.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<a id=\"more\"></a>\n<p>　　<strong>注意:</strong>很多blog都说使用宏会消耗很多内存,但我这验证并不会生成很多内存,宏定义的是常量,常量都放在常量区,只会产生一份内存.<br>​    </p>\n<h2 id=\"const\"><a href=\"#const\" class=\"headerlink\" title=\"const\"></a>const</h2><ol>\n<li><strong>const作用</strong>:const的作用是用来限制类型的.</li>\n</ol>\n<ul>\n<li>const仅仅用来修饰右边的变量(基本数据类型p,指针变量*p);</li>\n<li>被const修饰的变量是只读的.</li>\n</ul>\n<ol>\n<li><p>const基本使用</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad &#123;</div><div class=\"line\">   [<span class=\"keyword\">super</span> viewDidLoad];</div><div class=\"line\">   <span class=\"keyword\">int</span> a = <span class=\"number\">1</span>;</div><div class=\"line\">   a = <span class=\"number\">20</span>;</div><div class=\"line\">   <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> b = <span class=\"number\">20</span>; <span class=\"comment\">// b:只读变量</span></div><div class=\"line\">   <span class=\"keyword\">int</span> <span class=\"keyword\">const</span> b = <span class=\"number\">20</span>; <span class=\"comment\">// b:只读变量</span></div><div class=\"line\">   b = <span class=\"number\">1</span>;  <span class=\"comment\">// 不允许修改值</span></div><div class=\"line\">   </div><div class=\"line\">   <span class=\"comment\">// const:修饰指针变量*p，带*的变量，就是指针变量.</span></div><div class=\"line\">   <span class=\"comment\">// 定义一个指向int类型的指针变量，指向a的地址</span></div><div class=\"line\">   <span class=\"keyword\">int</span> *p = &amp;a;</div><div class=\"line\">   <span class=\"keyword\">int</span> c = <span class=\"number\">10</span>;</div><div class=\"line\">   p = &amp;c;<span class=\"comment\">// 允许修改p指向的地址，</span></div><div class=\"line\">   *p = <span class=\"number\">20</span>;  <span class=\"comment\">// 允许修改p访问内存空间的值</span></div><div class=\"line\">   </div><div class=\"line\">   <span class=\"comment\">// 两种方式一样,const修饰指针变量访问的内存空间，修饰的是右边*p1，</span></div><div class=\"line\">   <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> *p1; <span class=\"comment\">// *p1：常量 p1:变量</span></div><div class=\"line\">   <span class=\"keyword\">int</span> <span class=\"keyword\">const</span> *p1; <span class=\"comment\">// *p1：常量 p1:变量</span></div><div class=\"line\"></div><div class=\"line\">   <span class=\"comment\">// const修饰指针变量p1</span></div><div class=\"line\">   <span class=\"keyword\">int</span> * <span class=\"keyword\">const</span> p1; <span class=\"comment\">// *p1:变量 p1:常量</span></div><div class=\"line\"></div><div class=\"line\">   <span class=\"comment\">// 两种方式一样,第一个const修饰*p1 第二个const修饰 p1</span></div><div class=\"line\">   <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> * <span class=\"keyword\">const</span> p1; <span class=\"comment\">// *p1：常量 p1：常量</span></div><div class=\"line\">   <span class=\"keyword\">int</span> <span class=\"keyword\">const</span> * <span class=\"keyword\">const</span> p1;  <span class=\"comment\">// *p1：常量 p1：常量</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>const开发中的使用场景</p>\n</li>\n</ol>\n<ul>\n<li>当一个方法参数只读</li>\n<li><p>定义只读全局变量</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 定义只读全局常量</span></div><div class=\"line\"><span class=\"built_in\">NSString</span> * <span class=\"keyword\">const</span> str  = <span class=\"string\">@\"123\"</span>;</div><div class=\"line\"><span class=\"comment\">// 当一个方法的参数，只读.</span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)test:(<span class=\"built_in\">NSString</span> * <span class=\"keyword\">const</span>)name;</div><div class=\"line\"><span class=\"comment\">// 指针只读,不能通过指针修改值</span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)test1:(<span class=\"keyword\">int</span> <span class=\"keyword\">const</span> *)a;</div><div class=\"line\"><span class=\"comment\">// 基本数据类型只读</span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)test2:(<span class=\"keyword\">int</span> <span class=\"keyword\">const</span>)a;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"static和extern的简单使用\"><a href=\"#static和extern的简单使用\" class=\"headerlink\" title=\"static和extern的简单使用\"></a>static和extern的简单使用</h2><ol>\n<li><strong>static作用</strong></li>\n</ol>\n<ul>\n<li>修饰局部变量:<ol>\n<li>延长局部变量的什么周期:程序结束才会销毁</li>\n<li>局部变量只会生成一份内存,只会初始化一次.</li>\n</ol>\n</li>\n<li>修饰全局变量<ol>\n<li>只能在本文件中访问,修改全局变量的作用域,生命周期不会改.</li>\n</ol>\n</li>\n</ul>\n<ol>\n<li><strong>extern作用</strong></li>\n</ol>\n<ul>\n<li>只是用来获取全局变量(包括全局静态变量)的值, 不能用于定义变量.</li>\n</ul>\n<ol>\n<li><strong>entern原理</strong></li>\n</ol>\n<ul>\n<li>现在当前文件查找有没有全局变量,没有找到,才会其他文件查找.</li>\n</ul>\n<ol>\n<li>代码演示<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> a = <span class=\"number\">20</span>;<span class=\"comment\">// 全局变量：只有一份内存，所有文件共享，与extern联合使用。</span></div><div class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> age = <span class=\"number\">20</span>;<span class=\"comment\">// static修饰全局变量</span></div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)test</div><div class=\"line\">&#123;</div><div class=\"line\">     <span class=\"comment\">// static修饰局部变量</span></div><div class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> age = <span class=\"number\">0</span>;</div><div class=\"line\">    age++;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%d\"</span>,age);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad &#123;</div><div class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</div><div class=\"line\">    [<span class=\"keyword\">self</span> test];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">extern</span> <span class=\"keyword\">int</span> age;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%d\"</span>,age);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"static与const联合使用\"><a href=\"#static与const联合使用\" class=\"headerlink\" title=\"static与const联合使用\"></a>static与const联合使用</h2><ol>\n<li><strong>static与const作用:</strong>声明一个只读的静态变量</li>\n<li><strong>开发场景:</strong>在<code>一个文件中</code>经常使用的字符串常量,可以使用static与const组合.</li>\n</ol>\n<ul>\n<li>开发中常用static修饰全局变量,只改变作用域</li>\n<li>为什么要改变全局变量作用域? 防止重复声明全局变量。</li>\n<li>开发中声明的全局变量，有些不希望外界改动，只允许读取。比如一个基本数据类型不希望别人改动<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 声明一个静态的全局只读常量</span></div><div class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> a = <span class=\"number\">20</span>;</div><div class=\"line\"><span class=\"comment\">// 开发中经常拿到key修改值，因此用const修饰key,表示key只读，不允许修改。</span></div><div class=\"line\"><span class=\"keyword\">static</span>  <span class=\"built_in\">NSString</span> * <span class=\"keyword\">const</span> key = <span class=\"string\">@\"name\"</span>;</div><div class=\"line\"><span class=\"comment\">// 如果 const修饰 *key1,表示*key1只读，key1还是能改变。</span></div><div class=\"line\"><span class=\"keyword\">static</span>  <span class=\"built_in\">NSString</span> <span class=\"keyword\">const</span> *key1 = <span class=\"string\">@\"name\"</span>;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"extern与const联合使用\"><a href=\"#extern与const联合使用\" class=\"headerlink\" title=\"extern与const联合使用\"></a>extern与const联合使用</h2><ol>\n<li>开发使用场景:</li>\n</ol>\n<ul>\n<li>在<strong>多个文件中</strong>经常使用的同一个字符串常量,可以使用extern与const组合</li>\n</ul>\n<ol>\n<li>原因:</li>\n</ol>\n<ul>\n<li><strong>static与const组合</strong>:在每个文件中都需要定义一份静态全局变量.</li>\n<li><strong>entern与const组合</strong>:只需定义一份全局变量,多个文件共享.</li>\n</ul>\n<ol>\n<li>示例代码<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// .h文件中</span></div><div class=\"line\"><span class=\"keyword\">extern</span> <span class=\"built_in\">NSString</span> * <span class=\"keyword\">const</span> nameKey = <span class=\"string\">@\"name\"</span>;</div><div class=\"line\"><span class=\"comment\">//.m文件中</span></div><div class=\"line\"><span class=\"built_in\">NSString</span> * <span class=\"keyword\">const</span> nameKey = <span class=\"string\">@\"name\"</span>;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"<h2 id=\"const与宏的区别-面试题\"><a href=\"#const与宏的区别-面试题\" class=\"headerlink\" title=\"const与宏的区别(面试题):\"></a>const与宏的区别(面试题):</h2><ol>\n<li><code>const</code>简介:之前常用的字符串常量,一般是抽成宏,但是苹果不推荐我们抽成宏,推荐我们使用const常量.<br>主要是因为以下四点:<ul>\n<li><code>编译时刻</code>:<strong>宏</strong>是预编译,<strong>const</strong>是编译阶段.<ul>\n<li><code>编译检查</code>:<strong>宏</strong>不做检查,不会报编译错误,只是替换,<strong>const</strong>会编译检查,会报编译错误.</li>\n<li><code>宏的好处</code>:宏能定义一些函数,方法,const不能.</li>\n<li><code>宏的坏处</code>:使用大量红,容易造成编译时间久,每次都需要重新替换.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>","more":"<p>　　<strong>注意:</strong>很多blog都说使用宏会消耗很多内存,但我这验证并不会生成很多内存,宏定义的是常量,常量都放在常量区,只会产生一份内存.<br>​    </p>\n<h2 id=\"const\"><a href=\"#const\" class=\"headerlink\" title=\"const\"></a>const</h2><ol>\n<li><strong>const作用</strong>:const的作用是用来限制类型的.</li>\n</ol>\n<ul>\n<li>const仅仅用来修饰右边的变量(基本数据类型p,指针变量*p);</li>\n<li>被const修饰的变量是只读的.</li>\n</ul>\n<ol>\n<li><p>const基本使用</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad &#123;</div><div class=\"line\">   [<span class=\"keyword\">super</span> viewDidLoad];</div><div class=\"line\">   <span class=\"keyword\">int</span> a = <span class=\"number\">1</span>;</div><div class=\"line\">   a = <span class=\"number\">20</span>;</div><div class=\"line\">   <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> b = <span class=\"number\">20</span>; <span class=\"comment\">// b:只读变量</span></div><div class=\"line\">   <span class=\"keyword\">int</span> <span class=\"keyword\">const</span> b = <span class=\"number\">20</span>; <span class=\"comment\">// b:只读变量</span></div><div class=\"line\">   b = <span class=\"number\">1</span>;  <span class=\"comment\">// 不允许修改值</span></div><div class=\"line\">   </div><div class=\"line\">   <span class=\"comment\">// const:修饰指针变量*p，带*的变量，就是指针变量.</span></div><div class=\"line\">   <span class=\"comment\">// 定义一个指向int类型的指针变量，指向a的地址</span></div><div class=\"line\">   <span class=\"keyword\">int</span> *p = &amp;a;</div><div class=\"line\">   <span class=\"keyword\">int</span> c = <span class=\"number\">10</span>;</div><div class=\"line\">   p = &amp;c;<span class=\"comment\">// 允许修改p指向的地址，</span></div><div class=\"line\">   *p = <span class=\"number\">20</span>;  <span class=\"comment\">// 允许修改p访问内存空间的值</span></div><div class=\"line\">   </div><div class=\"line\">   <span class=\"comment\">// 两种方式一样,const修饰指针变量访问的内存空间，修饰的是右边*p1，</span></div><div class=\"line\">   <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> *p1; <span class=\"comment\">// *p1：常量 p1:变量</span></div><div class=\"line\">   <span class=\"keyword\">int</span> <span class=\"keyword\">const</span> *p1; <span class=\"comment\">// *p1：常量 p1:变量</span></div><div class=\"line\"></div><div class=\"line\">   <span class=\"comment\">// const修饰指针变量p1</span></div><div class=\"line\">   <span class=\"keyword\">int</span> * <span class=\"keyword\">const</span> p1; <span class=\"comment\">// *p1:变量 p1:常量</span></div><div class=\"line\"></div><div class=\"line\">   <span class=\"comment\">// 两种方式一样,第一个const修饰*p1 第二个const修饰 p1</span></div><div class=\"line\">   <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> * <span class=\"keyword\">const</span> p1; <span class=\"comment\">// *p1：常量 p1：常量</span></div><div class=\"line\">   <span class=\"keyword\">int</span> <span class=\"keyword\">const</span> * <span class=\"keyword\">const</span> p1;  <span class=\"comment\">// *p1：常量 p1：常量</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>const开发中的使用场景</p>\n</li>\n</ol>\n<ul>\n<li>当一个方法参数只读</li>\n<li><p>定义只读全局变量</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 定义只读全局常量</span></div><div class=\"line\"><span class=\"built_in\">NSString</span> * <span class=\"keyword\">const</span> str  = <span class=\"string\">@\"123\"</span>;</div><div class=\"line\"><span class=\"comment\">// 当一个方法的参数，只读.</span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)test:(<span class=\"built_in\">NSString</span> * <span class=\"keyword\">const</span>)name;</div><div class=\"line\"><span class=\"comment\">// 指针只读,不能通过指针修改值</span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)test1:(<span class=\"keyword\">int</span> <span class=\"keyword\">const</span> *)a;</div><div class=\"line\"><span class=\"comment\">// 基本数据类型只读</span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)test2:(<span class=\"keyword\">int</span> <span class=\"keyword\">const</span>)a;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"static和extern的简单使用\"><a href=\"#static和extern的简单使用\" class=\"headerlink\" title=\"static和extern的简单使用\"></a>static和extern的简单使用</h2><ol>\n<li><strong>static作用</strong></li>\n</ol>\n<ul>\n<li>修饰局部变量:<ol>\n<li>延长局部变量的什么周期:程序结束才会销毁</li>\n<li>局部变量只会生成一份内存,只会初始化一次.</li>\n</ol>\n</li>\n<li>修饰全局变量<ol>\n<li>只能在本文件中访问,修改全局变量的作用域,生命周期不会改.</li>\n</ol>\n</li>\n</ul>\n<ol>\n<li><strong>extern作用</strong></li>\n</ol>\n<ul>\n<li>只是用来获取全局变量(包括全局静态变量)的值, 不能用于定义变量.</li>\n</ul>\n<ol>\n<li><strong>entern原理</strong></li>\n</ol>\n<ul>\n<li>现在当前文件查找有没有全局变量,没有找到,才会其他文件查找.</li>\n</ul>\n<ol>\n<li>代码演示<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> a = <span class=\"number\">20</span>;<span class=\"comment\">// 全局变量：只有一份内存，所有文件共享，与extern联合使用。</span></div><div class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> age = <span class=\"number\">20</span>;<span class=\"comment\">// static修饰全局变量</span></div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)test</div><div class=\"line\">&#123;</div><div class=\"line\">     <span class=\"comment\">// static修饰局部变量</span></div><div class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> age = <span class=\"number\">0</span>;</div><div class=\"line\">    age++;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%d\"</span>,age);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad &#123;</div><div class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</div><div class=\"line\">    [<span class=\"keyword\">self</span> test];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">extern</span> <span class=\"keyword\">int</span> age;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%d\"</span>,age);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"static与const联合使用\"><a href=\"#static与const联合使用\" class=\"headerlink\" title=\"static与const联合使用\"></a>static与const联合使用</h2><ol>\n<li><strong>static与const作用:</strong>声明一个只读的静态变量</li>\n<li><strong>开发场景:</strong>在<code>一个文件中</code>经常使用的字符串常量,可以使用static与const组合.</li>\n</ol>\n<ul>\n<li>开发中常用static修饰全局变量,只改变作用域</li>\n<li>为什么要改变全局变量作用域? 防止重复声明全局变量。</li>\n<li>开发中声明的全局变量，有些不希望外界改动，只允许读取。比如一个基本数据类型不希望别人改动<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 声明一个静态的全局只读常量</span></div><div class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> a = <span class=\"number\">20</span>;</div><div class=\"line\"><span class=\"comment\">// 开发中经常拿到key修改值，因此用const修饰key,表示key只读，不允许修改。</span></div><div class=\"line\"><span class=\"keyword\">static</span>  <span class=\"built_in\">NSString</span> * <span class=\"keyword\">const</span> key = <span class=\"string\">@\"name\"</span>;</div><div class=\"line\"><span class=\"comment\">// 如果 const修饰 *key1,表示*key1只读，key1还是能改变。</span></div><div class=\"line\"><span class=\"keyword\">static</span>  <span class=\"built_in\">NSString</span> <span class=\"keyword\">const</span> *key1 = <span class=\"string\">@\"name\"</span>;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"extern与const联合使用\"><a href=\"#extern与const联合使用\" class=\"headerlink\" title=\"extern与const联合使用\"></a>extern与const联合使用</h2><ol>\n<li>开发使用场景:</li>\n</ol>\n<ul>\n<li>在<strong>多个文件中</strong>经常使用的同一个字符串常量,可以使用extern与const组合</li>\n</ul>\n<ol>\n<li>原因:</li>\n</ol>\n<ul>\n<li><strong>static与const组合</strong>:在每个文件中都需要定义一份静态全局变量.</li>\n<li><strong>entern与const组合</strong>:只需定义一份全局变量,多个文件共享.</li>\n</ul>\n<ol>\n<li>示例代码<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// .h文件中</span></div><div class=\"line\"><span class=\"keyword\">extern</span> <span class=\"built_in\">NSString</span> * <span class=\"keyword\">const</span> nameKey = <span class=\"string\">@\"name\"</span>;</div><div class=\"line\"><span class=\"comment\">//.m文件中</span></div><div class=\"line\"><span class=\"built_in\">NSString</span> * <span class=\"keyword\">const</span> nameKey = <span class=\"string\">@\"name\"</span>;</div></pre></td></tr></table></figure>\n</li>\n</ol>"},{"title":"https使用网易音乐外链播放器无法播放","date":"2016-06-02T17:05:58.000Z","Tags":"教程","_content":"\n\n### 问题描述\n`https`协议的网站嵌入网易云音乐外链播放器，无法播放音乐。\n\n<!--more-->\n\n### 分析\n无法播放是因为网易云音乐外链播放器的`html`代码你的音乐资源链接默认是`http`协议的，而访问使用`https`协议的网站，浏览器会自动屏蔽掉`http`的资源。\n\n### 解决方法\n把网易云音乐外链播放器的`html`代码里的`http`改为`https`就可以解决\n\n### 示例\n* 这是网易云音乐默认生成的连接\n\n```html\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"http://music.163.com/outchain/player?type=2&id=16232697&auto=1&height=66\"></iframe>\n```\n\n* 只要将`http`给为`https`即可\n\n```html\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"https://music.163.com/outchain/player?type=2&id=16232697&auto=1&height=66\"></iframe>\n```\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"https://music.163.com/outchain/player?type=2&id=16232697&auto=1&height=66\"></iframe>\n​    \n\n\n\n","source":"_posts/https使用网易音乐外链播放器无法播放.md","raw":"---\ntitle: https使用网易音乐外链播放器无法播放\ndate: 2016-06-03 01:05:58\ncategories: 教程\nTags: 教程\n---\n\n\n### 问题描述\n`https`协议的网站嵌入网易云音乐外链播放器，无法播放音乐。\n\n<!--more-->\n\n### 分析\n无法播放是因为网易云音乐外链播放器的`html`代码你的音乐资源链接默认是`http`协议的，而访问使用`https`协议的网站，浏览器会自动屏蔽掉`http`的资源。\n\n### 解决方法\n把网易云音乐外链播放器的`html`代码里的`http`改为`https`就可以解决\n\n### 示例\n* 这是网易云音乐默认生成的连接\n\n```html\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"http://music.163.com/outchain/player?type=2&id=16232697&auto=1&height=66\"></iframe>\n```\n\n* 只要将`http`给为`https`即可\n\n```html\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"https://music.163.com/outchain/player?type=2&id=16232697&auto=1&height=66\"></iframe>\n```\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"https://music.163.com/outchain/player?type=2&id=16232697&auto=1&height=66\"></iframe>\n​    \n\n\n\n","slug":"https使用网易音乐外链播放器无法播放","published":1,"updated":"2017-04-28T08:37:52.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6686xlz0016xe9z53jjjpj4","content":"<h3 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h3><p><code>https</code>协议的网站嵌入网易云音乐外链播放器，无法播放音乐。</p>\n<a id=\"more\"></a>\n<h3 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h3><p>无法播放是因为网易云音乐外链播放器的<code>html</code>代码你的音乐资源链接默认是<code>http</code>协议的，而访问使用<code>https</code>协议的网站，浏览器会自动屏蔽掉<code>http</code>的资源。</p>\n<h3 id=\"解决方法\"><a href=\"#解决方法\" class=\"headerlink\" title=\"解决方法\"></a>解决方法</h3><p>把网易云音乐外链播放器的<code>html</code>代码里的<code>http</code>改为<code>https</code>就可以解决</p>\n<h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><ul>\n<li>这是网易云音乐默认生成的连接</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">iframe</span> <span class=\"attr\">frameborder</span>=<span class=\"string\">\"no\"</span> <span class=\"attr\">border</span>=<span class=\"string\">\"0\"</span> <span class=\"attr\">marginwidth</span>=<span class=\"string\">\"0\"</span> <span class=\"attr\">marginheight</span>=<span class=\"string\">\"0\"</span> <span class=\"attr\">width</span>=<span class=\"string\">330</span> <span class=\"attr\">height</span>=<span class=\"string\">86</span> <span class=\"attr\">src</span>=<span class=\"string\">\"http://music.163.com/outchain/player?type=2&amp;id=16232697&amp;auto=1&amp;height=66\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">iframe</span>&gt;</span></div></pre></td></tr></table></figure>\n<ul>\n<li>只要将<code>http</code>给为<code>https</code>即可</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">iframe</span> <span class=\"attr\">frameborder</span>=<span class=\"string\">\"no\"</span> <span class=\"attr\">border</span>=<span class=\"string\">\"0\"</span> <span class=\"attr\">marginwidth</span>=<span class=\"string\">\"0\"</span> <span class=\"attr\">marginheight</span>=<span class=\"string\">\"0\"</span> <span class=\"attr\">width</span>=<span class=\"string\">330</span> <span class=\"attr\">height</span>=<span class=\"string\">86</span> <span class=\"attr\">src</span>=<span class=\"string\">\"https://music.163.com/outchain/player?type=2&amp;id=16232697&amp;auto=1&amp;height=66\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">iframe</span>&gt;</span></div></pre></td></tr></table></figure>\n<p><iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=\"330\" height=\"86\" src=\"https://music.163.com/outchain/player?type=2&id=16232697&auto=1&height=66\"></iframe><br>​    </p>\n","site":{"data":{}},"excerpt":"<h3 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h3><p><code>https</code>协议的网站嵌入网易云音乐外链播放器，无法播放音乐。</p>","more":"<h3 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h3><p>无法播放是因为网易云音乐外链播放器的<code>html</code>代码你的音乐资源链接默认是<code>http</code>协议的，而访问使用<code>https</code>协议的网站，浏览器会自动屏蔽掉<code>http</code>的资源。</p>\n<h3 id=\"解决方法\"><a href=\"#解决方法\" class=\"headerlink\" title=\"解决方法\"></a>解决方法</h3><p>把网易云音乐外链播放器的<code>html</code>代码里的<code>http</code>改为<code>https</code>就可以解决</p>\n<h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><ul>\n<li>这是网易云音乐默认生成的连接</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">iframe</span> <span class=\"attr\">frameborder</span>=<span class=\"string\">\"no\"</span> <span class=\"attr\">border</span>=<span class=\"string\">\"0\"</span> <span class=\"attr\">marginwidth</span>=<span class=\"string\">\"0\"</span> <span class=\"attr\">marginheight</span>=<span class=\"string\">\"0\"</span> <span class=\"attr\">width</span>=<span class=\"string\">330</span> <span class=\"attr\">height</span>=<span class=\"string\">86</span> <span class=\"attr\">src</span>=<span class=\"string\">\"http://music.163.com/outchain/player?type=2&amp;id=16232697&amp;auto=1&amp;height=66\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">iframe</span>&gt;</span></div></pre></td></tr></table></figure>\n<ul>\n<li>只要将<code>http</code>给为<code>https</code>即可</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">iframe</span> <span class=\"attr\">frameborder</span>=<span class=\"string\">\"no\"</span> <span class=\"attr\">border</span>=<span class=\"string\">\"0\"</span> <span class=\"attr\">marginwidth</span>=<span class=\"string\">\"0\"</span> <span class=\"attr\">marginheight</span>=<span class=\"string\">\"0\"</span> <span class=\"attr\">width</span>=<span class=\"string\">330</span> <span class=\"attr\">height</span>=<span class=\"string\">86</span> <span class=\"attr\">src</span>=<span class=\"string\">\"https://music.163.com/outchain/player?type=2&amp;id=16232697&amp;auto=1&amp;height=66\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">iframe</span>&gt;</span></div></pre></td></tr></table></figure>\n<p><iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=\"330\" height=\"86\" src=\"https://music.163.com/outchain/player?type=2&id=16232697&auto=1&height=66\"></iframe><br>​    </p>"},{"title":"install VPN on your vps","date":"2017-01-16T07:25:07.000Z","_content":"\n### 一、安装环境\n\n1. ubuntu 14.04\n\n### 二、检查ppp/tun环境\n\n```shell\ncat /dev/net/tun\n```\n\n* 必须返回是:`cat: /dev/net/tun: File descriptor in bad state`\n\n```shell\ncat /dev/ppp\n```\n\n* 必须返回是`cat: /dev/ppp: No such device or address`\n\n如果不是, 请联系你的vps提供商\n\n<!-- more -->\n\n### 三、安装脚本\n\n1. 下载脚本:\n\n   ```shell\n   wget --no-check-certificate https://raw.githubusercontent.com/quericy/one-key-ikev2-vpn/master/one-key-ikev2.sh\n   ```\n\n2. 安装\n\n   ```shell\n   chmod +x one-key-ikev2.sh\n   bash one-key-ikev2.sh\n   ```\n\n   这里需要注意的是让你选择vpn类型: **OpenVZ还是Xen、KVM**, 自己可询问vps提供商, 或者通过其他途径, 其他选项 一路回车就可以.\n\n   如图情况表示配置完成, 可根据自身情况修改用户名、密码、密钥等\n\n   ![installed](https://ww2.sinaimg.cn/large/006y8lVagw1fbsi9xr8x7j30w6092adm.jpg)\n\n3. 修改/添加用户\n\n   ```shell\n   vi /usr/local/etc/ipsec.secrets\n   ```\n\n   内容如下:\n\n   ```ruby\n   : RSA server.pem \n   : PSK \"myPSKkey\" #表示贡献密钥\n   : XAUTH \"myXAUTHPass\"\n   myUserName1 %any : EAP \"myUserPass1\" #用户名以及密码\n   myUserName2 %any : EAP \"myUserPass2\" #用户名以及密码\n   ```\n\n### 四、开机启动(ubuntu)\n\n1. ubuntu系统\n\n   ```shell\n   chmod +x /etc/rc.local && echo \"/usr/local/sbin/ipsec start\" >> /etc/rc.local\n   ```\n\n\n2. 打开sysctl文件:\n\n   ```shell\n   vi /etc/sysctl.conf\n   ```\n\n   - 找到 `net.ipv4.ip_forward=1`，删除前面的“#”注释符（按` I键 `进入编辑模式），并保存退出（按` Esc键 `退出编辑模式，然后输入` :wq `保存并退出）。\n\n3. 使用以下指令刷新sysctl：\n\n   ```shell\n   sysctl -p\n   ```\n\n### 五、卸载\n\n```shell\ncd /root/strongswan-5.3.5\nmake uninstall\n```\n\n### 六、其他命令\n\n```shel\nipsec start # 启动pvn\nipsec status #vpn状态\nipsec restart #重启vpn\nipsec stop #停止vpn\n```\n\n\n\n","source":"_posts/install-VPN-on-your-vps.md","raw":"---\ntitle: install VPN on your vps\ndate: 2017-01-16 15:25:07\ncategories: 教程\ntags: [教程 翻墙]\n\n---\n\n### 一、安装环境\n\n1. ubuntu 14.04\n\n### 二、检查ppp/tun环境\n\n```shell\ncat /dev/net/tun\n```\n\n* 必须返回是:`cat: /dev/net/tun: File descriptor in bad state`\n\n```shell\ncat /dev/ppp\n```\n\n* 必须返回是`cat: /dev/ppp: No such device or address`\n\n如果不是, 请联系你的vps提供商\n\n<!-- more -->\n\n### 三、安装脚本\n\n1. 下载脚本:\n\n   ```shell\n   wget --no-check-certificate https://raw.githubusercontent.com/quericy/one-key-ikev2-vpn/master/one-key-ikev2.sh\n   ```\n\n2. 安装\n\n   ```shell\n   chmod +x one-key-ikev2.sh\n   bash one-key-ikev2.sh\n   ```\n\n   这里需要注意的是让你选择vpn类型: **OpenVZ还是Xen、KVM**, 自己可询问vps提供商, 或者通过其他途径, 其他选项 一路回车就可以.\n\n   如图情况表示配置完成, 可根据自身情况修改用户名、密码、密钥等\n\n   ![installed](https://ww2.sinaimg.cn/large/006y8lVagw1fbsi9xr8x7j30w6092adm.jpg)\n\n3. 修改/添加用户\n\n   ```shell\n   vi /usr/local/etc/ipsec.secrets\n   ```\n\n   内容如下:\n\n   ```ruby\n   : RSA server.pem \n   : PSK \"myPSKkey\" #表示贡献密钥\n   : XAUTH \"myXAUTHPass\"\n   myUserName1 %any : EAP \"myUserPass1\" #用户名以及密码\n   myUserName2 %any : EAP \"myUserPass2\" #用户名以及密码\n   ```\n\n### 四、开机启动(ubuntu)\n\n1. ubuntu系统\n\n   ```shell\n   chmod +x /etc/rc.local && echo \"/usr/local/sbin/ipsec start\" >> /etc/rc.local\n   ```\n\n\n2. 打开sysctl文件:\n\n   ```shell\n   vi /etc/sysctl.conf\n   ```\n\n   - 找到 `net.ipv4.ip_forward=1`，删除前面的“#”注释符（按` I键 `进入编辑模式），并保存退出（按` Esc键 `退出编辑模式，然后输入` :wq `保存并退出）。\n\n3. 使用以下指令刷新sysctl：\n\n   ```shell\n   sysctl -p\n   ```\n\n### 五、卸载\n\n```shell\ncd /root/strongswan-5.3.5\nmake uninstall\n```\n\n### 六、其他命令\n\n```shel\nipsec start # 启动pvn\nipsec status #vpn状态\nipsec restart #重启vpn\nipsec stop #停止vpn\n```\n\n\n\n","slug":"install-VPN-on-your-vps","published":1,"updated":"2017-04-28T08:38:54.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6686xm10019xe9zj302ws47","content":"<h3 id=\"一、安装环境\"><a href=\"#一、安装环境\" class=\"headerlink\" title=\"一、安装环境\"></a>一、安装环境</h3><ol>\n<li>ubuntu 14.04</li>\n</ol>\n<h3 id=\"二、检查ppp-tun环境\"><a href=\"#二、检查ppp-tun环境\" class=\"headerlink\" title=\"二、检查ppp/tun环境\"></a>二、检查ppp/tun环境</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">cat /dev/net/tun</div></pre></td></tr></table></figure>\n<ul>\n<li>必须返回是:<code>cat: /dev/net/tun: File descriptor in bad state</code></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">cat /dev/ppp</div></pre></td></tr></table></figure>\n<ul>\n<li>必须返回是<code>cat: /dev/ppp: No such device or address</code></li>\n</ul>\n<p>如果不是, 请联系你的vps提供商</p>\n<a id=\"more\"></a>\n<h3 id=\"三、安装脚本\"><a href=\"#三、安装脚本\" class=\"headerlink\" title=\"三、安装脚本\"></a>三、安装脚本</h3><ol>\n<li><p>下载脚本:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">wget --no-check-certificate https://raw.githubusercontent.com/quericy/one-key-ikev2-vpn/master/one-key-ikev2.sh</div></pre></td></tr></table></figure>\n</li>\n<li><p>安装</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">chmod +x one-key-ikev2.sh</div><div class=\"line\">bash one-key-ikev2.sh</div></pre></td></tr></table></figure>\n<p>这里需要注意的是让你选择vpn类型: <strong>OpenVZ还是Xen、KVM</strong>, 自己可询问vps提供商, 或者通过其他途径, 其他选项 一路回车就可以.</p>\n<p>如图情况表示配置完成, 可根据自身情况修改用户名、密码、密钥等</p>\n<p><img src=\"https://ww2.sinaimg.cn/large/006y8lVagw1fbsi9xr8x7j30w6092adm.jpg\" alt=\"installed\"></p>\n</li>\n<li><p>修改/添加用户</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">vi /usr/local/etc/ipsec.secrets</div></pre></td></tr></table></figure>\n<p>内容如下:</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">: RSA server.pem </div><div class=\"line\">: PSK <span class=\"string\">\"myPSKkey\"</span> <span class=\"comment\">#表示贡献密钥</span></div><div class=\"line\">: XAUTH <span class=\"string\">\"myXAUTHPass\"</span></div><div class=\"line\">myUserName1 %any : EAP <span class=\"string\">\"myUserPass1\"</span> <span class=\"comment\">#用户名以及密码</span></div><div class=\"line\">myUserName2 %any : EAP <span class=\"string\">\"myUserPass2\"</span> <span class=\"comment\">#用户名以及密码</span></div></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"四、开机启动-ubuntu\"><a href=\"#四、开机启动-ubuntu\" class=\"headerlink\" title=\"四、开机启动(ubuntu)\"></a>四、开机启动(ubuntu)</h3><ol>\n<li><p>ubuntu系统</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">chmod +x /etc/rc.local &amp;&amp; echo &quot;/usr/local/sbin/ipsec start&quot; &gt;&gt; /etc/rc.local</div></pre></td></tr></table></figure>\n</li>\n<li><p>打开sysctl文件:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">vi /etc/sysctl.conf</div></pre></td></tr></table></figure>\n<ul>\n<li>找到 <code>net.ipv4.ip_forward=1</code>，删除前面的“#”注释符（按<code>I键</code>进入编辑模式），并保存退出（按<code>Esc键</code>退出编辑模式，然后输入<code>:wq</code>保存并退出）。</li>\n</ul>\n</li>\n<li><p>使用以下指令刷新sysctl：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sysctl -p</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"五、卸载\"><a href=\"#五、卸载\" class=\"headerlink\" title=\"五、卸载\"></a>五、卸载</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">cd /root/strongswan-5.3.5</div><div class=\"line\">make uninstall</div></pre></td></tr></table></figure>\n<h3 id=\"六、其他命令\"><a href=\"#六、其他命令\" class=\"headerlink\" title=\"六、其他命令\"></a>六、其他命令</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">ipsec start # 启动pvn</div><div class=\"line\">ipsec status #vpn状态</div><div class=\"line\">ipsec restart #重启vpn</div><div class=\"line\">ipsec stop #停止vpn</div></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h3 id=\"一、安装环境\"><a href=\"#一、安装环境\" class=\"headerlink\" title=\"一、安装环境\"></a>一、安装环境</h3><ol>\n<li>ubuntu 14.04</li>\n</ol>\n<h3 id=\"二、检查ppp-tun环境\"><a href=\"#二、检查ppp-tun环境\" class=\"headerlink\" title=\"二、检查ppp/tun环境\"></a>二、检查ppp/tun环境</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">cat /dev/net/tun</div></pre></td></tr></table></figure>\n<ul>\n<li>必须返回是:<code>cat: /dev/net/tun: File descriptor in bad state</code></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">cat /dev/ppp</div></pre></td></tr></table></figure>\n<ul>\n<li>必须返回是<code>cat: /dev/ppp: No such device or address</code></li>\n</ul>\n<p>如果不是, 请联系你的vps提供商</p>","more":"<h3 id=\"三、安装脚本\"><a href=\"#三、安装脚本\" class=\"headerlink\" title=\"三、安装脚本\"></a>三、安装脚本</h3><ol>\n<li><p>下载脚本:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">wget --no-check-certificate https://raw.githubusercontent.com/quericy/one-key-ikev2-vpn/master/one-key-ikev2.sh</div></pre></td></tr></table></figure>\n</li>\n<li><p>安装</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">chmod +x one-key-ikev2.sh</div><div class=\"line\">bash one-key-ikev2.sh</div></pre></td></tr></table></figure>\n<p>这里需要注意的是让你选择vpn类型: <strong>OpenVZ还是Xen、KVM</strong>, 自己可询问vps提供商, 或者通过其他途径, 其他选项 一路回车就可以.</p>\n<p>如图情况表示配置完成, 可根据自身情况修改用户名、密码、密钥等</p>\n<p><img src=\"https://ww2.sinaimg.cn/large/006y8lVagw1fbsi9xr8x7j30w6092adm.jpg\" alt=\"installed\"></p>\n</li>\n<li><p>修改/添加用户</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">vi /usr/local/etc/ipsec.secrets</div></pre></td></tr></table></figure>\n<p>内容如下:</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">: RSA server.pem </div><div class=\"line\">: PSK <span class=\"string\">\"myPSKkey\"</span> <span class=\"comment\">#表示贡献密钥</span></div><div class=\"line\">: XAUTH <span class=\"string\">\"myXAUTHPass\"</span></div><div class=\"line\">myUserName1 %any : EAP <span class=\"string\">\"myUserPass1\"</span> <span class=\"comment\">#用户名以及密码</span></div><div class=\"line\">myUserName2 %any : EAP <span class=\"string\">\"myUserPass2\"</span> <span class=\"comment\">#用户名以及密码</span></div></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"四、开机启动-ubuntu\"><a href=\"#四、开机启动-ubuntu\" class=\"headerlink\" title=\"四、开机启动(ubuntu)\"></a>四、开机启动(ubuntu)</h3><ol>\n<li><p>ubuntu系统</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">chmod +x /etc/rc.local &amp;&amp; echo &quot;/usr/local/sbin/ipsec start&quot; &gt;&gt; /etc/rc.local</div></pre></td></tr></table></figure>\n</li>\n<li><p>打开sysctl文件:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">vi /etc/sysctl.conf</div></pre></td></tr></table></figure>\n<ul>\n<li>找到 <code>net.ipv4.ip_forward=1</code>，删除前面的“#”注释符（按<code>I键</code>进入编辑模式），并保存退出（按<code>Esc键</code>退出编辑模式，然后输入<code>:wq</code>保存并退出）。</li>\n</ul>\n</li>\n<li><p>使用以下指令刷新sysctl：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sysctl -p</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"五、卸载\"><a href=\"#五、卸载\" class=\"headerlink\" title=\"五、卸载\"></a>五、卸载</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">cd /root/strongswan-5.3.5</div><div class=\"line\">make uninstall</div></pre></td></tr></table></figure>\n<h3 id=\"六、其他命令\"><a href=\"#六、其他命令\" class=\"headerlink\" title=\"六、其他命令\"></a>六、其他命令</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">ipsec start # 启动pvn</div><div class=\"line\">ipsec status #vpn状态</div><div class=\"line\">ipsec restart #重启vpn</div><div class=\"line\">ipsec stop #停止vpn</div></pre></td></tr></table></figure>"},{"title":"在vps上安装hexo并且使用git更新","date":"2016-12-02T03:28:17.000Z","_content":"\n\n## 一、准备工作\n#### VPS&域名\n请自行购买服务器以及域名.\n\n## 二、搭建过程\n>搭建分为两个部分:一部分在本机(Mac)进行，另一部分则在服务端(VPS)进行，大致需要完成的工作是在本机和服务器各安装一次Hexo和Git，并在服务器上安装Nginx服务器、配置Git Hooks以实现更新.并且全程使用终端命令完成。\n\n<!-- more -->\n\n#### 本地电脑配置\n1. 安装Homebrew\n* `/usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"`\n2. 安装Node.js\n* `brew install node`\n3. 创建网站目录\n* 在任意位置创建一个文件夹，作为网站目录，并通过 cd 命令进入文件夹。\n4. 本地电脑安装hexo\n* `npm install -g hexo-cli`\n* `hexo init`\n* `npm install`\n* `hexo d -fg`\n* `hexo serve` *简洁写法:`hexo s`*\n\n然后访问 http://localhost:4000 如果看到网页表示Hexo配置成功\n\n#### 远程服务器配置(VPS)\n**下文中的`yuxiang.ren(这是我的域名)`,`45.32.249.14(这是我的主机ip)`...请自行替换**\n\n1. 此处为Debian/Ubuntu在root用户下的操作:\n*  执行`ssh root@你的vps地址`进入主机\n* 依次执行以下命令 (安装hexo服务)\n    ​          \n    ```bash\n     $apt-get update && apt-get upgrade -y\n     $apt-get install git-core -y\n     $curl -sL https://deb.nodesource.com/setup | bash\n     $apt-get install nodejs -y\n     $apt-get install nginx -y\n     $cd /etc/nginx/sites-available\n     $rm -rf default\n     $touch yuxiang.ren #根据自己情况替换\n     $vi yuxiang.ren #根据自己情况替换\n    ```\n2. 上面的最后一条命令输入完成后会进入编辑页面,将下面代码复制到里面(通过按i进入编辑模式)。(host监听)\n```ruby\n    server {\n        listen 45.32.249.14:80; #监听80端口\n        server_name yuxiang.ren; # 域名\n        access_log  /var/log/nginx/yuxiang_access.log;\n        error_log   /var/log/nginx/yuxiang_error.log;\n        location ~* ^.+\\.(ico|gif|jpg|jpeg|png)$ {\n                root /var/www/yuxiang.ren/public;\n                access_log   off;\n                expires      1d;\n            }\n        location ~* ^.+\\.(css|js|txt|xml|swf|wav)$ {\n            root /var/www/yuxiang.ren/public;\n            access_log   off;\n            expires      10m;\n        }\n        location / {\n            root /var/www/yuxiang.ren/public;\n            if (-f $request_filename) {\n                rewrite ^/(.*)$  /$1 break;\n            }\n        }\n    }\n```\n *也可再本地编辑好后上传到服务器*\n3. 确认无误后按下esc键,之后再按下:wq!退出. 然后执行下面命令, 注意`yuxiang.ren`的替换。(配置git仓库)\n```bash\n    ln -s /etc/nginx/sites-available/yuxiang.ren /etc/nginx/sites-enabled/`\n    cd ~\n    mkdir repos && cd repos\n    mkdir yuxiang.ren.git && cd yuxiang.ren.git\n    git init --bare\n    cd hooks\n    touch post-receive\n    vi post-receive`\n```\n4. 在出现的编辑页面中输入以下内容,注意`yuxiang.ren`的替换,然后保存退出。(hexo 部署)\n``` bash\n    #!/bin/bash -l\n    GIT_REPO=$HOME/repos/yuxiang.ren.git\n    TMP_GIT_CLONE=$HOME/tmp/git/renyuxiang.ren\n    PUBLIC_WWW=/var/www/yuxiang.ren\n    rm -rf ${TMP_GIT_CLONE}\n    git clone $GIT_REPO $TMP_GIT_CLONE\n    rm -rf ${PUBLIC_WWW}/*\n    cp -rf ${TMP_GIT_CLONE}/* ${PUBLIC_WWW}\n    cd ~\n    #cd ${PUBLIC_WWW}\n    #hexo d -fg\n    cd ~\n    exit\n```\n5. 依次执行下面命令\n* `chmod +x post-receive`\n* `cd ~`\n* `service nginx restart`\n\n#### 回到本地电脑\n1. 首先进入网站根目录。\n2. 执行以下命令, 注意替换\n* `git clone root@45.32.249.14:repos/yuxiang.ren.git`; 把之前再服务器创建的仓库clone到本地\n* `git add .`\n* `git commit -m \"commit message\"`\n* `push`\n\n## 三、Blog更新\n#### 1. 创建`.m`文件\n有两种方法\n1. 直接创建\n2. 通过命令(推荐)\n* 进入网站目录\n* `hexo new 文章名字`\n* 用MarkDown编辑器编辑创建的文件(`/source/_posts/`下)\n\n```markdown\n    title: title  #文章的标题\n    date: yyyy-mm-dd #创建时间\n    categories: category #分类\n    tags: tag #标签\n       \n    #多标签请这样写：tags: [tag1,tag2,tag3]\n    #或者这样写： \n     #tags: \n       #- tag1\n       #- tag2 \n       #- tag3 \n    ---  \n      \n    #正文\n```\n### 发布\n进入网站根目录\n```ruby\nhexo d -fg\ngit add .\ngit commit -m \"操作内容\"\ngit push\n```","source":"_posts/install-hexo-on-vps-and-update-with-git.md","raw":"---\ntitle: 在vps上安装hexo并且使用git更新\ndate: 2016-12-02 11:28:17\ncategories: 教程\ntags: [教程 Hexo]\n\n---\n\n\n## 一、准备工作\n#### VPS&域名\n请自行购买服务器以及域名.\n\n## 二、搭建过程\n>搭建分为两个部分:一部分在本机(Mac)进行，另一部分则在服务端(VPS)进行，大致需要完成的工作是在本机和服务器各安装一次Hexo和Git，并在服务器上安装Nginx服务器、配置Git Hooks以实现更新.并且全程使用终端命令完成。\n\n<!-- more -->\n\n#### 本地电脑配置\n1. 安装Homebrew\n* `/usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"`\n2. 安装Node.js\n* `brew install node`\n3. 创建网站目录\n* 在任意位置创建一个文件夹，作为网站目录，并通过 cd 命令进入文件夹。\n4. 本地电脑安装hexo\n* `npm install -g hexo-cli`\n* `hexo init`\n* `npm install`\n* `hexo d -fg`\n* `hexo serve` *简洁写法:`hexo s`*\n\n然后访问 http://localhost:4000 如果看到网页表示Hexo配置成功\n\n#### 远程服务器配置(VPS)\n**下文中的`yuxiang.ren(这是我的域名)`,`45.32.249.14(这是我的主机ip)`...请自行替换**\n\n1. 此处为Debian/Ubuntu在root用户下的操作:\n*  执行`ssh root@你的vps地址`进入主机\n* 依次执行以下命令 (安装hexo服务)\n    ​          \n    ```bash\n     $apt-get update && apt-get upgrade -y\n     $apt-get install git-core -y\n     $curl -sL https://deb.nodesource.com/setup | bash\n     $apt-get install nodejs -y\n     $apt-get install nginx -y\n     $cd /etc/nginx/sites-available\n     $rm -rf default\n     $touch yuxiang.ren #根据自己情况替换\n     $vi yuxiang.ren #根据自己情况替换\n    ```\n2. 上面的最后一条命令输入完成后会进入编辑页面,将下面代码复制到里面(通过按i进入编辑模式)。(host监听)\n```ruby\n    server {\n        listen 45.32.249.14:80; #监听80端口\n        server_name yuxiang.ren; # 域名\n        access_log  /var/log/nginx/yuxiang_access.log;\n        error_log   /var/log/nginx/yuxiang_error.log;\n        location ~* ^.+\\.(ico|gif|jpg|jpeg|png)$ {\n                root /var/www/yuxiang.ren/public;\n                access_log   off;\n                expires      1d;\n            }\n        location ~* ^.+\\.(css|js|txt|xml|swf|wav)$ {\n            root /var/www/yuxiang.ren/public;\n            access_log   off;\n            expires      10m;\n        }\n        location / {\n            root /var/www/yuxiang.ren/public;\n            if (-f $request_filename) {\n                rewrite ^/(.*)$  /$1 break;\n            }\n        }\n    }\n```\n *也可再本地编辑好后上传到服务器*\n3. 确认无误后按下esc键,之后再按下:wq!退出. 然后执行下面命令, 注意`yuxiang.ren`的替换。(配置git仓库)\n```bash\n    ln -s /etc/nginx/sites-available/yuxiang.ren /etc/nginx/sites-enabled/`\n    cd ~\n    mkdir repos && cd repos\n    mkdir yuxiang.ren.git && cd yuxiang.ren.git\n    git init --bare\n    cd hooks\n    touch post-receive\n    vi post-receive`\n```\n4. 在出现的编辑页面中输入以下内容,注意`yuxiang.ren`的替换,然后保存退出。(hexo 部署)\n``` bash\n    #!/bin/bash -l\n    GIT_REPO=$HOME/repos/yuxiang.ren.git\n    TMP_GIT_CLONE=$HOME/tmp/git/renyuxiang.ren\n    PUBLIC_WWW=/var/www/yuxiang.ren\n    rm -rf ${TMP_GIT_CLONE}\n    git clone $GIT_REPO $TMP_GIT_CLONE\n    rm -rf ${PUBLIC_WWW}/*\n    cp -rf ${TMP_GIT_CLONE}/* ${PUBLIC_WWW}\n    cd ~\n    #cd ${PUBLIC_WWW}\n    #hexo d -fg\n    cd ~\n    exit\n```\n5. 依次执行下面命令\n* `chmod +x post-receive`\n* `cd ~`\n* `service nginx restart`\n\n#### 回到本地电脑\n1. 首先进入网站根目录。\n2. 执行以下命令, 注意替换\n* `git clone root@45.32.249.14:repos/yuxiang.ren.git`; 把之前再服务器创建的仓库clone到本地\n* `git add .`\n* `git commit -m \"commit message\"`\n* `push`\n\n## 三、Blog更新\n#### 1. 创建`.m`文件\n有两种方法\n1. 直接创建\n2. 通过命令(推荐)\n* 进入网站目录\n* `hexo new 文章名字`\n* 用MarkDown编辑器编辑创建的文件(`/source/_posts/`下)\n\n```markdown\n    title: title  #文章的标题\n    date: yyyy-mm-dd #创建时间\n    categories: category #分类\n    tags: tag #标签\n       \n    #多标签请这样写：tags: [tag1,tag2,tag3]\n    #或者这样写： \n     #tags: \n       #- tag1\n       #- tag2 \n       #- tag3 \n    ---  \n      \n    #正文\n```\n### 发布\n进入网站根目录\n```ruby\nhexo d -fg\ngit add .\ngit commit -m \"操作内容\"\ngit push\n```","slug":"install-hexo-on-vps-and-update-with-git","published":1,"updated":"2017-04-28T08:38:11.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6686xm4001cxe9z1iylg3z3","content":"<h2 id=\"一、准备工作\"><a href=\"#一、准备工作\" class=\"headerlink\" title=\"一、准备工作\"></a>一、准备工作</h2><h4 id=\"VPS-amp-域名\"><a href=\"#VPS-amp-域名\" class=\"headerlink\" title=\"VPS&amp;域名\"></a>VPS&amp;域名</h4><p>请自行购买服务器以及域名.</p>\n<h2 id=\"二、搭建过程\"><a href=\"#二、搭建过程\" class=\"headerlink\" title=\"二、搭建过程\"></a>二、搭建过程</h2><blockquote>\n<p>搭建分为两个部分:一部分在本机(Mac)进行，另一部分则在服务端(VPS)进行，大致需要完成的工作是在本机和服务器各安装一次Hexo和Git，并在服务器上安装Nginx服务器、配置Git Hooks以实现更新.并且全程使用终端命令完成。</p>\n</blockquote>\n<a id=\"more\"></a>\n<h4 id=\"本地电脑配置\"><a href=\"#本地电脑配置\" class=\"headerlink\" title=\"本地电脑配置\"></a>本地电脑配置</h4><ol>\n<li>安装Homebrew</li>\n</ol>\n<ul>\n<li><code>/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</code></li>\n</ul>\n<ol>\n<li>安装Node.js</li>\n</ol>\n<ul>\n<li><code>brew install node</code></li>\n</ul>\n<ol>\n<li>创建网站目录</li>\n</ol>\n<ul>\n<li>在任意位置创建一个文件夹，作为网站目录，并通过 cd 命令进入文件夹。</li>\n</ul>\n<ol>\n<li>本地电脑安装hexo</li>\n</ol>\n<ul>\n<li><code>npm install -g hexo-cli</code></li>\n<li><code>hexo init</code></li>\n<li><code>npm install</code></li>\n<li><code>hexo d -fg</code></li>\n<li><code>hexo serve</code> <em>简洁写法:<code>hexo s</code></em></li>\n</ul>\n<p>然后访问 <a href=\"http://localhost:4000\" target=\"_blank\" rel=\"external\">http://localhost:4000</a> 如果看到网页表示Hexo配置成功</p>\n<h4 id=\"远程服务器配置-VPS\"><a href=\"#远程服务器配置-VPS\" class=\"headerlink\" title=\"远程服务器配置(VPS)\"></a>远程服务器配置(VPS)</h4><p><strong>下文中的<code>yuxiang.ren(这是我的域名)</code>,<code>45.32.249.14(这是我的主机ip)</code>…请自行替换</strong></p>\n<ol>\n<li>此处为Debian/Ubuntu在root用户下的操作:</li>\n</ol>\n<ul>\n<li>执行<code>ssh root@你的vps地址</code>进入主机</li>\n<li>依次执行以下命令 (安装hexo服务)<br>  ​            <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"variable\">$apt</span>-get update &amp;&amp; apt-get upgrade -y</div><div class=\"line\"><span class=\"variable\">$apt</span>-get install git-core -y</div><div class=\"line\"><span class=\"variable\">$curl</span> <span class=\"_\">-s</span>L https://deb.nodesource.com/setup | bash</div><div class=\"line\"><span class=\"variable\">$apt</span>-get install nodejs -y</div><div class=\"line\"><span class=\"variable\">$apt</span>-get install nginx -y</div><div class=\"line\"><span class=\"variable\">$cd</span> /etc/nginx/sites-available</div><div class=\"line\"><span class=\"variable\">$rm</span> -rf default</div><div class=\"line\"><span class=\"variable\">$touch</span> yuxiang.ren <span class=\"comment\">#根据自己情况替换</span></div><div class=\"line\"><span class=\"variable\">$vi</span> yuxiang.ren <span class=\"comment\">#根据自己情况替换</span></div></pre></td></tr></table></figure>\n</li>\n</ul>\n<ol>\n<li><p>上面的最后一条命令输入完成后会进入编辑页面,将下面代码复制到里面(通过按i进入编辑模式)。(host监听)</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">server &#123;</div><div class=\"line\">    listen <span class=\"number\">45.32</span>.<span class=\"number\">249.14</span><span class=\"symbol\">:</span><span class=\"number\">80</span>; <span class=\"comment\">#监听80端口</span></div><div class=\"line\">    server_name yuxiang.ren; <span class=\"comment\"># 域名</span></div><div class=\"line\">    access_log  /var/log/nginx/yuxiang_access.log;</div><div class=\"line\">    error_log   /var/log/nginx/yuxiang_error.log;</div><div class=\"line\">    location ~* ^.+\\.(ico<span class=\"params\">|gif|</span>jpg<span class=\"params\">|jpeg|</span>png)$ &#123;</div><div class=\"line\">            root /var/www/yuxiang.ren/public;</div><div class=\"line\">            access_log   off;</div><div class=\"line\">            expires      <span class=\"number\">1</span>d;</div><div class=\"line\">        &#125;</div><div class=\"line\">    location ~* ^.+\\.(css<span class=\"params\">|js|</span>txt<span class=\"params\">|xml|</span>swf<span class=\"params\">|wav)$ &#123;</span></div><div class=\"line\">        root /var/www/yuxiang.ren/public;</div><div class=\"line\">        access_log   off;</div><div class=\"line\">        expires      10m;</div><div class=\"line\">    &#125;</div><div class=\"line\">    location / &#123;</div><div class=\"line\">        root /var/www/yuxiang.ren/public;</div><div class=\"line\">        <span class=\"keyword\">if</span> (-f $request_filename) &#123;</div><div class=\"line\">            rewrite ^/(.*)$  /$1 <span class=\"keyword\">break</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><em>也可再本地编辑好后上传到服务器</em></p>\n</li>\n<li><p>确认无误后按下esc键,之后再按下:wq!退出. 然后执行下面命令, 注意<code>yuxiang.ren</code>的替换。(配置git仓库)</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">ln <span class=\"_\">-s</span> /etc/nginx/sites-available/yuxiang.ren /etc/nginx/sites-enabled/`</div><div class=\"line\"><span class=\"built_in\">cd</span> ~</div><div class=\"line\">mkdir repos &amp;&amp; <span class=\"built_in\">cd</span> repos</div><div class=\"line\">mkdir yuxiang.ren.git &amp;&amp; <span class=\"built_in\">cd</span> yuxiang.ren.git</div><div class=\"line\">git init --bare</div><div class=\"line\"><span class=\"built_in\">cd</span> hooks</div><div class=\"line\">touch post-receive</div><div class=\"line\">vi post-receive`</div></pre></td></tr></table></figure>\n</li>\n<li><p>在出现的编辑页面中输入以下内容,注意<code>yuxiang.ren</code>的替换,然后保存退出。(hexo 部署)</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">#!/bin/bash -l</span></div><div class=\"line\">GIT_REPO=<span class=\"variable\">$HOME</span>/repos/yuxiang.ren.git</div><div class=\"line\">TMP_GIT_CLONE=<span class=\"variable\">$HOME</span>/tmp/git/renyuxiang.ren</div><div class=\"line\">PUBLIC_WWW=/var/www/yuxiang.ren</div><div class=\"line\">rm -rf <span class=\"variable\">$&#123;TMP_GIT_CLONE&#125;</span></div><div class=\"line\">git <span class=\"built_in\">clone</span> <span class=\"variable\">$GIT_REPO</span> <span class=\"variable\">$TMP_GIT_CLONE</span></div><div class=\"line\">rm -rf <span class=\"variable\">$&#123;PUBLIC_WWW&#125;</span>/*</div><div class=\"line\">cp -rf <span class=\"variable\">$&#123;TMP_GIT_CLONE&#125;</span>/* <span class=\"variable\">$&#123;PUBLIC_WWW&#125;</span></div><div class=\"line\"><span class=\"built_in\">cd</span> ~</div><div class=\"line\"><span class=\"comment\">#cd $&#123;PUBLIC_WWW&#125;</span></div><div class=\"line\"><span class=\"comment\">#hexo d -fg</span></div><div class=\"line\"><span class=\"built_in\">cd</span> ~</div><div class=\"line\"><span class=\"built_in\">exit</span></div></pre></td></tr></table></figure>\n</li>\n<li><p>依次执行下面命令</p>\n</li>\n</ol>\n<ul>\n<li><code>chmod +x post-receive</code></li>\n<li><code>cd ~</code></li>\n<li><code>service nginx restart</code></li>\n</ul>\n<h4 id=\"回到本地电脑\"><a href=\"#回到本地电脑\" class=\"headerlink\" title=\"回到本地电脑\"></a>回到本地电脑</h4><ol>\n<li>首先进入网站根目录。</li>\n<li>执行以下命令, 注意替换</li>\n</ol>\n<ul>\n<li><code>git clone root@45.32.249.14:repos/yuxiang.ren.git</code>; 把之前再服务器创建的仓库clone到本地</li>\n<li><code>git add .</code></li>\n<li><code>git commit -m &quot;commit message&quot;</code></li>\n<li><code>push</code></li>\n</ul>\n<h2 id=\"三、Blog更新\"><a href=\"#三、Blog更新\" class=\"headerlink\" title=\"三、Blog更新\"></a>三、Blog更新</h2><h4 id=\"1-创建-m文件\"><a href=\"#1-创建-m文件\" class=\"headerlink\" title=\"1. 创建.m文件\"></a>1. 创建<code>.m</code>文件</h4><p>有两种方法</p>\n<ol>\n<li>直接创建</li>\n<li>通过命令(推荐)</li>\n</ol>\n<ul>\n<li>进入网站目录</li>\n<li><code>hexo new 文章名字</code></li>\n<li>用MarkDown编辑器编辑创建的文件(<code>/source/_posts/</code>下)</li>\n</ul>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">title: title  #文章的标题</div><div class=\"line\">date: yyyy-mm-dd #创建时间</div><div class=\"line\">categories: category #分类</div><div class=\"line\">tags: tag #标签</div><div class=\"line\">   </div><div class=\"line\"><span class=\"section\">#多标签请这样写：tags: [tag1,tag2,tag3]</span></div><div class=\"line\"><span class=\"section\">#或者这样写： </span></div><div class=\"line\"> #tags: </div><div class=\"line\">   #- tag1</div><div class=\"line\">   #- tag2 </div><div class=\"line\">   #- tag3 </div><div class=\"line\">---  </div><div class=\"line\">  </div><div class=\"line\"><span class=\"section\">#正文</span></div></pre></td></tr></table></figure>\n<h3 id=\"发布\"><a href=\"#发布\" class=\"headerlink\" title=\"发布\"></a>发布</h3><p>进入网站根目录<br><figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo d -fg</div><div class=\"line\">git add .</div><div class=\"line\">git commit -m <span class=\"string\">\"操作内容\"</span></div><div class=\"line\">git push</div></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"一、准备工作\"><a href=\"#一、准备工作\" class=\"headerlink\" title=\"一、准备工作\"></a>一、准备工作</h2><h4 id=\"VPS-amp-域名\"><a href=\"#VPS-amp-域名\" class=\"headerlink\" title=\"VPS&amp;域名\"></a>VPS&amp;域名</h4><p>请自行购买服务器以及域名.</p>\n<h2 id=\"二、搭建过程\"><a href=\"#二、搭建过程\" class=\"headerlink\" title=\"二、搭建过程\"></a>二、搭建过程</h2><blockquote>\n<p>搭建分为两个部分:一部分在本机(Mac)进行，另一部分则在服务端(VPS)进行，大致需要完成的工作是在本机和服务器各安装一次Hexo和Git，并在服务器上安装Nginx服务器、配置Git Hooks以实现更新.并且全程使用终端命令完成。</p>\n</blockquote>","more":"<h4 id=\"本地电脑配置\"><a href=\"#本地电脑配置\" class=\"headerlink\" title=\"本地电脑配置\"></a>本地电脑配置</h4><ol>\n<li>安装Homebrew</li>\n</ol>\n<ul>\n<li><code>/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</code></li>\n</ul>\n<ol>\n<li>安装Node.js</li>\n</ol>\n<ul>\n<li><code>brew install node</code></li>\n</ul>\n<ol>\n<li>创建网站目录</li>\n</ol>\n<ul>\n<li>在任意位置创建一个文件夹，作为网站目录，并通过 cd 命令进入文件夹。</li>\n</ul>\n<ol>\n<li>本地电脑安装hexo</li>\n</ol>\n<ul>\n<li><code>npm install -g hexo-cli</code></li>\n<li><code>hexo init</code></li>\n<li><code>npm install</code></li>\n<li><code>hexo d -fg</code></li>\n<li><code>hexo serve</code> <em>简洁写法:<code>hexo s</code></em></li>\n</ul>\n<p>然后访问 <a href=\"http://localhost:4000\" target=\"_blank\" rel=\"external\">http://localhost:4000</a> 如果看到网页表示Hexo配置成功</p>\n<h4 id=\"远程服务器配置-VPS\"><a href=\"#远程服务器配置-VPS\" class=\"headerlink\" title=\"远程服务器配置(VPS)\"></a>远程服务器配置(VPS)</h4><p><strong>下文中的<code>yuxiang.ren(这是我的域名)</code>,<code>45.32.249.14(这是我的主机ip)</code>…请自行替换</strong></p>\n<ol>\n<li>此处为Debian/Ubuntu在root用户下的操作:</li>\n</ol>\n<ul>\n<li>执行<code>ssh root@你的vps地址</code>进入主机</li>\n<li>依次执行以下命令 (安装hexo服务)<br>  ​            <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"variable\">$apt</span>-get update &amp;&amp; apt-get upgrade -y</div><div class=\"line\"><span class=\"variable\">$apt</span>-get install git-core -y</div><div class=\"line\"><span class=\"variable\">$curl</span> <span class=\"_\">-s</span>L https://deb.nodesource.com/setup | bash</div><div class=\"line\"><span class=\"variable\">$apt</span>-get install nodejs -y</div><div class=\"line\"><span class=\"variable\">$apt</span>-get install nginx -y</div><div class=\"line\"><span class=\"variable\">$cd</span> /etc/nginx/sites-available</div><div class=\"line\"><span class=\"variable\">$rm</span> -rf default</div><div class=\"line\"><span class=\"variable\">$touch</span> yuxiang.ren <span class=\"comment\">#根据自己情况替换</span></div><div class=\"line\"><span class=\"variable\">$vi</span> yuxiang.ren <span class=\"comment\">#根据自己情况替换</span></div></pre></td></tr></table></figure>\n</li>\n</ul>\n<ol>\n<li><p>上面的最后一条命令输入完成后会进入编辑页面,将下面代码复制到里面(通过按i进入编辑模式)。(host监听)</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">server &#123;</div><div class=\"line\">    listen <span class=\"number\">45.32</span>.<span class=\"number\">249.14</span><span class=\"symbol\">:</span><span class=\"number\">80</span>; <span class=\"comment\">#监听80端口</span></div><div class=\"line\">    server_name yuxiang.ren; <span class=\"comment\"># 域名</span></div><div class=\"line\">    access_log  /var/log/nginx/yuxiang_access.log;</div><div class=\"line\">    error_log   /var/log/nginx/yuxiang_error.log;</div><div class=\"line\">    location ~* ^.+\\.(ico<span class=\"params\">|gif|</span>jpg<span class=\"params\">|jpeg|</span>png)$ &#123;</div><div class=\"line\">            root /var/www/yuxiang.ren/public;</div><div class=\"line\">            access_log   off;</div><div class=\"line\">            expires      <span class=\"number\">1</span>d;</div><div class=\"line\">        &#125;</div><div class=\"line\">    location ~* ^.+\\.(css<span class=\"params\">|js|</span>txt<span class=\"params\">|xml|</span>swf<span class=\"params\">|wav)$ &#123;</span></div><div class=\"line\">        root /var/www/yuxiang.ren/public;</div><div class=\"line\">        access_log   off;</div><div class=\"line\">        expires      10m;</div><div class=\"line\">    &#125;</div><div class=\"line\">    location / &#123;</div><div class=\"line\">        root /var/www/yuxiang.ren/public;</div><div class=\"line\">        <span class=\"keyword\">if</span> (-f $request_filename) &#123;</div><div class=\"line\">            rewrite ^/(.*)$  /$1 <span class=\"keyword\">break</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><em>也可再本地编辑好后上传到服务器</em></p>\n</li>\n<li><p>确认无误后按下esc键,之后再按下:wq!退出. 然后执行下面命令, 注意<code>yuxiang.ren</code>的替换。(配置git仓库)</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">ln <span class=\"_\">-s</span> /etc/nginx/sites-available/yuxiang.ren /etc/nginx/sites-enabled/`</div><div class=\"line\"><span class=\"built_in\">cd</span> ~</div><div class=\"line\">mkdir repos &amp;&amp; <span class=\"built_in\">cd</span> repos</div><div class=\"line\">mkdir yuxiang.ren.git &amp;&amp; <span class=\"built_in\">cd</span> yuxiang.ren.git</div><div class=\"line\">git init --bare</div><div class=\"line\"><span class=\"built_in\">cd</span> hooks</div><div class=\"line\">touch post-receive</div><div class=\"line\">vi post-receive`</div></pre></td></tr></table></figure>\n</li>\n<li><p>在出现的编辑页面中输入以下内容,注意<code>yuxiang.ren</code>的替换,然后保存退出。(hexo 部署)</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">#!/bin/bash -l</span></div><div class=\"line\">GIT_REPO=<span class=\"variable\">$HOME</span>/repos/yuxiang.ren.git</div><div class=\"line\">TMP_GIT_CLONE=<span class=\"variable\">$HOME</span>/tmp/git/renyuxiang.ren</div><div class=\"line\">PUBLIC_WWW=/var/www/yuxiang.ren</div><div class=\"line\">rm -rf <span class=\"variable\">$&#123;TMP_GIT_CLONE&#125;</span></div><div class=\"line\">git <span class=\"built_in\">clone</span> <span class=\"variable\">$GIT_REPO</span> <span class=\"variable\">$TMP_GIT_CLONE</span></div><div class=\"line\">rm -rf <span class=\"variable\">$&#123;PUBLIC_WWW&#125;</span>/*</div><div class=\"line\">cp -rf <span class=\"variable\">$&#123;TMP_GIT_CLONE&#125;</span>/* <span class=\"variable\">$&#123;PUBLIC_WWW&#125;</span></div><div class=\"line\"><span class=\"built_in\">cd</span> ~</div><div class=\"line\"><span class=\"comment\">#cd $&#123;PUBLIC_WWW&#125;</span></div><div class=\"line\"><span class=\"comment\">#hexo d -fg</span></div><div class=\"line\"><span class=\"built_in\">cd</span> ~</div><div class=\"line\"><span class=\"built_in\">exit</span></div></pre></td></tr></table></figure>\n</li>\n<li><p>依次执行下面命令</p>\n</li>\n</ol>\n<ul>\n<li><code>chmod +x post-receive</code></li>\n<li><code>cd ~</code></li>\n<li><code>service nginx restart</code></li>\n</ul>\n<h4 id=\"回到本地电脑\"><a href=\"#回到本地电脑\" class=\"headerlink\" title=\"回到本地电脑\"></a>回到本地电脑</h4><ol>\n<li>首先进入网站根目录。</li>\n<li>执行以下命令, 注意替换</li>\n</ol>\n<ul>\n<li><code>git clone root@45.32.249.14:repos/yuxiang.ren.git</code>; 把之前再服务器创建的仓库clone到本地</li>\n<li><code>git add .</code></li>\n<li><code>git commit -m &quot;commit message&quot;</code></li>\n<li><code>push</code></li>\n</ul>\n<h2 id=\"三、Blog更新\"><a href=\"#三、Blog更新\" class=\"headerlink\" title=\"三、Blog更新\"></a>三、Blog更新</h2><h4 id=\"1-创建-m文件\"><a href=\"#1-创建-m文件\" class=\"headerlink\" title=\"1. 创建.m文件\"></a>1. 创建<code>.m</code>文件</h4><p>有两种方法</p>\n<ol>\n<li>直接创建</li>\n<li>通过命令(推荐)</li>\n</ol>\n<ul>\n<li>进入网站目录</li>\n<li><code>hexo new 文章名字</code></li>\n<li>用MarkDown编辑器编辑创建的文件(<code>/source/_posts/</code>下)</li>\n</ul>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">title: title  #文章的标题</div><div class=\"line\">date: yyyy-mm-dd #创建时间</div><div class=\"line\">categories: category #分类</div><div class=\"line\">tags: tag #标签</div><div class=\"line\">   </div><div class=\"line\"><span class=\"section\">#多标签请这样写：tags: [tag1,tag2,tag3]</span></div><div class=\"line\"><span class=\"section\">#或者这样写： </span></div><div class=\"line\"> #tags: </div><div class=\"line\">   #- tag1</div><div class=\"line\">   #- tag2 </div><div class=\"line\">   #- tag3 </div><div class=\"line\">---  </div><div class=\"line\">  </div><div class=\"line\"><span class=\"section\">#正文</span></div></pre></td></tr></table></figure>\n<h3 id=\"发布\"><a href=\"#发布\" class=\"headerlink\" title=\"发布\"></a>发布</h3><p>进入网站根目录<br><figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo d -fg</div><div class=\"line\">git add .</div><div class=\"line\">git commit -m <span class=\"string\">\"操作内容\"</span></div><div class=\"line\">git push</div></pre></td></tr></table></figure></p>"},{"title":"hexo安装huno主题","date":"2016-12-02T01:40:39.000Z","_content":"\n# Huno\n\nHuno是为[Hexo](http://hexo.io/)编写的一个响应式的主题，该主题基于[Uno](https://github.com/daleanthony/uno/)。\n\n<!-- more -->\n\n## Demo\n\n[Huno's demo](https://yuxiang.ren)\n\n## 安装\n\n```plain\n$ git clone git://github.com/someus/huno.git themes/huno\n```\n\n修改Hexo的配置文件`_config.xml`：\n\n```plain\ntheme: huno\n```\n\n\n## 兼容性\n在Hexo 3.1.1测试正常。\n\n## 配置示例\n\n```ruby\n# Header\nmenu:\n  博客: /#blog\n  归档: /archive\n  关于: /about\n  主页: # your home page\n\n# Site favicon\nfavicon: /images/favicon.ico\n\n# 头像\navatar: /images/avatar.jpg\n\n# apple touch icon\nappleTouchIcon: /images/apple-touch-icon.png\n\n# Enable Mathjax\nmathjax: true\n\n# Enable awesome-toc\nawesome_toc: true\n\n# Enable githubRepoWidget\ngithub_repo_widget: false\n\n```\n\nmenu中定义`/#blog`是必须的，示例中的`/about`和`/archive`是两个页面。`/archive`会在下面的**归档页面**中介绍。\n\n**mathjax:**\n\n数学公式支持。其设置（layout/_scripts/mathjax.ejs）如下：\n\n```\n$(document).ready(function(){\n    MathJax.Hub.Config({ \n        tex2jax: {inlineMath: [['[latex]','[/latex]'], ['\\\\(','\\\\)']]} \n    });\n});\n```\n\n官网：[mathjax](https://www.mathjax.org/)\n\n\n**awesome_toc:**\n\n为文章生成目录。\n\n官网：[awesome-toc](https://github.com/someus/awesome-toc)\n\n**github_repo_widget:**\n\n可视化显示github中的项目。\n\n官网：[GitHub-jQuery-Repo-Widget](https://github.com/JoelSutherland/GitHub-jQuery-Repo-Widget)\n\n\n## 侧边栏图片\n侧边栏图片URL定义在`source/css/uno.css`中下面的这段代码中：\n\n```css\n.panel-cover {\n  display: block;\n  position: fixed;\n  z-index: 900;\n  width: 100%;\n  max-width: none;\n  height: 100%;\n  background: url(../images/background-cover.jpg) top left no-repeat #666666;\n  background-size: cover; }\n```\n\n可以看出图片路径是`source/images/background-cover.jpg`。可以根据需要替换成不同的图片，或者修改图片URL。例如修改成CDN中的某个图片（[#28](https://github.com/someus/huno/pull/28)）：\n\n```\nbackground: url(\"http://ww4.sinaimg.cn/mw690/6a80ef0fgw1fac749wvfij21hc0xch6b.jpg\") top left no-repeat #666666;\n```\n\n\n## 归档页面\n归档页面会显示分类、标签云以及基于日期的归档。\n\n在主题的配置文件`_config.yml`中：\n\n```yaml\n# Header\nmenu:\n  首页: /#blog\n  归档: /archive\n  关于: /about\n```\n\n创建新的page：\n\n```plain\n$ hexo new page archive\n$ cd source/archive\n$ vim index.md\n```\n\n内容修改为：\n\n```\ntitle: 归档\nlayout: page-archive\n---\n```\n\n> !! hexo 默认有一个`/archives`，如果您认为归档页面的url（`/archive`）和这个冲突，可以选更加合适的名称:blush:。\n\n\n## 评论\n支持Disqus和多说，在Hexo配置文件`_config.yml`中设置名称即可，例如：\n\n```yaml\n# Disqus\ndisqus_shortname: letian\n\n# Duoshuo\nduoshuo_shortname: letian\n```\n\n> !!! 如果两个都设置，则两个评论工具都会显示。\n\n## Social Icon\n默认提供了Github的图标，Github用户名请在Hexo的配置文件`_config.yml`中配置，例如：\n\n```yaml\n# Social\nsocial:\n  github: someus\n```\n\n可以根据需要在`layout/_partials/social.ejs`中添加更多的图标。\n\n\n## China Social Icon\n> 这套字体来自 [设计素材：国内常用社交图标的web字体](http://www.zcool.com.cn/gfx/ZMzM1MjEy.html)， 版权归原作者所有。在huno中CSS文件做了些修改。\n\n这套字体和上面`Social Icon`的设计得并不一样，如果混用，排版效果会略差。例如，在`layout/_partials/social.ejs`加上：\n\n```\n<li class=\"navigation__item\">\n  <a href=\"\" title=\"\">\n    <i class='icon cs-icon-douban'></i>\n    <span class=\"label\">Douban</span>\n  </a>\n</li>\n\n<li class=\"navigation__item\">\n  <a href=\"\" title=\"\">\n    <i class='icon cs-icon-weibo'></i>\n    <span class=\"label\">Weibo</span>\n  </a>\n</li>\n```\n\n效果如下：\n\n![](./cs-icon.png)\n\n字体文件位于`source/fonts/china-social/`中，对应的css文件是`source/css/china-social-icon.css`。\n\n\n## 网站统计\n将网站统计（如Google analysis、CNZZ、百度统计等）代码放入`layout/_scripts/site-analytics.ejs`即可。\n\n## 如何将Huno生成的静态网站放在某网站子目录\n\n例如要将其放入`http://hi.letiantian.me/huno/`下，则需要：\n\n**修改Hexo配置文件`_config.yml`:**\n\n```yaml\n# URL\n## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'\nurl: http://hi.letiantian.me/huno\nroot: /huno/\n```\n\n**修改主题的配置文件`_config.yml`:**\n\n```yaml\n# Header\nmenu:\n  首页: /huno/#blog\n  关于: /huno/about\n  归档: /huno/archive\n\n# Site favicon\nfavicon: /huno/favicon.png\n```\n\n**修改`huno/source/js/main.js`:**\n\n将\n\n```js\nif (window.location.pathname != \"/\") {\n  $('.panel-cover').addClass('panel-cover--collapsed');\n}\n```\n\n修改为\n\n```js\nif (window.location.pathname != \"/huno/\") {\n  $('.panel-cover').addClass('panel-cover--collapsed');\n}\n```\n\n**修改`huno/layout/_partials/side-panel.ejs`:**\n\n将\n\n```plain\n<% for (var i in theme.menu){ %>\n  <%\n    if (theme.menu[i]+'' == '/#blog') {\n      nav_btn_class = 'blog-button';\n    } else {\n      nav_btn_class = '';\n    }\n  %>\n```\n\n修改为：\n\n```plain\n<% for (var i in theme.menu){ %>\n  <%\n    if (theme.menu[i]+'' == '/huno/#blog') {\n      nav_btn_class = 'blog-button';\n    } else {\n      nav_btn_class = '';\n    }\n  %>\n```\n\n## 其他\n\n如果在中国大陆使用该主题后，访问速度变慢，可以考虑注释掉`source/css/uno.css`的第一行。\n\n","source":"_posts/install-huno-theme.md","raw":"---\ntitle: hexo安装huno主题\ndate: 2016-12-02 09:40:39\ncategories: 教程\ntags: [教程 Hexo]\n---\n\n# Huno\n\nHuno是为[Hexo](http://hexo.io/)编写的一个响应式的主题，该主题基于[Uno](https://github.com/daleanthony/uno/)。\n\n<!-- more -->\n\n## Demo\n\n[Huno's demo](https://yuxiang.ren)\n\n## 安装\n\n```plain\n$ git clone git://github.com/someus/huno.git themes/huno\n```\n\n修改Hexo的配置文件`_config.xml`：\n\n```plain\ntheme: huno\n```\n\n\n## 兼容性\n在Hexo 3.1.1测试正常。\n\n## 配置示例\n\n```ruby\n# Header\nmenu:\n  博客: /#blog\n  归档: /archive\n  关于: /about\n  主页: # your home page\n\n# Site favicon\nfavicon: /images/favicon.ico\n\n# 头像\navatar: /images/avatar.jpg\n\n# apple touch icon\nappleTouchIcon: /images/apple-touch-icon.png\n\n# Enable Mathjax\nmathjax: true\n\n# Enable awesome-toc\nawesome_toc: true\n\n# Enable githubRepoWidget\ngithub_repo_widget: false\n\n```\n\nmenu中定义`/#blog`是必须的，示例中的`/about`和`/archive`是两个页面。`/archive`会在下面的**归档页面**中介绍。\n\n**mathjax:**\n\n数学公式支持。其设置（layout/_scripts/mathjax.ejs）如下：\n\n```\n$(document).ready(function(){\n    MathJax.Hub.Config({ \n        tex2jax: {inlineMath: [['[latex]','[/latex]'], ['\\\\(','\\\\)']]} \n    });\n});\n```\n\n官网：[mathjax](https://www.mathjax.org/)\n\n\n**awesome_toc:**\n\n为文章生成目录。\n\n官网：[awesome-toc](https://github.com/someus/awesome-toc)\n\n**github_repo_widget:**\n\n可视化显示github中的项目。\n\n官网：[GitHub-jQuery-Repo-Widget](https://github.com/JoelSutherland/GitHub-jQuery-Repo-Widget)\n\n\n## 侧边栏图片\n侧边栏图片URL定义在`source/css/uno.css`中下面的这段代码中：\n\n```css\n.panel-cover {\n  display: block;\n  position: fixed;\n  z-index: 900;\n  width: 100%;\n  max-width: none;\n  height: 100%;\n  background: url(../images/background-cover.jpg) top left no-repeat #666666;\n  background-size: cover; }\n```\n\n可以看出图片路径是`source/images/background-cover.jpg`。可以根据需要替换成不同的图片，或者修改图片URL。例如修改成CDN中的某个图片（[#28](https://github.com/someus/huno/pull/28)）：\n\n```\nbackground: url(\"http://ww4.sinaimg.cn/mw690/6a80ef0fgw1fac749wvfij21hc0xch6b.jpg\") top left no-repeat #666666;\n```\n\n\n## 归档页面\n归档页面会显示分类、标签云以及基于日期的归档。\n\n在主题的配置文件`_config.yml`中：\n\n```yaml\n# Header\nmenu:\n  首页: /#blog\n  归档: /archive\n  关于: /about\n```\n\n创建新的page：\n\n```plain\n$ hexo new page archive\n$ cd source/archive\n$ vim index.md\n```\n\n内容修改为：\n\n```\ntitle: 归档\nlayout: page-archive\n---\n```\n\n> !! hexo 默认有一个`/archives`，如果您认为归档页面的url（`/archive`）和这个冲突，可以选更加合适的名称:blush:。\n\n\n## 评论\n支持Disqus和多说，在Hexo配置文件`_config.yml`中设置名称即可，例如：\n\n```yaml\n# Disqus\ndisqus_shortname: letian\n\n# Duoshuo\nduoshuo_shortname: letian\n```\n\n> !!! 如果两个都设置，则两个评论工具都会显示。\n\n## Social Icon\n默认提供了Github的图标，Github用户名请在Hexo的配置文件`_config.yml`中配置，例如：\n\n```yaml\n# Social\nsocial:\n  github: someus\n```\n\n可以根据需要在`layout/_partials/social.ejs`中添加更多的图标。\n\n\n## China Social Icon\n> 这套字体来自 [设计素材：国内常用社交图标的web字体](http://www.zcool.com.cn/gfx/ZMzM1MjEy.html)， 版权归原作者所有。在huno中CSS文件做了些修改。\n\n这套字体和上面`Social Icon`的设计得并不一样，如果混用，排版效果会略差。例如，在`layout/_partials/social.ejs`加上：\n\n```\n<li class=\"navigation__item\">\n  <a href=\"\" title=\"\">\n    <i class='icon cs-icon-douban'></i>\n    <span class=\"label\">Douban</span>\n  </a>\n</li>\n\n<li class=\"navigation__item\">\n  <a href=\"\" title=\"\">\n    <i class='icon cs-icon-weibo'></i>\n    <span class=\"label\">Weibo</span>\n  </a>\n</li>\n```\n\n效果如下：\n\n![](./cs-icon.png)\n\n字体文件位于`source/fonts/china-social/`中，对应的css文件是`source/css/china-social-icon.css`。\n\n\n## 网站统计\n将网站统计（如Google analysis、CNZZ、百度统计等）代码放入`layout/_scripts/site-analytics.ejs`即可。\n\n## 如何将Huno生成的静态网站放在某网站子目录\n\n例如要将其放入`http://hi.letiantian.me/huno/`下，则需要：\n\n**修改Hexo配置文件`_config.yml`:**\n\n```yaml\n# URL\n## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'\nurl: http://hi.letiantian.me/huno\nroot: /huno/\n```\n\n**修改主题的配置文件`_config.yml`:**\n\n```yaml\n# Header\nmenu:\n  首页: /huno/#blog\n  关于: /huno/about\n  归档: /huno/archive\n\n# Site favicon\nfavicon: /huno/favicon.png\n```\n\n**修改`huno/source/js/main.js`:**\n\n将\n\n```js\nif (window.location.pathname != \"/\") {\n  $('.panel-cover').addClass('panel-cover--collapsed');\n}\n```\n\n修改为\n\n```js\nif (window.location.pathname != \"/huno/\") {\n  $('.panel-cover').addClass('panel-cover--collapsed');\n}\n```\n\n**修改`huno/layout/_partials/side-panel.ejs`:**\n\n将\n\n```plain\n<% for (var i in theme.menu){ %>\n  <%\n    if (theme.menu[i]+'' == '/#blog') {\n      nav_btn_class = 'blog-button';\n    } else {\n      nav_btn_class = '';\n    }\n  %>\n```\n\n修改为：\n\n```plain\n<% for (var i in theme.menu){ %>\n  <%\n    if (theme.menu[i]+'' == '/huno/#blog') {\n      nav_btn_class = 'blog-button';\n    } else {\n      nav_btn_class = '';\n    }\n  %>\n```\n\n## 其他\n\n如果在中国大陆使用该主题后，访问速度变慢，可以考虑注释掉`source/css/uno.css`的第一行。\n\n","slug":"install-huno-theme","published":1,"updated":"2017-04-28T08:38:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6686xm7001hxe9z7rketmo4","content":"<h1 id=\"Huno\"><a href=\"#Huno\" class=\"headerlink\" title=\"Huno\"></a>Huno</h1><p>Huno是为<a href=\"http://hexo.io/\" target=\"_blank\" rel=\"external\">Hexo</a>编写的一个响应式的主题，该主题基于<a href=\"https://github.com/daleanthony/uno/\" target=\"_blank\" rel=\"external\">Uno</a>。</p>\n<a id=\"more\"></a>\n<h2 id=\"Demo\"><a href=\"#Demo\" class=\"headerlink\" title=\"Demo\"></a>Demo</h2><p><a href=\"https://yuxiang.ren\">Huno’s demo</a></p>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ git clone git://github.com/someus/huno.git themes/huno</div></pre></td></tr></table></figure>\n<p>修改Hexo的配置文件<code>_config.xml</code>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">theme: huno</div></pre></td></tr></table></figure>\n<h2 id=\"兼容性\"><a href=\"#兼容性\" class=\"headerlink\" title=\"兼容性\"></a>兼容性</h2><p>在Hexo 3.1.1测试正常。</p>\n<h2 id=\"配置示例\"><a href=\"#配置示例\" class=\"headerlink\" title=\"配置示例\"></a>配置示例</h2><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"># Header</div><div class=\"line\">menu:</div><div class=\"line\">  博客: /#blog</div><div class=\"line\">  归档: /archive</div><div class=\"line\">  关于: /about</div><div class=\"line\">  主页: # your home page</div><div class=\"line\"></div><div class=\"line\"># Site favicon</div><div class=\"line\">favicon: /images/favicon.ico</div><div class=\"line\"></div><div class=\"line\"># 头像</div><div class=\"line\">avatar: /images/avatar.jpg</div><div class=\"line\"></div><div class=\"line\"># apple touch icon</div><div class=\"line\">appleTouchIcon: /images/apple-touch-icon.png</div><div class=\"line\"></div><div class=\"line\"># Enable Mathjax</div><div class=\"line\">mathjax: true</div><div class=\"line\"></div><div class=\"line\"># Enable awesome-toc</div><div class=\"line\">awesome_toc: true</div><div class=\"line\"></div><div class=\"line\"># Enable githubRepoWidget</div><div class=\"line\">github_repo_widget: false</div></pre></td></tr></table></figure>\n<p>menu中定义<code>/#blog</code>是必须的，示例中的<code>/about</code>和<code>/archive</code>是两个页面。<code>/archive</code>会在下面的<strong>归档页面</strong>中介绍。</p>\n<p><strong>mathjax:</strong></p>\n<p>数学公式支持。其设置（layout/_scripts/mathjax.ejs）如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">$(document).ready(function()&#123;</div><div class=\"line\">    MathJax.Hub.Config(&#123; </div><div class=\"line\">        tex2jax: &#123;inlineMath: [[&apos;[latex]&apos;,&apos;[/latex]&apos;], [&apos;\\\\(&apos;,&apos;\\\\)&apos;]]&#125; </div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>官网：<a href=\"https://www.mathjax.org/\" target=\"_blank\" rel=\"external\">mathjax</a></p>\n<p><strong>awesome_toc:</strong></p>\n<p>为文章生成目录。</p>\n<p>官网：<a href=\"https://github.com/someus/awesome-toc\" target=\"_blank\" rel=\"external\">awesome-toc</a></p>\n<p><strong>github_repo_widget:</strong></p>\n<p>可视化显示github中的项目。</p>\n<p>官网：<a href=\"https://github.com/JoelSutherland/GitHub-jQuery-Repo-Widget\" target=\"_blank\" rel=\"external\">GitHub-jQuery-Repo-Widget</a></p>\n<h2 id=\"侧边栏图片\"><a href=\"#侧边栏图片\" class=\"headerlink\" title=\"侧边栏图片\"></a>侧边栏图片</h2><p>侧边栏图片URL定义在<code>source/css/uno.css</code>中下面的这段代码中：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.panel-cover</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">display</span>: block;</div><div class=\"line\">  <span class=\"attribute\">position</span>: fixed;</div><div class=\"line\">  <span class=\"attribute\">z-index</span>: <span class=\"number\">900</span>;</div><div class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>;</div><div class=\"line\">  <span class=\"attribute\">max-width</span>: none;</div><div class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">100%</span>;</div><div class=\"line\">  <span class=\"attribute\">background</span>: <span class=\"built_in\">url</span>(../images/background-cover.jpg) top left no-repeat <span class=\"number\">#666666</span>;</div><div class=\"line\">  <span class=\"attribute\">background-size</span>: cover; &#125;</div></pre></td></tr></table></figure>\n<p>可以看出图片路径是<code>source/images/background-cover.jpg</code>。可以根据需要替换成不同的图片，或者修改图片URL。例如修改成CDN中的某个图片（<a href=\"https://github.com/someus/huno/pull/28\" target=\"_blank\" rel=\"external\">#28</a>）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">background: url(&quot;http://ww4.sinaimg.cn/mw690/6a80ef0fgw1fac749wvfij21hc0xch6b.jpg&quot;) top left no-repeat #666666;</div></pre></td></tr></table></figure>\n<h2 id=\"归档页面\"><a href=\"#归档页面\" class=\"headerlink\" title=\"归档页面\"></a>归档页面</h2><p>归档页面会显示分类、标签云以及基于日期的归档。</p>\n<p>在主题的配置文件<code>_config.yml</code>中：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># Header</span></div><div class=\"line\"><span class=\"attr\">menu:</span></div><div class=\"line\">  <span class=\"string\">首页:</span> <span class=\"string\">/#blog</span></div><div class=\"line\">  <span class=\"string\">归档:</span> <span class=\"string\">/archive</span></div><div class=\"line\">  <span class=\"string\">关于:</span> <span class=\"string\">/about</span></div></pre></td></tr></table></figure>\n<p>创建新的page：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo new page archive</div><div class=\"line\">$ cd source/archive</div><div class=\"line\">$ vim index.md</div></pre></td></tr></table></figure>\n<p>内容修改为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">title: 归档</div><div class=\"line\">layout: page-archive</div><div class=\"line\">---</div></pre></td></tr></table></figure>\n<blockquote>\n<p>!! hexo 默认有一个<code>/archives</code>，如果您认为归档页面的url（<code>/archive</code>）和这个冲突，可以选更加合适的名称:blush:。</p>\n</blockquote>\n<h2 id=\"评论\"><a href=\"#评论\" class=\"headerlink\" title=\"评论\"></a>评论</h2><p>支持Disqus和多说，在Hexo配置文件<code>_config.yml</code>中设置名称即可，例如：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># Disqus</span></div><div class=\"line\"><span class=\"attr\">disqus_shortname:</span> <span class=\"string\">letian</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># Duoshuo</span></div><div class=\"line\"><span class=\"attr\">duoshuo_shortname:</span> <span class=\"string\">letian</span></div></pre></td></tr></table></figure>\n<blockquote>\n<p>!!! 如果两个都设置，则两个评论工具都会显示。</p>\n</blockquote>\n<h2 id=\"Social-Icon\"><a href=\"#Social-Icon\" class=\"headerlink\" title=\"Social Icon\"></a>Social Icon</h2><p>默认提供了Github的图标，Github用户名请在Hexo的配置文件<code>_config.yml</code>中配置，例如：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># Social</span></div><div class=\"line\"><span class=\"attr\">social:</span></div><div class=\"line\"><span class=\"attr\">  github:</span> <span class=\"string\">someus</span></div></pre></td></tr></table></figure>\n<p>可以根据需要在<code>layout/_partials/social.ejs</code>中添加更多的图标。</p>\n<h2 id=\"China-Social-Icon\"><a href=\"#China-Social-Icon\" class=\"headerlink\" title=\"China Social Icon\"></a>China Social Icon</h2><blockquote>\n<p>这套字体来自 <a href=\"http://www.zcool.com.cn/gfx/ZMzM1MjEy.html\" target=\"_blank\" rel=\"external\">设计素材：国内常用社交图标的web字体</a>， 版权归原作者所有。在huno中CSS文件做了些修改。</p>\n</blockquote>\n<p>这套字体和上面<code>Social Icon</code>的设计得并不一样，如果混用，排版效果会略差。例如，在<code>layout/_partials/social.ejs</code>加上：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;li class=&quot;navigation__item&quot;&gt;</div><div class=\"line\">  &lt;a href=&quot;&quot; title=&quot;&quot;&gt;</div><div class=\"line\">    &lt;i class=&apos;icon cs-icon-douban&apos;&gt;&lt;/i&gt;</div><div class=\"line\">    &lt;span class=&quot;label&quot;&gt;Douban&lt;/span&gt;</div><div class=\"line\">  &lt;/a&gt;</div><div class=\"line\">&lt;/li&gt;</div><div class=\"line\"></div><div class=\"line\">&lt;li class=&quot;navigation__item&quot;&gt;</div><div class=\"line\">  &lt;a href=&quot;&quot; title=&quot;&quot;&gt;</div><div class=\"line\">    &lt;i class=&apos;icon cs-icon-weibo&apos;&gt;&lt;/i&gt;</div><div class=\"line\">    &lt;span class=&quot;label&quot;&gt;Weibo&lt;/span&gt;</div><div class=\"line\">  &lt;/a&gt;</div><div class=\"line\">&lt;/li&gt;</div></pre></td></tr></table></figure>\n<p>效果如下：</p>\n<p><img src=\"./cs-icon.png\" alt=\"\"></p>\n<p>字体文件位于<code>source/fonts/china-social/</code>中，对应的css文件是<code>source/css/china-social-icon.css</code>。</p>\n<h2 id=\"网站统计\"><a href=\"#网站统计\" class=\"headerlink\" title=\"网站统计\"></a>网站统计</h2><p>将网站统计（如Google analysis、CNZZ、百度统计等）代码放入<code>layout/_scripts/site-analytics.ejs</code>即可。</p>\n<h2 id=\"如何将Huno生成的静态网站放在某网站子目录\"><a href=\"#如何将Huno生成的静态网站放在某网站子目录\" class=\"headerlink\" title=\"如何将Huno生成的静态网站放在某网站子目录\"></a>如何将Huno生成的静态网站放在某网站子目录</h2><p>例如要将其放入<code>http://hi.letiantian.me/huno/</code>下，则需要：</p>\n<p><strong>修改Hexo配置文件<code>_config.yml</code>:</strong></p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># URL</span></div><div class=\"line\"><span class=\"comment\">## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'</span></div><div class=\"line\"><span class=\"attr\">url:</span> <span class=\"attr\">http://hi.letiantian.me/huno</span></div><div class=\"line\"><span class=\"attr\">root:</span> <span class=\"string\">/huno/</span></div></pre></td></tr></table></figure>\n<p><strong>修改主题的配置文件<code>_config.yml</code>:</strong></p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># Header</span></div><div class=\"line\"><span class=\"attr\">menu:</span></div><div class=\"line\">  <span class=\"string\">首页:</span> <span class=\"string\">/huno/#blog</span></div><div class=\"line\">  <span class=\"string\">关于:</span> <span class=\"string\">/huno/about</span></div><div class=\"line\">  <span class=\"string\">归档:</span> <span class=\"string\">/huno/archive</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># Site favicon</span></div><div class=\"line\"><span class=\"attr\">favicon:</span> <span class=\"string\">/huno/favicon.png</span></div></pre></td></tr></table></figure>\n<p><strong>修改<code>huno/source/js/main.js</code>:</strong></p>\n<p>将</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> (<span class=\"built_in\">window</span>.location.pathname != <span class=\"string\">\"/\"</span>) &#123;</div><div class=\"line\">  $(<span class=\"string\">'.panel-cover'</span>).addClass(<span class=\"string\">'panel-cover--collapsed'</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>修改为</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> (<span class=\"built_in\">window</span>.location.pathname != <span class=\"string\">\"/huno/\"</span>) &#123;</div><div class=\"line\">  $(<span class=\"string\">'.panel-cover'</span>).addClass(<span class=\"string\">'panel-cover--collapsed'</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><strong>修改<code>huno/layout/_partials/side-panel.ejs</code>:</strong></p>\n<p>将</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;% for (var i in theme.menu)&#123; %&gt;</div><div class=\"line\">  &lt;%</div><div class=\"line\">    if (theme.menu[i]+&apos;&apos; == &apos;/#blog&apos;) &#123;</div><div class=\"line\">      nav_btn_class = &apos;blog-button&apos;;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">      nav_btn_class = &apos;&apos;;</div><div class=\"line\">    &#125;</div><div class=\"line\">  %&gt;</div></pre></td></tr></table></figure>\n<p>修改为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;% for (var i in theme.menu)&#123; %&gt;</div><div class=\"line\">  &lt;%</div><div class=\"line\">    if (theme.menu[i]+&apos;&apos; == &apos;/huno/#blog&apos;) &#123;</div><div class=\"line\">      nav_btn_class = &apos;blog-button&apos;;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">      nav_btn_class = &apos;&apos;;</div><div class=\"line\">    &#125;</div><div class=\"line\">  %&gt;</div></pre></td></tr></table></figure>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><p>如果在中国大陆使用该主题后，访问速度变慢，可以考虑注释掉<code>source/css/uno.css</code>的第一行。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"Huno\"><a href=\"#Huno\" class=\"headerlink\" title=\"Huno\"></a>Huno</h1><p>Huno是为<a href=\"http://hexo.io/\" target=\"_blank\" rel=\"external\">Hexo</a>编写的一个响应式的主题，该主题基于<a href=\"https://github.com/daleanthony/uno/\" target=\"_blank\" rel=\"external\">Uno</a>。</p>","more":"<h2 id=\"Demo\"><a href=\"#Demo\" class=\"headerlink\" title=\"Demo\"></a>Demo</h2><p><a href=\"https://yuxiang.ren\">Huno’s demo</a></p>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ git clone git://github.com/someus/huno.git themes/huno</div></pre></td></tr></table></figure>\n<p>修改Hexo的配置文件<code>_config.xml</code>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">theme: huno</div></pre></td></tr></table></figure>\n<h2 id=\"兼容性\"><a href=\"#兼容性\" class=\"headerlink\" title=\"兼容性\"></a>兼容性</h2><p>在Hexo 3.1.1测试正常。</p>\n<h2 id=\"配置示例\"><a href=\"#配置示例\" class=\"headerlink\" title=\"配置示例\"></a>配置示例</h2><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"># Header</div><div class=\"line\">menu:</div><div class=\"line\">  博客: /#blog</div><div class=\"line\">  归档: /archive</div><div class=\"line\">  关于: /about</div><div class=\"line\">  主页: # your home page</div><div class=\"line\"></div><div class=\"line\"># Site favicon</div><div class=\"line\">favicon: /images/favicon.ico</div><div class=\"line\"></div><div class=\"line\"># 头像</div><div class=\"line\">avatar: /images/avatar.jpg</div><div class=\"line\"></div><div class=\"line\"># apple touch icon</div><div class=\"line\">appleTouchIcon: /images/apple-touch-icon.png</div><div class=\"line\"></div><div class=\"line\"># Enable Mathjax</div><div class=\"line\">mathjax: true</div><div class=\"line\"></div><div class=\"line\"># Enable awesome-toc</div><div class=\"line\">awesome_toc: true</div><div class=\"line\"></div><div class=\"line\"># Enable githubRepoWidget</div><div class=\"line\">github_repo_widget: false</div></pre></td></tr></table></figure>\n<p>menu中定义<code>/#blog</code>是必须的，示例中的<code>/about</code>和<code>/archive</code>是两个页面。<code>/archive</code>会在下面的<strong>归档页面</strong>中介绍。</p>\n<p><strong>mathjax:</strong></p>\n<p>数学公式支持。其设置（layout/_scripts/mathjax.ejs）如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">$(document).ready(function()&#123;</div><div class=\"line\">    MathJax.Hub.Config(&#123; </div><div class=\"line\">        tex2jax: &#123;inlineMath: [[&apos;[latex]&apos;,&apos;[/latex]&apos;], [&apos;\\\\(&apos;,&apos;\\\\)&apos;]]&#125; </div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>官网：<a href=\"https://www.mathjax.org/\" target=\"_blank\" rel=\"external\">mathjax</a></p>\n<p><strong>awesome_toc:</strong></p>\n<p>为文章生成目录。</p>\n<p>官网：<a href=\"https://github.com/someus/awesome-toc\" target=\"_blank\" rel=\"external\">awesome-toc</a></p>\n<p><strong>github_repo_widget:</strong></p>\n<p>可视化显示github中的项目。</p>\n<p>官网：<a href=\"https://github.com/JoelSutherland/GitHub-jQuery-Repo-Widget\" target=\"_blank\" rel=\"external\">GitHub-jQuery-Repo-Widget</a></p>\n<h2 id=\"侧边栏图片\"><a href=\"#侧边栏图片\" class=\"headerlink\" title=\"侧边栏图片\"></a>侧边栏图片</h2><p>侧边栏图片URL定义在<code>source/css/uno.css</code>中下面的这段代码中：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.panel-cover</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">display</span>: block;</div><div class=\"line\">  <span class=\"attribute\">position</span>: fixed;</div><div class=\"line\">  <span class=\"attribute\">z-index</span>: <span class=\"number\">900</span>;</div><div class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>;</div><div class=\"line\">  <span class=\"attribute\">max-width</span>: none;</div><div class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">100%</span>;</div><div class=\"line\">  <span class=\"attribute\">background</span>: <span class=\"built_in\">url</span>(../images/background-cover.jpg) top left no-repeat <span class=\"number\">#666666</span>;</div><div class=\"line\">  <span class=\"attribute\">background-size</span>: cover; &#125;</div></pre></td></tr></table></figure>\n<p>可以看出图片路径是<code>source/images/background-cover.jpg</code>。可以根据需要替换成不同的图片，或者修改图片URL。例如修改成CDN中的某个图片（<a href=\"https://github.com/someus/huno/pull/28\" target=\"_blank\" rel=\"external\">#28</a>）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">background: url(&quot;http://ww4.sinaimg.cn/mw690/6a80ef0fgw1fac749wvfij21hc0xch6b.jpg&quot;) top left no-repeat #666666;</div></pre></td></tr></table></figure>\n<h2 id=\"归档页面\"><a href=\"#归档页面\" class=\"headerlink\" title=\"归档页面\"></a>归档页面</h2><p>归档页面会显示分类、标签云以及基于日期的归档。</p>\n<p>在主题的配置文件<code>_config.yml</code>中：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># Header</span></div><div class=\"line\"><span class=\"attr\">menu:</span></div><div class=\"line\">  <span class=\"string\">首页:</span> <span class=\"string\">/#blog</span></div><div class=\"line\">  <span class=\"string\">归档:</span> <span class=\"string\">/archive</span></div><div class=\"line\">  <span class=\"string\">关于:</span> <span class=\"string\">/about</span></div></pre></td></tr></table></figure>\n<p>创建新的page：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo new page archive</div><div class=\"line\">$ cd source/archive</div><div class=\"line\">$ vim index.md</div></pre></td></tr></table></figure>\n<p>内容修改为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">title: 归档</div><div class=\"line\">layout: page-archive</div><div class=\"line\">---</div></pre></td></tr></table></figure>\n<blockquote>\n<p>!! hexo 默认有一个<code>/archives</code>，如果您认为归档页面的url（<code>/archive</code>）和这个冲突，可以选更加合适的名称:blush:。</p>\n</blockquote>\n<h2 id=\"评论\"><a href=\"#评论\" class=\"headerlink\" title=\"评论\"></a>评论</h2><p>支持Disqus和多说，在Hexo配置文件<code>_config.yml</code>中设置名称即可，例如：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># Disqus</span></div><div class=\"line\"><span class=\"attr\">disqus_shortname:</span> <span class=\"string\">letian</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># Duoshuo</span></div><div class=\"line\"><span class=\"attr\">duoshuo_shortname:</span> <span class=\"string\">letian</span></div></pre></td></tr></table></figure>\n<blockquote>\n<p>!!! 如果两个都设置，则两个评论工具都会显示。</p>\n</blockquote>\n<h2 id=\"Social-Icon\"><a href=\"#Social-Icon\" class=\"headerlink\" title=\"Social Icon\"></a>Social Icon</h2><p>默认提供了Github的图标，Github用户名请在Hexo的配置文件<code>_config.yml</code>中配置，例如：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># Social</span></div><div class=\"line\"><span class=\"attr\">social:</span></div><div class=\"line\"><span class=\"attr\">  github:</span> <span class=\"string\">someus</span></div></pre></td></tr></table></figure>\n<p>可以根据需要在<code>layout/_partials/social.ejs</code>中添加更多的图标。</p>\n<h2 id=\"China-Social-Icon\"><a href=\"#China-Social-Icon\" class=\"headerlink\" title=\"China Social Icon\"></a>China Social Icon</h2><blockquote>\n<p>这套字体来自 <a href=\"http://www.zcool.com.cn/gfx/ZMzM1MjEy.html\" target=\"_blank\" rel=\"external\">设计素材：国内常用社交图标的web字体</a>， 版权归原作者所有。在huno中CSS文件做了些修改。</p>\n</blockquote>\n<p>这套字体和上面<code>Social Icon</code>的设计得并不一样，如果混用，排版效果会略差。例如，在<code>layout/_partials/social.ejs</code>加上：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;li class=&quot;navigation__item&quot;&gt;</div><div class=\"line\">  &lt;a href=&quot;&quot; title=&quot;&quot;&gt;</div><div class=\"line\">    &lt;i class=&apos;icon cs-icon-douban&apos;&gt;&lt;/i&gt;</div><div class=\"line\">    &lt;span class=&quot;label&quot;&gt;Douban&lt;/span&gt;</div><div class=\"line\">  &lt;/a&gt;</div><div class=\"line\">&lt;/li&gt;</div><div class=\"line\"></div><div class=\"line\">&lt;li class=&quot;navigation__item&quot;&gt;</div><div class=\"line\">  &lt;a href=&quot;&quot; title=&quot;&quot;&gt;</div><div class=\"line\">    &lt;i class=&apos;icon cs-icon-weibo&apos;&gt;&lt;/i&gt;</div><div class=\"line\">    &lt;span class=&quot;label&quot;&gt;Weibo&lt;/span&gt;</div><div class=\"line\">  &lt;/a&gt;</div><div class=\"line\">&lt;/li&gt;</div></pre></td></tr></table></figure>\n<p>效果如下：</p>\n<p><img src=\"./cs-icon.png\" alt=\"\"></p>\n<p>字体文件位于<code>source/fonts/china-social/</code>中，对应的css文件是<code>source/css/china-social-icon.css</code>。</p>\n<h2 id=\"网站统计\"><a href=\"#网站统计\" class=\"headerlink\" title=\"网站统计\"></a>网站统计</h2><p>将网站统计（如Google analysis、CNZZ、百度统计等）代码放入<code>layout/_scripts/site-analytics.ejs</code>即可。</p>\n<h2 id=\"如何将Huno生成的静态网站放在某网站子目录\"><a href=\"#如何将Huno生成的静态网站放在某网站子目录\" class=\"headerlink\" title=\"如何将Huno生成的静态网站放在某网站子目录\"></a>如何将Huno生成的静态网站放在某网站子目录</h2><p>例如要将其放入<code>http://hi.letiantian.me/huno/</code>下，则需要：</p>\n<p><strong>修改Hexo配置文件<code>_config.yml</code>:</strong></p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># URL</span></div><div class=\"line\"><span class=\"comment\">## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'</span></div><div class=\"line\"><span class=\"attr\">url:</span> <span class=\"attr\">http://hi.letiantian.me/huno</span></div><div class=\"line\"><span class=\"attr\">root:</span> <span class=\"string\">/huno/</span></div></pre></td></tr></table></figure>\n<p><strong>修改主题的配置文件<code>_config.yml</code>:</strong></p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># Header</span></div><div class=\"line\"><span class=\"attr\">menu:</span></div><div class=\"line\">  <span class=\"string\">首页:</span> <span class=\"string\">/huno/#blog</span></div><div class=\"line\">  <span class=\"string\">关于:</span> <span class=\"string\">/huno/about</span></div><div class=\"line\">  <span class=\"string\">归档:</span> <span class=\"string\">/huno/archive</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># Site favicon</span></div><div class=\"line\"><span class=\"attr\">favicon:</span> <span class=\"string\">/huno/favicon.png</span></div></pre></td></tr></table></figure>\n<p><strong>修改<code>huno/source/js/main.js</code>:</strong></p>\n<p>将</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> (<span class=\"built_in\">window</span>.location.pathname != <span class=\"string\">\"/\"</span>) &#123;</div><div class=\"line\">  $(<span class=\"string\">'.panel-cover'</span>).addClass(<span class=\"string\">'panel-cover--collapsed'</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>修改为</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> (<span class=\"built_in\">window</span>.location.pathname != <span class=\"string\">\"/huno/\"</span>) &#123;</div><div class=\"line\">  $(<span class=\"string\">'.panel-cover'</span>).addClass(<span class=\"string\">'panel-cover--collapsed'</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><strong>修改<code>huno/layout/_partials/side-panel.ejs</code>:</strong></p>\n<p>将</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;% for (var i in theme.menu)&#123; %&gt;</div><div class=\"line\">  &lt;%</div><div class=\"line\">    if (theme.menu[i]+&apos;&apos; == &apos;/#blog&apos;) &#123;</div><div class=\"line\">      nav_btn_class = &apos;blog-button&apos;;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">      nav_btn_class = &apos;&apos;;</div><div class=\"line\">    &#125;</div><div class=\"line\">  %&gt;</div></pre></td></tr></table></figure>\n<p>修改为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;% for (var i in theme.menu)&#123; %&gt;</div><div class=\"line\">  &lt;%</div><div class=\"line\">    if (theme.menu[i]+&apos;&apos; == &apos;/huno/#blog&apos;) &#123;</div><div class=\"line\">      nav_btn_class = &apos;blog-button&apos;;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">      nav_btn_class = &apos;&apos;;</div><div class=\"line\">    &#125;</div><div class=\"line\">  %&gt;</div></pre></td></tr></table></figure>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><p>如果在中国大陆使用该主题后，访问速度变慢，可以考虑注释掉<code>source/css/uno.css</code>的第一行。</p>"},{"title":"安装shadowsocks","date":"2017-03-30T06:39:09.000Z","_content":"\n\n\n## 一. 安装\n\n1. 登录你的vps\n\n2. 安装PIP环境\n\n   ```shell\n   apt-get install python-gevent python-pip\n   ```\n\n3. 安装`shadowsocks`\n\n   ```Shell\n   pip install shadowsocks\n   ```\n\n<!-- more -->\n\n##2.  配置信息\n\n1. 创建`config.json`文件\n   * 进入shadowsocks文件夹: `cd /etc/shadowsocks`\n   * 创建配置文件: `touch config.json`\n2. 编辑`config.json`\n* 打开vi编辑器: `vi config.json`\n* 按照下列格式填写配置信息\n ```json\n {\n \"server\":\"123.123.123.123\", # 服务器地址\n \"server_port\":9000, #端口号\n \"local_port\":9000, # 本地端口号\n \"password\":\"123456\", # 密码\n \"timeout\":600, # 超时时间\n \"method\":\"rc4-md5\" # 密码类型\n }\n ```\n\n\n* 保存并且退出\n\n## 三. 开启服务\n\n1. 执行启动服务器: `nohup ssserver -c /etc/shadowsocks/config.json > log &`\n2. 设置开机启动: `/usr/local/bin/ssserver -c /etc/shadowsocks/config.json`","source":"_posts/install-shadowsocks-on-your-vps.md","raw":"---\ntitle: 安装shadowsocks\ndate: 2017-03-30 14:39:09\ncategories: 教程\ntags: [教程 翻墙]\n---\n\n\n\n## 一. 安装\n\n1. 登录你的vps\n\n2. 安装PIP环境\n\n   ```shell\n   apt-get install python-gevent python-pip\n   ```\n\n3. 安装`shadowsocks`\n\n   ```Shell\n   pip install shadowsocks\n   ```\n\n<!-- more -->\n\n##2.  配置信息\n\n1. 创建`config.json`文件\n   * 进入shadowsocks文件夹: `cd /etc/shadowsocks`\n   * 创建配置文件: `touch config.json`\n2. 编辑`config.json`\n* 打开vi编辑器: `vi config.json`\n* 按照下列格式填写配置信息\n ```json\n {\n \"server\":\"123.123.123.123\", # 服务器地址\n \"server_port\":9000, #端口号\n \"local_port\":9000, # 本地端口号\n \"password\":\"123456\", # 密码\n \"timeout\":600, # 超时时间\n \"method\":\"rc4-md5\" # 密码类型\n }\n ```\n\n\n* 保存并且退出\n\n## 三. 开启服务\n\n1. 执行启动服务器: `nohup ssserver -c /etc/shadowsocks/config.json > log &`\n2. 设置开机启动: `/usr/local/bin/ssserver -c /etc/shadowsocks/config.json`","slug":"install-shadowsocks-on-your-vps","published":1,"updated":"2017-04-28T08:38:42.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6686xma001jxe9z2ijqx018","content":"<h2 id=\"一-安装\"><a href=\"#一-安装\" class=\"headerlink\" title=\"一. 安装\"></a>一. 安装</h2><ol>\n<li><p>登录你的vps</p>\n</li>\n<li><p>安装PIP环境</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">apt-get install python-gevent python-pip</div></pre></td></tr></table></figure>\n</li>\n<li><p>安装<code>shadowsocks</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">pip install shadowsocks</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<a id=\"more\"></a>\n<p>##2.  配置信息</p>\n<ol>\n<li>创建<code>config.json</code>文件<ul>\n<li>进入shadowsocks文件夹: <code>cd /etc/shadowsocks</code></li>\n<li>创建配置文件: <code>touch config.json</code></li>\n</ul>\n</li>\n<li>编辑<code>config.json</code></li>\n</ol>\n<ul>\n<li>打开vi编辑器: <code>vi config.json</code></li>\n<li><p>按照下列格式填写配置信息</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">\"server\":\"123.123.123.123\", # 服务器地址</div><div class=\"line\">\"server_port\":9000, #端口号</div><div class=\"line\">\"local_port\":9000, # 本地端口号</div><div class=\"line\">\"password\":\"123456\", # 密码</div><div class=\"line\">\"timeout\":600, # 超时时间</div><div class=\"line\">\"method\":\"rc4-md5\" # 密码类型</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>保存并且退出</p>\n</li>\n</ul>\n<h2 id=\"三-开启服务\"><a href=\"#三-开启服务\" class=\"headerlink\" title=\"三. 开启服务\"></a>三. 开启服务</h2><ol>\n<li>执行启动服务器: <code>nohup ssserver -c /etc/shadowsocks/config.json &gt; log &amp;</code></li>\n<li>设置开机启动: <code>/usr/local/bin/ssserver -c /etc/shadowsocks/config.json</code></li>\n</ol>\n","site":{"data":{}},"excerpt":"<h2 id=\"一-安装\"><a href=\"#一-安装\" class=\"headerlink\" title=\"一. 安装\"></a>一. 安装</h2><ol>\n<li><p>登录你的vps</p>\n</li>\n<li><p>安装PIP环境</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">apt-get install python-gevent python-pip</div></pre></td></tr></table></figure>\n</li>\n<li><p>安装<code>shadowsocks</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">pip install shadowsocks</div></pre></td></tr></table></figure>\n</li>\n</ol>","more":"<p>##2.  配置信息</p>\n<ol>\n<li>创建<code>config.json</code>文件<ul>\n<li>进入shadowsocks文件夹: <code>cd /etc/shadowsocks</code></li>\n<li>创建配置文件: <code>touch config.json</code></li>\n</ul>\n</li>\n<li>编辑<code>config.json</code></li>\n</ol>\n<ul>\n<li>打开vi编辑器: <code>vi config.json</code></li>\n<li><p>按照下列格式填写配置信息</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">\"server\":\"123.123.123.123\", # 服务器地址</div><div class=\"line\">\"server_port\":9000, #端口号</div><div class=\"line\">\"local_port\":9000, # 本地端口号</div><div class=\"line\">\"password\":\"123456\", # 密码</div><div class=\"line\">\"timeout\":600, # 超时时间</div><div class=\"line\">\"method\":\"rc4-md5\" # 密码类型</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>保存并且退出</p>\n</li>\n</ul>\n<h2 id=\"三-开启服务\"><a href=\"#三-开启服务\" class=\"headerlink\" title=\"三. 开启服务\"></a>三. 开启服务</h2><ol>\n<li>执行启动服务器: <code>nohup ssserver -c /etc/shadowsocks/config.json &gt; log &amp;</code></li>\n<li>设置开机启动: <code>/usr/local/bin/ssserver -c /etc/shadowsocks/config.json</code></li>\n</ol>"},{"title":"javaScript基础","date":"2017-05-22T01:00:05.000Z","_content":"\n# 一、函数\n\n##  1. 函数的定义\n\n1. 使用`function`定义\n\n   ```javascript\n   function fun() {\n     alert(\"hello world\");\n   }\n   ```\n\n2. 匿名函数的方式\n\n   ```javascript\n   // 定义函数\n   var fun = function() {\n     alert(\"hello wordl\");\n   }\n   // 执行\n   fun();\n   ```\n\n3. `new Function`(不常用)\n\n   ```javascript\n   var fun = new Function(\"msg\", \"alert(msg)\");\n   fun(\"hello world\");\n   ```\n\n4. 函数调用\n\n   * 调用函数的时候是通过函数名调用的,\n   * 定义函数的时候不能聪明.\n\n<!-- more -->\n\n## 2. 函数劫持\n\n改变`javascript`的函数预定义好的功能\n\n```javascript\nwindow.alert = function(msg) {\n  \tdocument.write(msg)\n}\nalert(\"hello world\");\n```\n\n## 3. 全局函数\n\n1. `isNaN`: 是不是一个数字, 返回true不是数字\n2. `parseInt`, `parsetFloat`\n3. `eval`: \n   * 主要执行字符串,奖结果转换为数字\n   * 将`json`格式的字符串转换为`json`\n\n# \n\n","source":"_posts/javaScript基础.md","raw":"---\ntitle: javaScript基础\ndate: 2017-05-22 09:00:05\ncategories: HTMl\ntags: javaScript html\n---\n\n# 一、函数\n\n##  1. 函数的定义\n\n1. 使用`function`定义\n\n   ```javascript\n   function fun() {\n     alert(\"hello world\");\n   }\n   ```\n\n2. 匿名函数的方式\n\n   ```javascript\n   // 定义函数\n   var fun = function() {\n     alert(\"hello wordl\");\n   }\n   // 执行\n   fun();\n   ```\n\n3. `new Function`(不常用)\n\n   ```javascript\n   var fun = new Function(\"msg\", \"alert(msg)\");\n   fun(\"hello world\");\n   ```\n\n4. 函数调用\n\n   * 调用函数的时候是通过函数名调用的,\n   * 定义函数的时候不能聪明.\n\n<!-- more -->\n\n## 2. 函数劫持\n\n改变`javascript`的函数预定义好的功能\n\n```javascript\nwindow.alert = function(msg) {\n  \tdocument.write(msg)\n}\nalert(\"hello world\");\n```\n\n## 3. 全局函数\n\n1. `isNaN`: 是不是一个数字, 返回true不是数字\n2. `parseInt`, `parsetFloat`\n3. `eval`: \n   * 主要执行字符串,奖结果转换为数字\n   * 将`json`格式的字符串转换为`json`\n\n# \n\n","slug":"javaScript基础","published":1,"updated":"2017-05-22T02:37:01.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6686xmf001mxe9zyxagdft3","content":"<h1 id=\"一、函数\"><a href=\"#一、函数\" class=\"headerlink\" title=\"一、函数\"></a>一、函数</h1><h2 id=\"1-函数的定义\"><a href=\"#1-函数的定义\" class=\"headerlink\" title=\"1. 函数的定义\"></a>1. 函数的定义</h2><ol>\n<li><p>使用<code>function</code>定义</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fun</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  alert(<span class=\"string\">\"hello world\"</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>匿名函数的方式</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 定义函数</span></div><div class=\"line\"><span class=\"keyword\">var</span> fun = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  alert(<span class=\"string\">\"hello wordl\"</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// 执行</span></div><div class=\"line\">fun();</div></pre></td></tr></table></figure>\n</li>\n<li><p><code>new Function</code>(不常用)</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> fun = <span class=\"keyword\">new</span> <span class=\"built_in\">Function</span>(<span class=\"string\">\"msg\"</span>, <span class=\"string\">\"alert(msg)\"</span>);</div><div class=\"line\">fun(<span class=\"string\">\"hello world\"</span>);</div></pre></td></tr></table></figure>\n</li>\n<li><p>函数调用</p>\n<ul>\n<li>调用函数的时候是通过函数名调用的,</li>\n<li>定义函数的时候不能聪明.</li>\n</ul>\n</li>\n</ol>\n<a id=\"more\"></a>\n<h2 id=\"2-函数劫持\"><a href=\"#2-函数劫持\" class=\"headerlink\" title=\"2. 函数劫持\"></a>2. 函数劫持</h2><p>改变<code>javascript</code>的函数预定义好的功能</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">window</span>.alert = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">msg</span>) </span>&#123;</div><div class=\"line\">  \t<span class=\"built_in\">document</span>.write(msg)</div><div class=\"line\">&#125;</div><div class=\"line\">alert(<span class=\"string\">\"hello world\"</span>);</div></pre></td></tr></table></figure>\n<h2 id=\"3-全局函数\"><a href=\"#3-全局函数\" class=\"headerlink\" title=\"3. 全局函数\"></a>3. 全局函数</h2><ol>\n<li><code>isNaN</code>: 是不是一个数字, 返回true不是数字</li>\n<li><code>parseInt</code>, <code>parsetFloat</code></li>\n<li><code>eval</code>: <ul>\n<li>主要执行字符串,奖结果转换为数字</li>\n<li>将<code>json</code>格式的字符串转换为<code>json</code></li>\n</ul>\n</li>\n</ol>\n<p># </p>\n","site":{"data":{}},"excerpt":"<h1 id=\"一、函数\"><a href=\"#一、函数\" class=\"headerlink\" title=\"一、函数\"></a>一、函数</h1><h2 id=\"1-函数的定义\"><a href=\"#1-函数的定义\" class=\"headerlink\" title=\"1. 函数的定义\"></a>1. 函数的定义</h2><ol>\n<li><p>使用<code>function</code>定义</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fun</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  alert(<span class=\"string\">\"hello world\"</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>匿名函数的方式</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 定义函数</span></div><div class=\"line\"><span class=\"keyword\">var</span> fun = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  alert(<span class=\"string\">\"hello wordl\"</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// 执行</span></div><div class=\"line\">fun();</div></pre></td></tr></table></figure>\n</li>\n<li><p><code>new Function</code>(不常用)</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> fun = <span class=\"keyword\">new</span> <span class=\"built_in\">Function</span>(<span class=\"string\">\"msg\"</span>, <span class=\"string\">\"alert(msg)\"</span>);</div><div class=\"line\">fun(<span class=\"string\">\"hello world\"</span>);</div></pre></td></tr></table></figure>\n</li>\n<li><p>函数调用</p>\n<ul>\n<li>调用函数的时候是通过函数名调用的,</li>\n<li>定义函数的时候不能聪明.</li>\n</ul>\n</li>\n</ol>","more":"<h2 id=\"2-函数劫持\"><a href=\"#2-函数劫持\" class=\"headerlink\" title=\"2. 函数劫持\"></a>2. 函数劫持</h2><p>改变<code>javascript</code>的函数预定义好的功能</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">window</span>.alert = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">msg</span>) </span>&#123;</div><div class=\"line\">  \t<span class=\"built_in\">document</span>.write(msg)</div><div class=\"line\">&#125;</div><div class=\"line\">alert(<span class=\"string\">\"hello world\"</span>);</div></pre></td></tr></table></figure>\n<h2 id=\"3-全局函数\"><a href=\"#3-全局函数\" class=\"headerlink\" title=\"3. 全局函数\"></a>3. 全局函数</h2><ol>\n<li><code>isNaN</code>: 是不是一个数字, 返回true不是数字</li>\n<li><code>parseInt</code>, <code>parsetFloat</code></li>\n<li><code>eval</code>: <ul>\n<li>主要执行字符串,奖结果转换为数字</li>\n<li>将<code>json</code>格式的字符串转换为<code>json</code></li>\n</ul>\n</li>\n</ol>\n<p># </p>"},{"title":"learn Android","date":"2017-02-09T08:59:49.000Z","_content":"\n\n\nNow learning Android ….\n\n<!-- more -->\n","source":"_posts/learn-Android.md","raw":"---\ntitle: learn Android\ndate: 2017-02-09 16:59:49\ncategories: Android\ntags: Android\n---\n\n\n\nNow learning Android ….\n\n<!-- more -->\n","slug":"learn-Android","published":1,"updated":"2017-02-09T09:01:37.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6686xmh001pxe9z7x7lwntb","content":"<p>Now learning Android ….</p>\n<a id=\"more\"></a>\n","site":{"data":{}},"excerpt":"<p>Now learning Android ….</p>","more":""},{"title":"linux常用命令","date":"2017-03-31T06:32:42.000Z","_content":"\n### 一. 系统清理\n1. clean命令删除所有的软件安装包\n\n   * 在网络连接正常的情况下，我们执行软件安装命令，软件安装结束后，以 .deb 为后缀的软件包就不再需要了。所以要对他定期清理\n\n     ```shell\n     sudo apt-get clean\n     ```\n\n   * 使用上面命令即可上错所有的软件包\n\n2. autoclean 删除不再可用的安装包\n\n   - 与`clean`一样, 只不过它有选择地删除软件包：那些不再可用的安装包(比如，你再也不能够从软件仓库中下载到该软件包的当前版本、或更新版本)。\n\n     ```shell\n     sudo apt-get autoclean\n     ```\n\n   <!-- more -->\n\n3. remove 删除特定软件\n\n   ```shell\n   sudo apt-get remove\n   ```\n\n4. purge清除软件残余\n\n   * purge 命令是 remove 命令的另一个版本，它可以在删除软件本身的同时，删除软件包的残余设置。\n\n     ```shell\n     sudo apt-get purge 软件名\n     ```\n\n5. autoremove 删除不需要的依赖包\n\n   ```shell\n   sudo apt-get autoremove\n   ```\n\n### 二. 磁盘相关命令\n\n1. `df -lh`\n\n   * 通过这个命令可以查看磁盘的使用情况以及文件系统被挂载的位置\n\n     ![](https://ww4.sinaimg.cn/large/006tNc79gy1fe60rpiwfkj30li0860uk.jpg)\n\n2. `fdisk -l ` 查看分区信息\n\n   * 下图表示一块16G的硬盘\n\n     ![](https://ww2.sinaimg.cn/large/006tNc79gy1fe60v7gzrnj30qu08u0v8.jpg)\n\n3. 查看某目录下占用空间最多的文件或目录\n\n   * 取前10个。需要先进入该目录下\n\n     ```shell\n     du -cks * | sort -rn | head -n 10\n     ```\n\n4. 查看某一目录大小:\n\n   ```shell\n   du -sh\n   ```\n\n\n## 三.  GIT相关\n\n1. 创建一个tag\n\n   ```shell\n   git tag <标签名> -m \"commit message\"\n   ```\n\n2. 提交tag\n\n   ```Shell\n   git push ---tags #将本地所有标签一次性提交到git服务器\n   git push <标签名> #将指定标签提交到git服务器\n   ```\n\n3. 删除一个tag\n\n   ```shell\n   git tag -d <标签名>\n   ```\n\n4. 删除远程标签\n\n   ```shell\n   git push origin :<标签名>\n   ```\n\n5. 查看所有标签\n\n   ```shell\n   git tag\n   ```\n\n6. `git warning: LF will be replaced by CRLF in `解决办法\n\n   ```shell\n   git config core.autocrlf false\n   ```\n\n","source":"_posts/linux常用命令.md","raw":"---\ntitle: linux常用命令\ndate: 2017-03-31 14:32:42\ncategories: 命令\ntags: 命令\n---\n\n### 一. 系统清理\n1. clean命令删除所有的软件安装包\n\n   * 在网络连接正常的情况下，我们执行软件安装命令，软件安装结束后，以 .deb 为后缀的软件包就不再需要了。所以要对他定期清理\n\n     ```shell\n     sudo apt-get clean\n     ```\n\n   * 使用上面命令即可上错所有的软件包\n\n2. autoclean 删除不再可用的安装包\n\n   - 与`clean`一样, 只不过它有选择地删除软件包：那些不再可用的安装包(比如，你再也不能够从软件仓库中下载到该软件包的当前版本、或更新版本)。\n\n     ```shell\n     sudo apt-get autoclean\n     ```\n\n   <!-- more -->\n\n3. remove 删除特定软件\n\n   ```shell\n   sudo apt-get remove\n   ```\n\n4. purge清除软件残余\n\n   * purge 命令是 remove 命令的另一个版本，它可以在删除软件本身的同时，删除软件包的残余设置。\n\n     ```shell\n     sudo apt-get purge 软件名\n     ```\n\n5. autoremove 删除不需要的依赖包\n\n   ```shell\n   sudo apt-get autoremove\n   ```\n\n### 二. 磁盘相关命令\n\n1. `df -lh`\n\n   * 通过这个命令可以查看磁盘的使用情况以及文件系统被挂载的位置\n\n     ![](https://ww4.sinaimg.cn/large/006tNc79gy1fe60rpiwfkj30li0860uk.jpg)\n\n2. `fdisk -l ` 查看分区信息\n\n   * 下图表示一块16G的硬盘\n\n     ![](https://ww2.sinaimg.cn/large/006tNc79gy1fe60v7gzrnj30qu08u0v8.jpg)\n\n3. 查看某目录下占用空间最多的文件或目录\n\n   * 取前10个。需要先进入该目录下\n\n     ```shell\n     du -cks * | sort -rn | head -n 10\n     ```\n\n4. 查看某一目录大小:\n\n   ```shell\n   du -sh\n   ```\n\n\n## 三.  GIT相关\n\n1. 创建一个tag\n\n   ```shell\n   git tag <标签名> -m \"commit message\"\n   ```\n\n2. 提交tag\n\n   ```Shell\n   git push ---tags #将本地所有标签一次性提交到git服务器\n   git push <标签名> #将指定标签提交到git服务器\n   ```\n\n3. 删除一个tag\n\n   ```shell\n   git tag -d <标签名>\n   ```\n\n4. 删除远程标签\n\n   ```shell\n   git push origin :<标签名>\n   ```\n\n5. 查看所有标签\n\n   ```shell\n   git tag\n   ```\n\n6. `git warning: LF will be replaced by CRLF in `解决办法\n\n   ```shell\n   git config core.autocrlf false\n   ```\n\n","slug":"linux常用命令","published":1,"updated":"2017-04-14T06:34:47.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6686xmj001sxe9z8xjno3fe","content":"<h3 id=\"一-系统清理\"><a href=\"#一-系统清理\" class=\"headerlink\" title=\"一. 系统清理\"></a>一. 系统清理</h3><ol>\n<li><p>clean命令删除所有的软件安装包</p>\n<ul>\n<li><p>在网络连接正常的情况下，我们执行软件安装命令，软件安装结束后，以 .deb 为后缀的软件包就不再需要了。所以要对他定期清理</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo apt-get clean</div></pre></td></tr></table></figure>\n</li>\n<li><p>使用上面命令即可上错所有的软件包</p>\n</li>\n</ul>\n</li>\n<li><p>autoclean 删除不再可用的安装包</p>\n<ul>\n<li><p>与<code>clean</code>一样, 只不过它有选择地删除软件包：那些不再可用的安装包(比如，你再也不能够从软件仓库中下载到该软件包的当前版本、或更新版本)。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo apt-get autoclean</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<a id=\"more\"></a>\n</li>\n<li><p>remove 删除特定软件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo apt-get remove</div></pre></td></tr></table></figure>\n</li>\n<li><p>purge清除软件残余</p>\n<ul>\n<li><p>purge 命令是 remove 命令的另一个版本，它可以在删除软件本身的同时，删除软件包的残余设置。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo apt-get purge 软件名</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>autoremove 删除不需要的依赖包</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo apt-get autoremove</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"二-磁盘相关命令\"><a href=\"#二-磁盘相关命令\" class=\"headerlink\" title=\"二. 磁盘相关命令\"></a>二. 磁盘相关命令</h3><ol>\n<li><p><code>df -lh</code></p>\n<ul>\n<li><p>通过这个命令可以查看磁盘的使用情况以及文件系统被挂载的位置</p>\n<p><img src=\"https://ww4.sinaimg.cn/large/006tNc79gy1fe60rpiwfkj30li0860uk.jpg\" alt=\"\"></p>\n</li>\n</ul>\n</li>\n<li><p><code>fdisk -l</code> 查看分区信息</p>\n<ul>\n<li><p>下图表示一块16G的硬盘</p>\n<p><img src=\"https://ww2.sinaimg.cn/large/006tNc79gy1fe60v7gzrnj30qu08u0v8.jpg\" alt=\"\"></p>\n</li>\n</ul>\n</li>\n<li><p>查看某目录下占用空间最多的文件或目录</p>\n<ul>\n<li><p>取前10个。需要先进入该目录下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">du -cks * | sort -rn | head -n 10</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>查看某一目录大小:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">du -sh</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"三-GIT相关\"><a href=\"#三-GIT相关\" class=\"headerlink\" title=\"三.  GIT相关\"></a>三.  GIT相关</h2><ol>\n<li><p>创建一个tag</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git tag &lt;标签名&gt; -m &quot;commit message&quot;</div></pre></td></tr></table></figure>\n</li>\n<li><p>提交tag</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">git push ---tags #将本地所有标签一次性提交到git服务器</div><div class=\"line\">git push &lt;标签名&gt; #将指定标签提交到git服务器</div></pre></td></tr></table></figure>\n</li>\n<li><p>删除一个tag</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git tag -d &lt;标签名&gt;</div></pre></td></tr></table></figure>\n</li>\n<li><p>删除远程标签</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git push origin :&lt;标签名&gt;</div></pre></td></tr></table></figure>\n</li>\n<li><p>查看所有标签</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git tag</div></pre></td></tr></table></figure>\n</li>\n<li><p><code>git warning: LF will be replaced by CRLF in</code>解决办法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git config core.autocrlf false</div></pre></td></tr></table></figure>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"<h3 id=\"一-系统清理\"><a href=\"#一-系统清理\" class=\"headerlink\" title=\"一. 系统清理\"></a>一. 系统清理</h3><ol>\n<li><p>clean命令删除所有的软件安装包</p>\n<ul>\n<li><p>在网络连接正常的情况下，我们执行软件安装命令，软件安装结束后，以 .deb 为后缀的软件包就不再需要了。所以要对他定期清理</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo apt-get clean</div></pre></td></tr></table></figure>\n</li>\n<li><p>使用上面命令即可上错所有的软件包</p>\n</li>\n</ul>\n</li>\n<li><p>autoclean 删除不再可用的安装包</p>\n<ul>\n<li><p>与<code>clean</code>一样, 只不过它有选择地删除软件包：那些不再可用的安装包(比如，你再也不能够从软件仓库中下载到该软件包的当前版本、或更新版本)。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo apt-get autoclean</div></pre></td></tr></table></figure>\n</li>\n</ul>","more":"</li>\n<li><p>remove 删除特定软件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo apt-get remove</div></pre></td></tr></table></figure>\n</li>\n<li><p>purge清除软件残余</p>\n<ul>\n<li><p>purge 命令是 remove 命令的另一个版本，它可以在删除软件本身的同时，删除软件包的残余设置。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo apt-get purge 软件名</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>autoremove 删除不需要的依赖包</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo apt-get autoremove</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"二-磁盘相关命令\"><a href=\"#二-磁盘相关命令\" class=\"headerlink\" title=\"二. 磁盘相关命令\"></a>二. 磁盘相关命令</h3><ol>\n<li><p><code>df -lh</code></p>\n<ul>\n<li><p>通过这个命令可以查看磁盘的使用情况以及文件系统被挂载的位置</p>\n<p><img src=\"https://ww4.sinaimg.cn/large/006tNc79gy1fe60rpiwfkj30li0860uk.jpg\" alt=\"\"></p>\n</li>\n</ul>\n</li>\n<li><p><code>fdisk -l</code> 查看分区信息</p>\n<ul>\n<li><p>下图表示一块16G的硬盘</p>\n<p><img src=\"https://ww2.sinaimg.cn/large/006tNc79gy1fe60v7gzrnj30qu08u0v8.jpg\" alt=\"\"></p>\n</li>\n</ul>\n</li>\n<li><p>查看某目录下占用空间最多的文件或目录</p>\n<ul>\n<li><p>取前10个。需要先进入该目录下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">du -cks * | sort -rn | head -n 10</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>查看某一目录大小:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">du -sh</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"三-GIT相关\"><a href=\"#三-GIT相关\" class=\"headerlink\" title=\"三.  GIT相关\"></a>三.  GIT相关</h2><ol>\n<li><p>创建一个tag</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git tag &lt;标签名&gt; -m &quot;commit message&quot;</div></pre></td></tr></table></figure>\n</li>\n<li><p>提交tag</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">git push ---tags #将本地所有标签一次性提交到git服务器</div><div class=\"line\">git push &lt;标签名&gt; #将指定标签提交到git服务器</div></pre></td></tr></table></figure>\n</li>\n<li><p>删除一个tag</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git tag -d &lt;标签名&gt;</div></pre></td></tr></table></figure>\n</li>\n<li><p>删除远程标签</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git push origin :&lt;标签名&gt;</div></pre></td></tr></table></figure>\n</li>\n<li><p>查看所有标签</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git tag</div></pre></td></tr></table></figure>\n</li>\n<li><p><code>git warning: LF will be replaced by CRLF in</code>解决办法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git config core.autocrlf false</div></pre></td></tr></table></figure>\n</li>\n</ol>"},{"title":"runtime","date":"2016-03-26T13:19:40.000Z","_content":"\n## runtime简介\n1. Runtime简称运行时,OC就是`运行时机制`,也就是在运行时候的一些机制,其中最主要的是消息机制.\n2. 对于C语言,`函数的调用在编译的时候回决定调用哪个函数`.\n3. 对于OC的函数,属于`动态调用过程`,在编译的时候并不能决定真正调用哪个函数,只要在真正运行的时候才会根据函数的名称找到对应的函数来调用.\n4. 事实证明:\n* 在编译阶段,CO可以`调用任何函数`,即使这个函数未实现,只要声明过就不会报错.\n* 在编译阶段,C语言调用`未实现的函数就会报错`.\n\n<!-- more -->\n## runtime作用\n### 发送消息\n*  方法调用的本质,就是让对象发送消息.\n* `objc_msgSeng`:只有对象才能发送消息,因此以`objc`开头.\n* 使用`消息机制`前提,必须要导入`<objc/message.h>`文件.\n* 消息机制的简单使用\n  * clang -rewrite-objc main.m 查看最终生成代码\n\n   ```objc\n     Person *p = [[Person alloc] init];\n     // 调用对象方法\n     [p eat];\n     objc_msgSend(p, @selector(eat));// 本质：让对象发送消息\n\n     // 调用类方法的方式：两种\n     // 第一种通过类名调用\n     [Person eat];\n     // 第二种通过类对象调用\n     [[Person class] eat];\n\n     // 用类名调用类方法，底层会自动把类名转换成类对象调用\n     // 本质：让类对象发送消息\n     objc_msgSend([Person class], @selector(eat));\n   ```\n  * 消息机制原理:对象根据方法编号`SEL`去映射表查找对应的方法实现\n\n### 交换方法\n*  开发使用场景:系统自带的方法功能不够,给系统自带的方法扩张一些功能,并且保持原有的功能.\n* 方式一:继承系统的类,重写方法.\n* 方式二:使用runtime,交换方法\n\n  ```objc\n  @implementation ViewController\n  - (void)viewDidLoad \n  {\n     [super viewDidLoad];\n     // 需求：给imageNamed方法提供功能，每次加载图片就判断下图片是否加载成功。\n     // 步骤一：先搞个分类，定义一个能加载图片并且能打印的方法\n     //+ (instancetype)imageWithName:(NSString *)name;\n     // 步骤二：交换imageNamed和imageWithName的实现，就能调用imageWithName，间接调用imageWithName的实现。\n     UIImage *image = [UIImage imageNamed:@\"123\"];\n  }\n  @end\n  ```\n ```\n\n ```objc\n @implementation UIImage (Image)\n // 加载分类到内存的时候调用\n + (void)load\n {\n    // 交换方法\n    // 获取imageWithName方法地址\n    Method imageWithName = class_getClassMethod(self,  @selector(imageWithName:));\n    // 获取imageWithName方法地址\n    Method imageName = class_getClassMethod(self, @selector(imageNamed:));\n    // 交换方法地址，相当于交换实现方式\n    method_exchangeImplementations(imageWithName, imageName);\n }\n\n   // 不能在分类中重写系统方法imageNamed，因为会把系统的功能给覆盖掉，而且分类中不能调用super.\n   // 既能加载图片又能打印\n + (instancetype)imageWithName:(NSString *)name\n {\n    // 这里调用imageWithName，相当于调用imageName\n    UIImage *image = [self imageWithName:name];\n    if (image == nil) \n    {\n        NSLog(@\"加载空的图片\");\n    }\n    return image;\n }\n ```\n\n### 动态添加方法\n*  开发使用场景:如果一个类方法非常多,加载类到内存的时候也比较耗费资源,需给每个方法生成映射表,可以使用动态给某个类添加方法解决.\n* 经典面试题:有没有使用过performSelector,其实主要实现问你有没有动态添加过方法.\n* 简单使用.\n\n  ```objc\n  - (void)viewDidLoad {\n    [super viewDidLoad];\n    Person *p = [[Person alloc] init];\n\n    // 默认person，没有实现eat方法，可以通过performSelector调用，但是会报错。\n    // 动态添加方法就不会报错\n    [p performSelector:@selector(eat)];\n  }\n  ```\n  ```objc\n    @implementation Person\n    // void(*)()\n    // 默认方法都有两个隐式参数，\n    void eat(id self,SEL sel)\n    {\n        NSLog(@\"%@ %@\",self,NSStringFromSelector(sel));\n    }\n\n    // 当一个对象调用未实现的方法，会调用这个方法处理,并且会把对应的方法列表传过来.\n    // 刚好可以用来判断，未实现的方法是不是我们想要动态添加的方法\n     + (BOOL)resolveInstanceMethod:(SEL)sel\n     {\n        if (sel == @selector(eat)) \n        {\n            /* \n                动态添加eat方法\n                 第一个参数：给哪个类添加方法\n                 第二个参数：添加方法的方法编号\n                 第三个参数：添加方法的函数实现（函数地址）\n                 第四个参数：函数的类型，(返回值+参数类型) v:void @:对象->self :表示SEL->_cmd\n             */\n            class_addMethod(self, @selector(eat), eat, \"v@:\");\n        }\n        \n        return [super resolveInstanceMethod:sel];\n     }\n     @end\n  ```\n\n### 给分类添加属性\n*   原理:给一个类声明属性,其实本质就是给这个类添加关联,并不是直接把这个值得内存空间添加到类的空间.\n\n  ```objc\n  - (void)viewDidLoad \n  {\n        [super viewDidLoad];\n        // 给系统NSObject类动态添加属性name\n        NSObject *objc = [[NSObject alloc] init];\n        objc.name = @\"jen\";\n        NSLog(@\"%@\",objc.name);\n  }\n  ```\n ```\n ```objc\n @implementation NSObject (Property)\n static const char *key = \"name\";// 定义关联的key\n - (NSString *)name\n {\n      // 根据关联的key，获取关联的值。\n      return objc_getAssociatedObject(self, key);\n  }\n    \n  - (void)setName:(NSString *)name\n  {\n      // 第一个参数：给哪个对象添加关联\n      // 第二个参数：关联的key，通过这个key获取\n      // 第三个参数：关联的value\n      // 第四个参数:关联的策略\n      objc_setAssociatedObject(self, key, name, OBJC_ASSOCIATION_RETAIN_NONATOMIC);\n }\n @end\n ```\n\n### 字典转模型\n*  设计模型:字典转模型的第一步\n  * 模型属性,通常需要跟字典中的key一一对应\n  * 问题:一个一个的生成模型属性?很慢!\n  * 需求:能不能自动根据一个字典,生成对应的属性.\n  * 解决:提供一个分类,专门根据字典生成对应属性的字符串.\n\n   ```objc\n    // 自动打印属性字符串\n    + (void)resolveDict:(NSDictionary *)dict\n    {\n        // 拼接属性字符串代码\n        NSMutableString *strM = [NSMutableString string];\n\n        // 1.遍历字典，把字典中的所有key取出来，生成对应的属性代码\n        [dict   enumerateKeysAndObjectsUsingBlock:^(id  _Nonnull key, id  _Nonnull obj, BOOL * _Nonnull stop) {\n            // 类型经常变，抽出来\n            NSString *type = nil;\n            if ([obj isKindOfClass:NSClassFromString(@\"__NSCFString\")]) \n            {\n                type = @\"NSString\";\n            }\n            else if ([obj isKindOfClass:NSClassFromString(@\"__NSCFArray\")])\n            {\n                type = @\"NSArray\";\n            }\n            else if ([obj isKindOfClass:NSClassFromString(@\"__NSCFNumber\")])\n            {\n                type = @\"int\";\n            }\n            else if ([obj isKindOfClass:NSClassFromString(@\"__NSCFDictionary\")])\n            {\n                type = @\"NSDictionary\";\n            }\n\n            // 属性字符串\n            NSString *str = nil;\n            if ([type containsString:@\"NS\"])\n            {\n                str = [NSString stringWithFormat:@\"@property (nonatomic, strong) %@ *%@;\",type,key];\n            }\n            else\n            {\n                str = [NSString stringWithFormat:@\"@property (nonatomic, assign) %@ %@;\",type,key];\n            }\n            // 每生成属性字符串，就自动换行。\n            [strM appendFormat:@\"\\n%@\\n\",str];\n        }];\n        NSLog(@\"%@\",strM);\n    }\n   ```\n\n#### 字典转模型的方式一:KVC    \n```objc\n+ (instancetype)statusWithDict:(NSDictionary *)dict\n{\n    Status *status = [[self alloc] init];\n    [status setValuesForKeysWithDictionary:dict];\n    return status;\n}\n```\n* KVC字典转模型的弊端:必须保证模型中的属性和字典中的key一一对应\n* 如果不一致,就会调用`[<Status 0x7fa74b545d60> setValue:forUndefinedKey:]`方法,报`key`找不到\n* 分析:模型中的属性和字典的key不一一对应,系统就会调用`setValue:forUndefinedKey:`报错.\n* 解决:重写对象的`setValue:forUndefinedKey:`把系统的方法覆盖,就能继续使用KVC字典转模型了\n\n     ```objc\n       - (void)setValue:(id)value forUndefinedKey:(NSString *)key\n       {\n       }\n     ```\n\n#### 字典转模型方式二:runtime\n*   思路:利用运行时 便利模型中所有属性,根据属性名,去字典中查找key,取出对应的值,给模型属性赋值.\n  * 步骤:提供一个`NSObject`分类,专门字典转模型,以后所有模型都可以通过这个分类转.\n    ​    \n   ```objc\n   - (void)viewDidLoad \n   {\n        [super viewDidLoad];\n        \n        // 解析Plist文件\n        NSString *filePath = [[NSBundle mainBundle] pathForResource:@\"status.plist\" ofType:nil];\n        NSDictionary *statusDict = [NSDictionary dictionaryWithContentsOfFile:filePath];\n\n        // 获取字典数组\n        NSArray *dictArr = statusDict[@\"statuses\"];\n        \n        // 自动生成模型的属性字符串\n        [NSObject resolveDict:dictArr[0][@\"user\"]];\n        _statuses = [NSMutableArray array];\n        \n        // 遍历字典数组\n        for (NSDictionary *dict in dictArr) \n        {\n            Status *status = [Status modelWithDict:dict]; \n            [_statuses addObject:status];\n        }\n        // 测试数据\n        NSLog(@\"%@ %@\",_statuses,[_statuses[0] user]);\n    }\n   ```\n    ```objc\n    @implementation NSObject (Model)\n      // 思路：遍历模型中所有属性-> 使用运行时\n    + (instancetype)modelWithDict:(NSDictionary *)dict\n    {\n        id objc = [[self alloc] init];\n\n        // 1.利用runtime给对象中的成员属性赋值\n        /*  \n          类似下面这种写法\n          Ivar ivar;\n          Ivar ivar1;\n          Ivar ivar2;\n          Ivar a[] = {ivar,ivar1,ivar2}; // 定义一个ivar的数组a\n          Ivar *ivarList = a; // 用一个Ivar *指针指向数组第一个元素\n          ivarList[0]; // 根据指针访问数组第一个元素\n        */\n    \n        unsigned int count;\n        /* \n          获取类中的所有成员属性\n          class_copyIvarList:获取类中的所有成员属性\n          Ivar：成员属性的意思\n          第一个参数：表示获取哪个类中的成员属性\n          第二个参数：表示这个类有多少成员属性，传入一个Int变量地址，会自动给这个变量赋值\n          返回值Ivar *：指的是一个ivar数组，会把所有成员属性放在一个数组中，通过返回的数组就能全部获取到。\n        */\n        Ivar *ivarList = class_copyIvarList(self, &count);\n        \n        for (int i = 0; i < count; i++) \n        {\n            // 根据角标，从数组取出对应的成员属性\n            Ivar ivar = ivarList[i];\n            \n            // 获取成员属性名\n            NSString *name = [NSString stringWithUTF8String:ivar_getName(ivar)];\n            \n            // 处理成员属性名->字典中的key\n            // 从第一个角标开始截取\n            NSString *key = [name substringFromIndex:1];\n            // 根据成员属性名去字典中查找对应的value\n            id value = dict[key];\n\n            // 二级转换:如果字典中还有字典，也需要把对应的字典转换成模型\n            // 判断下value是否是字典\n            if ([value isKindOfClass:[NSDictionary class]]) \n            {\n                // 字典转模型\n                // 获取模型的类对象，调用modelWithDict\n                // 模型的类名已知，就是成员属性的类型\n\n                // 获取成员属性类型\n                NSString *type = [NSString stringWithUTF8String:ivar_getTypeEncoding(ivar)];\n                // 生成的是这种@\"@\\\"User\\\"\" 类型 -> @\"User\"  在OC字符串中 \\\" -> \"，\\是转义的意思，不占用字符\n                // 裁剪类型字符串\n                NSRange range = [type rangeOfString:@\"\\\"\"];\n                type = [type substringFromIndex:range.location + range.length];\n                range = [type rangeOfString:@\"\\\"\"];\n\n                // 裁剪到哪个角标，不包括当前角标\n                type = [type substringToIndex:range.location];\n\n                // 根据字符串类名生成类对象\n                Class modelClass = NSClassFromString(type);\n\n                if (modelClass) // 有对应的模型才需要转\n                {\n                    // 把字典转模型\n                    value  =  [modelClass modelWithDict:value];\n                }\n            }\n\n            // 三级转换：NSArray中也是字典，把数组中的字典转换成模型.\n            if ([value isKindOfClass:[NSArray class]]) // 判断值是否是数组\n            {\n                // 判断对应类有没有实现字典数组转模型数组的协议\n                if ([self respondsToSelector:@selector(arrayContainModelClass)])\n                {\n                    // 转换成id类型，就能调用任何对象的方法\n                    id idSelf = self;\n\n                    // 获取数组中字典对应的模型\n                    NSString *type =  [idSelf arrayContainModelClass][key];\n\n                    // 生成模型\n                    Class classModel = NSClassFromString(type);\n                    NSMutableArray *arrM = [NSMutableArray array];\n                    // 遍历字典数组，生成模型数组\n                    for (NSDictionary *dict in value) // 字典转模型\n                    {\n                        id model =  [classModel modelWithDict:dict];\n                        [arrM addObject:model];\n                    }\n\n                    // 把模型数组赋值给value\n                    value = arrM;\n                }\n            }\n\n            if (value) // 有值，才需要给模型的属性赋值\n            {    \n                // 利用KVC给模型中的属性赋值\n                [objc setValue:value forKey:key];\n            }\n\n        }\n            \n        return objc;\n     }\n     @end\n    ```\n\n","source":"_posts/runtime.md","raw":"---\ntitle: runtime\ndate: 2016-03-26 21:19:40\ncategories: iOS\ntags: Objective-C\n---\n\n## runtime简介\n1. Runtime简称运行时,OC就是`运行时机制`,也就是在运行时候的一些机制,其中最主要的是消息机制.\n2. 对于C语言,`函数的调用在编译的时候回决定调用哪个函数`.\n3. 对于OC的函数,属于`动态调用过程`,在编译的时候并不能决定真正调用哪个函数,只要在真正运行的时候才会根据函数的名称找到对应的函数来调用.\n4. 事实证明:\n* 在编译阶段,CO可以`调用任何函数`,即使这个函数未实现,只要声明过就不会报错.\n* 在编译阶段,C语言调用`未实现的函数就会报错`.\n\n<!-- more -->\n## runtime作用\n### 发送消息\n*  方法调用的本质,就是让对象发送消息.\n* `objc_msgSeng`:只有对象才能发送消息,因此以`objc`开头.\n* 使用`消息机制`前提,必须要导入`<objc/message.h>`文件.\n* 消息机制的简单使用\n  * clang -rewrite-objc main.m 查看最终生成代码\n\n   ```objc\n     Person *p = [[Person alloc] init];\n     // 调用对象方法\n     [p eat];\n     objc_msgSend(p, @selector(eat));// 本质：让对象发送消息\n\n     // 调用类方法的方式：两种\n     // 第一种通过类名调用\n     [Person eat];\n     // 第二种通过类对象调用\n     [[Person class] eat];\n\n     // 用类名调用类方法，底层会自动把类名转换成类对象调用\n     // 本质：让类对象发送消息\n     objc_msgSend([Person class], @selector(eat));\n   ```\n  * 消息机制原理:对象根据方法编号`SEL`去映射表查找对应的方法实现\n\n### 交换方法\n*  开发使用场景:系统自带的方法功能不够,给系统自带的方法扩张一些功能,并且保持原有的功能.\n* 方式一:继承系统的类,重写方法.\n* 方式二:使用runtime,交换方法\n\n  ```objc\n  @implementation ViewController\n  - (void)viewDidLoad \n  {\n     [super viewDidLoad];\n     // 需求：给imageNamed方法提供功能，每次加载图片就判断下图片是否加载成功。\n     // 步骤一：先搞个分类，定义一个能加载图片并且能打印的方法\n     //+ (instancetype)imageWithName:(NSString *)name;\n     // 步骤二：交换imageNamed和imageWithName的实现，就能调用imageWithName，间接调用imageWithName的实现。\n     UIImage *image = [UIImage imageNamed:@\"123\"];\n  }\n  @end\n  ```\n ```\n\n ```objc\n @implementation UIImage (Image)\n // 加载分类到内存的时候调用\n + (void)load\n {\n    // 交换方法\n    // 获取imageWithName方法地址\n    Method imageWithName = class_getClassMethod(self,  @selector(imageWithName:));\n    // 获取imageWithName方法地址\n    Method imageName = class_getClassMethod(self, @selector(imageNamed:));\n    // 交换方法地址，相当于交换实现方式\n    method_exchangeImplementations(imageWithName, imageName);\n }\n\n   // 不能在分类中重写系统方法imageNamed，因为会把系统的功能给覆盖掉，而且分类中不能调用super.\n   // 既能加载图片又能打印\n + (instancetype)imageWithName:(NSString *)name\n {\n    // 这里调用imageWithName，相当于调用imageName\n    UIImage *image = [self imageWithName:name];\n    if (image == nil) \n    {\n        NSLog(@\"加载空的图片\");\n    }\n    return image;\n }\n ```\n\n### 动态添加方法\n*  开发使用场景:如果一个类方法非常多,加载类到内存的时候也比较耗费资源,需给每个方法生成映射表,可以使用动态给某个类添加方法解决.\n* 经典面试题:有没有使用过performSelector,其实主要实现问你有没有动态添加过方法.\n* 简单使用.\n\n  ```objc\n  - (void)viewDidLoad {\n    [super viewDidLoad];\n    Person *p = [[Person alloc] init];\n\n    // 默认person，没有实现eat方法，可以通过performSelector调用，但是会报错。\n    // 动态添加方法就不会报错\n    [p performSelector:@selector(eat)];\n  }\n  ```\n  ```objc\n    @implementation Person\n    // void(*)()\n    // 默认方法都有两个隐式参数，\n    void eat(id self,SEL sel)\n    {\n        NSLog(@\"%@ %@\",self,NSStringFromSelector(sel));\n    }\n\n    // 当一个对象调用未实现的方法，会调用这个方法处理,并且会把对应的方法列表传过来.\n    // 刚好可以用来判断，未实现的方法是不是我们想要动态添加的方法\n     + (BOOL)resolveInstanceMethod:(SEL)sel\n     {\n        if (sel == @selector(eat)) \n        {\n            /* \n                动态添加eat方法\n                 第一个参数：给哪个类添加方法\n                 第二个参数：添加方法的方法编号\n                 第三个参数：添加方法的函数实现（函数地址）\n                 第四个参数：函数的类型，(返回值+参数类型) v:void @:对象->self :表示SEL->_cmd\n             */\n            class_addMethod(self, @selector(eat), eat, \"v@:\");\n        }\n        \n        return [super resolveInstanceMethod:sel];\n     }\n     @end\n  ```\n\n### 给分类添加属性\n*   原理:给一个类声明属性,其实本质就是给这个类添加关联,并不是直接把这个值得内存空间添加到类的空间.\n\n  ```objc\n  - (void)viewDidLoad \n  {\n        [super viewDidLoad];\n        // 给系统NSObject类动态添加属性name\n        NSObject *objc = [[NSObject alloc] init];\n        objc.name = @\"jen\";\n        NSLog(@\"%@\",objc.name);\n  }\n  ```\n ```\n ```objc\n @implementation NSObject (Property)\n static const char *key = \"name\";// 定义关联的key\n - (NSString *)name\n {\n      // 根据关联的key，获取关联的值。\n      return objc_getAssociatedObject(self, key);\n  }\n    \n  - (void)setName:(NSString *)name\n  {\n      // 第一个参数：给哪个对象添加关联\n      // 第二个参数：关联的key，通过这个key获取\n      // 第三个参数：关联的value\n      // 第四个参数:关联的策略\n      objc_setAssociatedObject(self, key, name, OBJC_ASSOCIATION_RETAIN_NONATOMIC);\n }\n @end\n ```\n\n### 字典转模型\n*  设计模型:字典转模型的第一步\n  * 模型属性,通常需要跟字典中的key一一对应\n  * 问题:一个一个的生成模型属性?很慢!\n  * 需求:能不能自动根据一个字典,生成对应的属性.\n  * 解决:提供一个分类,专门根据字典生成对应属性的字符串.\n\n   ```objc\n    // 自动打印属性字符串\n    + (void)resolveDict:(NSDictionary *)dict\n    {\n        // 拼接属性字符串代码\n        NSMutableString *strM = [NSMutableString string];\n\n        // 1.遍历字典，把字典中的所有key取出来，生成对应的属性代码\n        [dict   enumerateKeysAndObjectsUsingBlock:^(id  _Nonnull key, id  _Nonnull obj, BOOL * _Nonnull stop) {\n            // 类型经常变，抽出来\n            NSString *type = nil;\n            if ([obj isKindOfClass:NSClassFromString(@\"__NSCFString\")]) \n            {\n                type = @\"NSString\";\n            }\n            else if ([obj isKindOfClass:NSClassFromString(@\"__NSCFArray\")])\n            {\n                type = @\"NSArray\";\n            }\n            else if ([obj isKindOfClass:NSClassFromString(@\"__NSCFNumber\")])\n            {\n                type = @\"int\";\n            }\n            else if ([obj isKindOfClass:NSClassFromString(@\"__NSCFDictionary\")])\n            {\n                type = @\"NSDictionary\";\n            }\n\n            // 属性字符串\n            NSString *str = nil;\n            if ([type containsString:@\"NS\"])\n            {\n                str = [NSString stringWithFormat:@\"@property (nonatomic, strong) %@ *%@;\",type,key];\n            }\n            else\n            {\n                str = [NSString stringWithFormat:@\"@property (nonatomic, assign) %@ %@;\",type,key];\n            }\n            // 每生成属性字符串，就自动换行。\n            [strM appendFormat:@\"\\n%@\\n\",str];\n        }];\n        NSLog(@\"%@\",strM);\n    }\n   ```\n\n#### 字典转模型的方式一:KVC    \n```objc\n+ (instancetype)statusWithDict:(NSDictionary *)dict\n{\n    Status *status = [[self alloc] init];\n    [status setValuesForKeysWithDictionary:dict];\n    return status;\n}\n```\n* KVC字典转模型的弊端:必须保证模型中的属性和字典中的key一一对应\n* 如果不一致,就会调用`[<Status 0x7fa74b545d60> setValue:forUndefinedKey:]`方法,报`key`找不到\n* 分析:模型中的属性和字典的key不一一对应,系统就会调用`setValue:forUndefinedKey:`报错.\n* 解决:重写对象的`setValue:forUndefinedKey:`把系统的方法覆盖,就能继续使用KVC字典转模型了\n\n     ```objc\n       - (void)setValue:(id)value forUndefinedKey:(NSString *)key\n       {\n       }\n     ```\n\n#### 字典转模型方式二:runtime\n*   思路:利用运行时 便利模型中所有属性,根据属性名,去字典中查找key,取出对应的值,给模型属性赋值.\n  * 步骤:提供一个`NSObject`分类,专门字典转模型,以后所有模型都可以通过这个分类转.\n    ​    \n   ```objc\n   - (void)viewDidLoad \n   {\n        [super viewDidLoad];\n        \n        // 解析Plist文件\n        NSString *filePath = [[NSBundle mainBundle] pathForResource:@\"status.plist\" ofType:nil];\n        NSDictionary *statusDict = [NSDictionary dictionaryWithContentsOfFile:filePath];\n\n        // 获取字典数组\n        NSArray *dictArr = statusDict[@\"statuses\"];\n        \n        // 自动生成模型的属性字符串\n        [NSObject resolveDict:dictArr[0][@\"user\"]];\n        _statuses = [NSMutableArray array];\n        \n        // 遍历字典数组\n        for (NSDictionary *dict in dictArr) \n        {\n            Status *status = [Status modelWithDict:dict]; \n            [_statuses addObject:status];\n        }\n        // 测试数据\n        NSLog(@\"%@ %@\",_statuses,[_statuses[0] user]);\n    }\n   ```\n    ```objc\n    @implementation NSObject (Model)\n      // 思路：遍历模型中所有属性-> 使用运行时\n    + (instancetype)modelWithDict:(NSDictionary *)dict\n    {\n        id objc = [[self alloc] init];\n\n        // 1.利用runtime给对象中的成员属性赋值\n        /*  \n          类似下面这种写法\n          Ivar ivar;\n          Ivar ivar1;\n          Ivar ivar2;\n          Ivar a[] = {ivar,ivar1,ivar2}; // 定义一个ivar的数组a\n          Ivar *ivarList = a; // 用一个Ivar *指针指向数组第一个元素\n          ivarList[0]; // 根据指针访问数组第一个元素\n        */\n    \n        unsigned int count;\n        /* \n          获取类中的所有成员属性\n          class_copyIvarList:获取类中的所有成员属性\n          Ivar：成员属性的意思\n          第一个参数：表示获取哪个类中的成员属性\n          第二个参数：表示这个类有多少成员属性，传入一个Int变量地址，会自动给这个变量赋值\n          返回值Ivar *：指的是一个ivar数组，会把所有成员属性放在一个数组中，通过返回的数组就能全部获取到。\n        */\n        Ivar *ivarList = class_copyIvarList(self, &count);\n        \n        for (int i = 0; i < count; i++) \n        {\n            // 根据角标，从数组取出对应的成员属性\n            Ivar ivar = ivarList[i];\n            \n            // 获取成员属性名\n            NSString *name = [NSString stringWithUTF8String:ivar_getName(ivar)];\n            \n            // 处理成员属性名->字典中的key\n            // 从第一个角标开始截取\n            NSString *key = [name substringFromIndex:1];\n            // 根据成员属性名去字典中查找对应的value\n            id value = dict[key];\n\n            // 二级转换:如果字典中还有字典，也需要把对应的字典转换成模型\n            // 判断下value是否是字典\n            if ([value isKindOfClass:[NSDictionary class]]) \n            {\n                // 字典转模型\n                // 获取模型的类对象，调用modelWithDict\n                // 模型的类名已知，就是成员属性的类型\n\n                // 获取成员属性类型\n                NSString *type = [NSString stringWithUTF8String:ivar_getTypeEncoding(ivar)];\n                // 生成的是这种@\"@\\\"User\\\"\" 类型 -> @\"User\"  在OC字符串中 \\\" -> \"，\\是转义的意思，不占用字符\n                // 裁剪类型字符串\n                NSRange range = [type rangeOfString:@\"\\\"\"];\n                type = [type substringFromIndex:range.location + range.length];\n                range = [type rangeOfString:@\"\\\"\"];\n\n                // 裁剪到哪个角标，不包括当前角标\n                type = [type substringToIndex:range.location];\n\n                // 根据字符串类名生成类对象\n                Class modelClass = NSClassFromString(type);\n\n                if (modelClass) // 有对应的模型才需要转\n                {\n                    // 把字典转模型\n                    value  =  [modelClass modelWithDict:value];\n                }\n            }\n\n            // 三级转换：NSArray中也是字典，把数组中的字典转换成模型.\n            if ([value isKindOfClass:[NSArray class]]) // 判断值是否是数组\n            {\n                // 判断对应类有没有实现字典数组转模型数组的协议\n                if ([self respondsToSelector:@selector(arrayContainModelClass)])\n                {\n                    // 转换成id类型，就能调用任何对象的方法\n                    id idSelf = self;\n\n                    // 获取数组中字典对应的模型\n                    NSString *type =  [idSelf arrayContainModelClass][key];\n\n                    // 生成模型\n                    Class classModel = NSClassFromString(type);\n                    NSMutableArray *arrM = [NSMutableArray array];\n                    // 遍历字典数组，生成模型数组\n                    for (NSDictionary *dict in value) // 字典转模型\n                    {\n                        id model =  [classModel modelWithDict:dict];\n                        [arrM addObject:model];\n                    }\n\n                    // 把模型数组赋值给value\n                    value = arrM;\n                }\n            }\n\n            if (value) // 有值，才需要给模型的属性赋值\n            {    \n                // 利用KVC给模型中的属性赋值\n                [objc setValue:value forKey:key];\n            }\n\n        }\n            \n        return objc;\n     }\n     @end\n    ```\n\n","slug":"runtime","published":1,"updated":"2017-04-28T08:42:16.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6686xml001vxe9zese60i4z","content":"<h2 id=\"runtime简介\"><a href=\"#runtime简介\" class=\"headerlink\" title=\"runtime简介\"></a>runtime简介</h2><ol>\n<li>Runtime简称运行时,OC就是<code>运行时机制</code>,也就是在运行时候的一些机制,其中最主要的是消息机制.</li>\n<li>对于C语言,<code>函数的调用在编译的时候回决定调用哪个函数</code>.</li>\n<li>对于OC的函数,属于<code>动态调用过程</code>,在编译的时候并不能决定真正调用哪个函数,只要在真正运行的时候才会根据函数的名称找到对应的函数来调用.</li>\n<li>事实证明:</li>\n</ol>\n<ul>\n<li>在编译阶段,CO可以<code>调用任何函数</code>,即使这个函数未实现,只要声明过就不会报错.</li>\n<li>在编译阶段,C语言调用<code>未实现的函数就会报错</code>.</li>\n</ul>\n<a id=\"more\"></a>\n<h2 id=\"runtime作用\"><a href=\"#runtime作用\" class=\"headerlink\" title=\"runtime作用\"></a>runtime作用</h2><h3 id=\"发送消息\"><a href=\"#发送消息\" class=\"headerlink\" title=\"发送消息\"></a>发送消息</h3><ul>\n<li>方法调用的本质,就是让对象发送消息.</li>\n<li><code>objc_msgSeng</code>:只有对象才能发送消息,因此以<code>objc</code>开头.</li>\n<li>使用<code>消息机制</code>前提,必须要导入<code>&lt;objc/message.h&gt;</code>文件.</li>\n<li><p>消息机制的简单使用</p>\n<ul>\n<li><p>clang -rewrite-objc main.m 查看最终生成代码</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">Person *p = [[Person alloc] init];</div><div class=\"line\"><span class=\"comment\">// 调用对象方法</span></div><div class=\"line\">[p eat];</div><div class=\"line\">objc_msgSend(p, <span class=\"keyword\">@selector</span>(eat));<span class=\"comment\">// 本质：让对象发送消息</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 调用类方法的方式：两种</span></div><div class=\"line\"><span class=\"comment\">// 第一种通过类名调用</span></div><div class=\"line\">[Person eat];</div><div class=\"line\"><span class=\"comment\">// 第二种通过类对象调用</span></div><div class=\"line\">[[Person <span class=\"keyword\">class</span>] eat];</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 用类名调用类方法，底层会自动把类名转换成类对象调用</span></div><div class=\"line\"><span class=\"comment\">// 本质：让类对象发送消息</span></div><div class=\"line\">objc_msgSend([Person <span class=\"keyword\">class</span>], <span class=\"keyword\">@selector</span>(eat));</div></pre></td></tr></table></figure>\n</li>\n<li><p>消息机制原理:对象根据方法编号<code>SEL</code>去映射表查找对应的方法实现</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"交换方法\"><a href=\"#交换方法\" class=\"headerlink\" title=\"交换方法\"></a>交换方法</h3><ul>\n<li>开发使用场景:系统自带的方法功能不够,给系统自带的方法扩张一些功能,并且保持原有的功能.</li>\n<li>方式一:继承系统的类,重写方法.</li>\n<li><p>方式二:使用runtime,交换方法</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">ViewController</span></span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad </div><div class=\"line\">&#123;</div><div class=\"line\">   [<span class=\"keyword\">super</span> viewDidLoad];</div><div class=\"line\">   <span class=\"comment\">// 需求：给imageNamed方法提供功能，每次加载图片就判断下图片是否加载成功。</span></div><div class=\"line\">   <span class=\"comment\">// 步骤一：先搞个分类，定义一个能加载图片并且能打印的方法</span></div><div class=\"line\">   <span class=\"comment\">//+ (instancetype)imageWithName:(NSString *)name;</span></div><div class=\"line\">   <span class=\"comment\">// 步骤二：交换imageNamed和imageWithName的实现，就能调用imageWithName，间接调用imageWithName的实现。</span></div><div class=\"line\">   <span class=\"built_in\">UIImage</span> *image = [<span class=\"built_in\">UIImage</span> imageNamed:<span class=\"string\">@\"123\"</span>];</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">```objc</div><div class=\"line\">@implementation UIImage (Image)</div><div class=\"line\">// 加载分类到内存的时候调用</div><div class=\"line\">+ (void)load</div><div class=\"line\">&#123;</div><div class=\"line\">   // 交换方法</div><div class=\"line\">   // 获取imageWithName方法地址</div><div class=\"line\">   Method imageWithName = class_getClassMethod(self,  @selector(imageWithName:));</div><div class=\"line\">   // 获取imageWithName方法地址</div><div class=\"line\">   Method imageName = class_getClassMethod(self, @selector(imageNamed:));</div><div class=\"line\">   // 交换方法地址，相当于交换实现方式</div><div class=\"line\">   method_exchangeImplementations(imageWithName, imageName);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">  // 不能在分类中重写系统方法imageNamed，因为会把系统的功能给覆盖掉，而且分类中不能调用super.</div><div class=\"line\">  // 既能加载图片又能打印</div><div class=\"line\">+ (instancetype)imageWithName:(NSString *)name</div><div class=\"line\">&#123;</div><div class=\"line\">   // 这里调用imageWithName，相当于调用imageName</div><div class=\"line\">   UIImage *image = [self imageWithName:name];</div><div class=\"line\">   if (image == nil) </div><div class=\"line\">   &#123;</div><div class=\"line\">       NSLog(@&quot;加载空的图片&quot;);</div><div class=\"line\">   &#125;</div><div class=\"line\">   return image;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"动态添加方法\"><a href=\"#动态添加方法\" class=\"headerlink\" title=\"动态添加方法\"></a>动态添加方法</h3><ul>\n<li>开发使用场景:如果一个类方法非常多,加载类到内存的时候也比较耗费资源,需给每个方法生成映射表,可以使用动态给某个类添加方法解决.</li>\n<li>经典面试题:有没有使用过performSelector,其实主要实现问你有没有动态添加过方法.</li>\n<li><p>简单使用.</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad &#123;</div><div class=\"line\">  [<span class=\"keyword\">super</span> viewDidLoad];</div><div class=\"line\">  Person *p = [[Person alloc] init];</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// 默认person，没有实现eat方法，可以通过performSelector调用，但是会报错。</span></div><div class=\"line\">  <span class=\"comment\">// 动态添加方法就不会报错</span></div><div class=\"line\">  [p performSelector:<span class=\"keyword\">@selector</span>(eat)];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">Person</span></span></div><div class=\"line\"><span class=\"comment\">// void(*)()</span></div><div class=\"line\"><span class=\"comment\">// 默认方法都有两个隐式参数，</span></div><div class=\"line\"><span class=\"keyword\">void</span> eat(<span class=\"keyword\">id</span> <span class=\"keyword\">self</span>,SEL sel)</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@ %@\"</span>,<span class=\"keyword\">self</span>,<span class=\"built_in\">NSStringFromSelector</span>(sel));</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 当一个对象调用未实现的方法，会调用这个方法处理,并且会把对应的方法列表传过来.</span></div><div class=\"line\"><span class=\"comment\">// 刚好可以用来判断，未实现的方法是不是我们想要动态添加的方法</span></div><div class=\"line\"> + (<span class=\"built_in\">BOOL</span>)resolveInstanceMethod:(SEL)sel</div><div class=\"line\"> &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (sel == <span class=\"keyword\">@selector</span>(eat)) </div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"comment\">/* </span></div><div class=\"line\">            动态添加eat方法</div><div class=\"line\">             第一个参数：给哪个类添加方法</div><div class=\"line\">             第二个参数：添加方法的方法编号</div><div class=\"line\">             第三个参数：添加方法的函数实现（函数地址）</div><div class=\"line\">             第四个参数：函数的类型，(返回值+参数类型) v:void @:对象-&gt;self :表示SEL-&gt;_cmd</div><div class=\"line\">         */</div><div class=\"line\">        class_addMethod(<span class=\"keyword\">self</span>, <span class=\"keyword\">@selector</span>(eat), eat, <span class=\"string\">\"v@:\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"keyword\">super</span> resolveInstanceMethod:sel];</div><div class=\"line\"> &#125;</div><div class=\"line\"> <span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"给分类添加属性\"><a href=\"#给分类添加属性\" class=\"headerlink\" title=\"给分类添加属性\"></a>给分类添加属性</h3><ul>\n<li><p>原理:给一个类声明属性,其实本质就是给这个类添加关联,并不是直接把这个值得内存空间添加到类的空间.</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad </div><div class=\"line\">&#123;</div><div class=\"line\">      [<span class=\"keyword\">super</span> viewDidLoad];</div><div class=\"line\">      <span class=\"comment\">// 给系统NSObject类动态添加属性name</span></div><div class=\"line\">      <span class=\"built_in\">NSObject</span> *objc = [[<span class=\"built_in\">NSObject</span> alloc] init];</div><div class=\"line\">      objc.name = <span class=\"string\">@\"jen\"</span>;</div><div class=\"line\">      <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>,objc.name);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">```objc</div><div class=\"line\">@implementation NSObject (Property)</div><div class=\"line\">static const char *key = &quot;name&quot;;// 定义关联的key</div><div class=\"line\">- (NSString *)name</div><div class=\"line\">&#123;</div><div class=\"line\">     // 根据关联的key，获取关联的值。</div><div class=\"line\">     return objc_getAssociatedObject(self, key);</div><div class=\"line\"> &#125;</div><div class=\"line\">   </div><div class=\"line\"> - (void)setName:(NSString *)name</div><div class=\"line\"> &#123;</div><div class=\"line\">     // 第一个参数：给哪个对象添加关联</div><div class=\"line\">     // 第二个参数：关联的key，通过这个key获取</div><div class=\"line\">     // 第三个参数：关联的value</div><div class=\"line\">     // 第四个参数:关联的策略</div><div class=\"line\">     objc_setAssociatedObject(self, key, name, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"字典转模型\"><a href=\"#字典转模型\" class=\"headerlink\" title=\"字典转模型\"></a>字典转模型</h3><ul>\n<li><p>设计模型:字典转模型的第一步</p>\n<ul>\n<li>模型属性,通常需要跟字典中的key一一对应</li>\n<li>问题:一个一个的生成模型属性?很慢!</li>\n<li>需求:能不能自动根据一个字典,生成对应的属性.</li>\n<li>解决:提供一个分类,专门根据字典生成对应属性的字符串.</li>\n</ul>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 自动打印属性字符串</span></div><div class=\"line\">+ (<span class=\"keyword\">void</span>)resolveDict:(<span class=\"built_in\">NSDictionary</span> *)dict</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"comment\">// 拼接属性字符串代码</span></div><div class=\"line\">    <span class=\"built_in\">NSMutableString</span> *strM = [<span class=\"built_in\">NSMutableString</span> string];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 1.遍历字典，把字典中的所有key取出来，生成对应的属性代码</span></div><div class=\"line\">    [dict   enumerateKeysAndObjectsUsingBlock:^(<span class=\"keyword\">id</span>  _Nonnull key, <span class=\"keyword\">id</span>  _Nonnull obj, <span class=\"built_in\">BOOL</span> * _Nonnull stop) &#123;</div><div class=\"line\">        <span class=\"comment\">// 类型经常变，抽出来</span></div><div class=\"line\">        <span class=\"built_in\">NSString</span> *type = <span class=\"literal\">nil</span>;</div><div class=\"line\">        <span class=\"keyword\">if</span> ([obj isKindOfClass:<span class=\"built_in\">NSClassFromString</span>(<span class=\"string\">@\"__NSCFString\"</span>)]) </div><div class=\"line\">        &#123;</div><div class=\"line\">            type = <span class=\"string\">@\"NSString\"</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ([obj isKindOfClass:<span class=\"built_in\">NSClassFromString</span>(<span class=\"string\">@\"__NSCFArray\"</span>)])</div><div class=\"line\">        &#123;</div><div class=\"line\">            type = <span class=\"string\">@\"NSArray\"</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ([obj isKindOfClass:<span class=\"built_in\">NSClassFromString</span>(<span class=\"string\">@\"__NSCFNumber\"</span>)])</div><div class=\"line\">        &#123;</div><div class=\"line\">            type = <span class=\"string\">@\"int\"</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ([obj isKindOfClass:<span class=\"built_in\">NSClassFromString</span>(<span class=\"string\">@\"__NSCFDictionary\"</span>)])</div><div class=\"line\">        &#123;</div><div class=\"line\">            type = <span class=\"string\">@\"NSDictionary\"</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// 属性字符串</span></div><div class=\"line\">        <span class=\"built_in\">NSString</span> *str = <span class=\"literal\">nil</span>;</div><div class=\"line\">        <span class=\"keyword\">if</span> ([type containsString:<span class=\"string\">@\"NS\"</span>])</div><div class=\"line\">        &#123;</div><div class=\"line\">            str = [<span class=\"built_in\">NSString</span> stringWithFormat:<span class=\"string\">@\"@property (nonatomic, strong) %@ *%@;\"</span>,type,key];</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">else</span></div><div class=\"line\">        &#123;</div><div class=\"line\">            str = [<span class=\"built_in\">NSString</span> stringWithFormat:<span class=\"string\">@\"@property (nonatomic, assign) %@ %@;\"</span>,type,key];</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"comment\">// 每生成属性字符串，就自动换行。</span></div><div class=\"line\">        [strM appendFormat:<span class=\"string\">@\"\\n%@\\n\"</span>,str];</div><div class=\"line\">    &#125;];</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>,strM);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"字典转模型的方式一-KVC\"><a href=\"#字典转模型的方式一-KVC\" class=\"headerlink\" title=\"字典转模型的方式一:KVC\"></a>字典转模型的方式一:KVC</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">+ (<span class=\"keyword\">instancetype</span>)statusWithDict:(<span class=\"built_in\">NSDictionary</span> *)dict</div><div class=\"line\">&#123;</div><div class=\"line\">    Status *status = [[<span class=\"keyword\">self</span> alloc] init];</div><div class=\"line\">    [status setValuesForKeysWithDictionary:dict];</div><div class=\"line\">    <span class=\"keyword\">return</span> status;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>KVC字典转模型的弊端:必须保证模型中的属性和字典中的key一一对应</li>\n<li>如果不一致,就会调用<code>[&lt;Status 0x7fa74b545d60&gt; setValue:forUndefinedKey:]</code>方法,报<code>key</code>找不到</li>\n<li>分析:模型中的属性和字典的key不一一对应,系统就会调用<code>setValue:forUndefinedKey:</code>报错.</li>\n<li><p>解决:重写对象的<code>setValue:forUndefinedKey:</code>把系统的方法覆盖,就能继续使用KVC字典转模型了</p>\n   <figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)setValue:(<span class=\"keyword\">id</span>)value forUndefinedKey:(<span class=\"built_in\">NSString</span> *)key</div><div class=\"line\">&#123;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"字典转模型方式二-runtime\"><a href=\"#字典转模型方式二-runtime\" class=\"headerlink\" title=\"字典转模型方式二:runtime\"></a>字典转模型方式二:runtime</h4><ul>\n<li><p>思路:利用运行时 便利模型中所有属性,根据属性名,去字典中查找key,取出对应的值,给模型属性赋值.</p>\n<ul>\n<li>步骤:提供一个<code>NSObject</code>分类,专门字典转模型,以后所有模型都可以通过这个分类转.<br>​    <figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad </div><div class=\"line\">&#123;</div><div class=\"line\">     [<span class=\"keyword\">super</span> viewDidLoad];</div><div class=\"line\">     </div><div class=\"line\">     <span class=\"comment\">// 解析Plist文件</span></div><div class=\"line\">     <span class=\"built_in\">NSString</span> *filePath = [[<span class=\"built_in\">NSBundle</span> mainBundle] pathForResource:<span class=\"string\">@\"status.plist\"</span> ofType:<span class=\"literal\">nil</span>];</div><div class=\"line\">     <span class=\"built_in\">NSDictionary</span> *statusDict = [<span class=\"built_in\">NSDictionary</span> dictionaryWithContentsOfFile:filePath];</div><div class=\"line\"></div><div class=\"line\">     <span class=\"comment\">// 获取字典数组</span></div><div class=\"line\">     <span class=\"built_in\">NSArray</span> *dictArr = statusDict[<span class=\"string\">@\"statuses\"</span>];</div><div class=\"line\">     </div><div class=\"line\">     <span class=\"comment\">// 自动生成模型的属性字符串</span></div><div class=\"line\">     [<span class=\"built_in\">NSObject</span> resolveDict:dictArr[<span class=\"number\">0</span>][<span class=\"string\">@\"user\"</span>]];</div><div class=\"line\">     _statuses = [<span class=\"built_in\">NSMutableArray</span> array];</div><div class=\"line\">     </div><div class=\"line\">     <span class=\"comment\">// 遍历字典数组</span></div><div class=\"line\">     <span class=\"keyword\">for</span> (<span class=\"built_in\">NSDictionary</span> *dict <span class=\"keyword\">in</span> dictArr) </div><div class=\"line\">     &#123;</div><div class=\"line\">         Status *status = [Status modelWithDict:dict]; </div><div class=\"line\">         [_statuses addObject:status];</div><div class=\"line\">     &#125;</div><div class=\"line\">     <span class=\"comment\">// 测试数据</span></div><div class=\"line\">     <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@ %@\"</span>,_statuses,[_statuses[<span class=\"number\">0</span>] user]);</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">NSObject</span> (<span class=\"title\">Model</span>)</span></div><div class=\"line\">  <span class=\"comment\">// 思路：遍历模型中所有属性-&gt; 使用运行时</span></div><div class=\"line\">+ (<span class=\"keyword\">instancetype</span>)modelWithDict:(<span class=\"built_in\">NSDictionary</span> *)dict</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">id</span> objc = [[<span class=\"keyword\">self</span> alloc] init];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 1.利用runtime给对象中的成员属性赋值</span></div><div class=\"line\">    <span class=\"comment\">/*  </span></div><div class=\"line\">      类似下面这种写法</div><div class=\"line\">      Ivar ivar;</div><div class=\"line\">      Ivar ivar1;</div><div class=\"line\">      Ivar ivar2;</div><div class=\"line\">      Ivar a[] = &#123;ivar,ivar1,ivar2&#125;; // 定义一个ivar的数组a</div><div class=\"line\">      Ivar *ivarList = a; // 用一个Ivar *指针指向数组第一个元素</div><div class=\"line\">      ivarList[0]; // 根据指针访问数组第一个元素</div><div class=\"line\">    */</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> count;</div><div class=\"line\">    <span class=\"comment\">/* </span></div><div class=\"line\">      获取类中的所有成员属性</div><div class=\"line\">      class_copyIvarList:获取类中的所有成员属性</div><div class=\"line\">      Ivar：成员属性的意思</div><div class=\"line\">      第一个参数：表示获取哪个类中的成员属性</div><div class=\"line\">      第二个参数：表示这个类有多少成员属性，传入一个Int变量地址，会自动给这个变量赋值</div><div class=\"line\">      返回值Ivar *：指的是一个ivar数组，会把所有成员属性放在一个数组中，通过返回的数组就能全部获取到。</div><div class=\"line\">    */</div><div class=\"line\">    Ivar *ivarList = class_copyIvarList(<span class=\"keyword\">self</span>, &amp;count);</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; count; i++) </div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"comment\">// 根据角标，从数组取出对应的成员属性</span></div><div class=\"line\">        Ivar ivar = ivarList[i];</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"comment\">// 获取成员属性名</span></div><div class=\"line\">        <span class=\"built_in\">NSString</span> *name = [<span class=\"built_in\">NSString</span> stringWithUTF8String:ivar_getName(ivar)];</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"comment\">// 处理成员属性名-&gt;字典中的key</span></div><div class=\"line\">        <span class=\"comment\">// 从第一个角标开始截取</span></div><div class=\"line\">        <span class=\"built_in\">NSString</span> *key = [name substringFromIndex:<span class=\"number\">1</span>];</div><div class=\"line\">        <span class=\"comment\">// 根据成员属性名去字典中查找对应的value</span></div><div class=\"line\">        <span class=\"keyword\">id</span> value = dict[key];</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// 二级转换:如果字典中还有字典，也需要把对应的字典转换成模型</span></div><div class=\"line\">        <span class=\"comment\">// 判断下value是否是字典</span></div><div class=\"line\">        <span class=\"keyword\">if</span> ([value isKindOfClass:[<span class=\"built_in\">NSDictionary</span> <span class=\"keyword\">class</span>]]) </div><div class=\"line\">        &#123;</div><div class=\"line\">            <span class=\"comment\">// 字典转模型</span></div><div class=\"line\">            <span class=\"comment\">// 获取模型的类对象，调用modelWithDict</span></div><div class=\"line\">            <span class=\"comment\">// 模型的类名已知，就是成员属性的类型</span></div><div class=\"line\"></div><div class=\"line\">            <span class=\"comment\">// 获取成员属性类型</span></div><div class=\"line\">            <span class=\"built_in\">NSString</span> *type = [<span class=\"built_in\">NSString</span> stringWithUTF8String:ivar_getTypeEncoding(ivar)];</div><div class=\"line\">            <span class=\"comment\">// 生成的是这种@\"@\\\"User\\\"\" 类型 -&gt; @\"User\"  在OC字符串中 \\\" -&gt; \"，\\是转义的意思，不占用字符</span></div><div class=\"line\">            <span class=\"comment\">// 裁剪类型字符串</span></div><div class=\"line\">            <span class=\"built_in\">NSRange</span> range = [type rangeOfString:<span class=\"string\">@\"\\\"\"</span>];</div><div class=\"line\">            type = [type substringFromIndex:range.location + range.length];</div><div class=\"line\">            range = [type rangeOfString:<span class=\"string\">@\"\\\"\"</span>];</div><div class=\"line\"></div><div class=\"line\">            <span class=\"comment\">// 裁剪到哪个角标，不包括当前角标</span></div><div class=\"line\">            type = [type substringToIndex:range.location];</div><div class=\"line\"></div><div class=\"line\">            <span class=\"comment\">// 根据字符串类名生成类对象</span></div><div class=\"line\">            Class modelClass = <span class=\"built_in\">NSClassFromString</span>(type);</div><div class=\"line\"></div><div class=\"line\">            <span class=\"keyword\">if</span> (modelClass) <span class=\"comment\">// 有对应的模型才需要转</span></div><div class=\"line\">            &#123;</div><div class=\"line\">                <span class=\"comment\">// 把字典转模型</span></div><div class=\"line\">                value  =  [modelClass modelWithDict:value];</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// 三级转换：NSArray中也是字典，把数组中的字典转换成模型.</span></div><div class=\"line\">        <span class=\"keyword\">if</span> ([value isKindOfClass:[<span class=\"built_in\">NSArray</span> <span class=\"keyword\">class</span>]]) <span class=\"comment\">// 判断值是否是数组</span></div><div class=\"line\">        &#123;</div><div class=\"line\">            <span class=\"comment\">// 判断对应类有没有实现字典数组转模型数组的协议</span></div><div class=\"line\">            <span class=\"keyword\">if</span> ([<span class=\"keyword\">self</span> respondsToSelector:<span class=\"keyword\">@selector</span>(arrayContainModelClass)])</div><div class=\"line\">            &#123;</div><div class=\"line\">                <span class=\"comment\">// 转换成id类型，就能调用任何对象的方法</span></div><div class=\"line\">                <span class=\"keyword\">id</span> idSelf = <span class=\"keyword\">self</span>;</div><div class=\"line\"></div><div class=\"line\">                <span class=\"comment\">// 获取数组中字典对应的模型</span></div><div class=\"line\">                <span class=\"built_in\">NSString</span> *type =  [idSelf arrayContainModelClass][key];</div><div class=\"line\"></div><div class=\"line\">                <span class=\"comment\">// 生成模型</span></div><div class=\"line\">                Class classModel = <span class=\"built_in\">NSClassFromString</span>(type);</div><div class=\"line\">                <span class=\"built_in\">NSMutableArray</span> *arrM = [<span class=\"built_in\">NSMutableArray</span> array];</div><div class=\"line\">                <span class=\"comment\">// 遍历字典数组，生成模型数组</span></div><div class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"built_in\">NSDictionary</span> *dict <span class=\"keyword\">in</span> value) <span class=\"comment\">// 字典转模型</span></div><div class=\"line\">                &#123;</div><div class=\"line\">                    <span class=\"keyword\">id</span> model =  [classModel modelWithDict:dict];</div><div class=\"line\">                    [arrM addObject:model];</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                <span class=\"comment\">// 把模型数组赋值给value</span></div><div class=\"line\">                value = arrM;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (value) <span class=\"comment\">// 有值，才需要给模型的属性赋值</span></div><div class=\"line\">        &#123;    </div><div class=\"line\">            <span class=\"comment\">// 利用KVC给模型中的属性赋值</span></div><div class=\"line\">            [objc setValue:value forKey:key];</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\">        </div><div class=\"line\">    <span class=\"keyword\">return</span> objc;</div><div class=\"line\"> &#125;</div><div class=\"line\"> <span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"runtime简介\"><a href=\"#runtime简介\" class=\"headerlink\" title=\"runtime简介\"></a>runtime简介</h2><ol>\n<li>Runtime简称运行时,OC就是<code>运行时机制</code>,也就是在运行时候的一些机制,其中最主要的是消息机制.</li>\n<li>对于C语言,<code>函数的调用在编译的时候回决定调用哪个函数</code>.</li>\n<li>对于OC的函数,属于<code>动态调用过程</code>,在编译的时候并不能决定真正调用哪个函数,只要在真正运行的时候才会根据函数的名称找到对应的函数来调用.</li>\n<li>事实证明:</li>\n</ol>\n<ul>\n<li>在编译阶段,CO可以<code>调用任何函数</code>,即使这个函数未实现,只要声明过就不会报错.</li>\n<li>在编译阶段,C语言调用<code>未实现的函数就会报错</code>.</li>\n</ul>","more":"<h2 id=\"runtime作用\"><a href=\"#runtime作用\" class=\"headerlink\" title=\"runtime作用\"></a>runtime作用</h2><h3 id=\"发送消息\"><a href=\"#发送消息\" class=\"headerlink\" title=\"发送消息\"></a>发送消息</h3><ul>\n<li>方法调用的本质,就是让对象发送消息.</li>\n<li><code>objc_msgSeng</code>:只有对象才能发送消息,因此以<code>objc</code>开头.</li>\n<li>使用<code>消息机制</code>前提,必须要导入<code>&lt;objc/message.h&gt;</code>文件.</li>\n<li><p>消息机制的简单使用</p>\n<ul>\n<li><p>clang -rewrite-objc main.m 查看最终生成代码</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">Person *p = [[Person alloc] init];</div><div class=\"line\"><span class=\"comment\">// 调用对象方法</span></div><div class=\"line\">[p eat];</div><div class=\"line\">objc_msgSend(p, <span class=\"keyword\">@selector</span>(eat));<span class=\"comment\">// 本质：让对象发送消息</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 调用类方法的方式：两种</span></div><div class=\"line\"><span class=\"comment\">// 第一种通过类名调用</span></div><div class=\"line\">[Person eat];</div><div class=\"line\"><span class=\"comment\">// 第二种通过类对象调用</span></div><div class=\"line\">[[Person <span class=\"keyword\">class</span>] eat];</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 用类名调用类方法，底层会自动把类名转换成类对象调用</span></div><div class=\"line\"><span class=\"comment\">// 本质：让类对象发送消息</span></div><div class=\"line\">objc_msgSend([Person <span class=\"keyword\">class</span>], <span class=\"keyword\">@selector</span>(eat));</div></pre></td></tr></table></figure>\n</li>\n<li><p>消息机制原理:对象根据方法编号<code>SEL</code>去映射表查找对应的方法实现</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"交换方法\"><a href=\"#交换方法\" class=\"headerlink\" title=\"交换方法\"></a>交换方法</h3><ul>\n<li>开发使用场景:系统自带的方法功能不够,给系统自带的方法扩张一些功能,并且保持原有的功能.</li>\n<li>方式一:继承系统的类,重写方法.</li>\n<li><p>方式二:使用runtime,交换方法</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">ViewController</span></span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad </div><div class=\"line\">&#123;</div><div class=\"line\">   [<span class=\"keyword\">super</span> viewDidLoad];</div><div class=\"line\">   <span class=\"comment\">// 需求：给imageNamed方法提供功能，每次加载图片就判断下图片是否加载成功。</span></div><div class=\"line\">   <span class=\"comment\">// 步骤一：先搞个分类，定义一个能加载图片并且能打印的方法</span></div><div class=\"line\">   <span class=\"comment\">//+ (instancetype)imageWithName:(NSString *)name;</span></div><div class=\"line\">   <span class=\"comment\">// 步骤二：交换imageNamed和imageWithName的实现，就能调用imageWithName，间接调用imageWithName的实现。</span></div><div class=\"line\">   <span class=\"built_in\">UIImage</span> *image = [<span class=\"built_in\">UIImage</span> imageNamed:<span class=\"string\">@\"123\"</span>];</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">```objc</div><div class=\"line\">@implementation UIImage (Image)</div><div class=\"line\">// 加载分类到内存的时候调用</div><div class=\"line\">+ (void)load</div><div class=\"line\">&#123;</div><div class=\"line\">   // 交换方法</div><div class=\"line\">   // 获取imageWithName方法地址</div><div class=\"line\">   Method imageWithName = class_getClassMethod(self,  @selector(imageWithName:));</div><div class=\"line\">   // 获取imageWithName方法地址</div><div class=\"line\">   Method imageName = class_getClassMethod(self, @selector(imageNamed:));</div><div class=\"line\">   // 交换方法地址，相当于交换实现方式</div><div class=\"line\">   method_exchangeImplementations(imageWithName, imageName);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">  // 不能在分类中重写系统方法imageNamed，因为会把系统的功能给覆盖掉，而且分类中不能调用super.</div><div class=\"line\">  // 既能加载图片又能打印</div><div class=\"line\">+ (instancetype)imageWithName:(NSString *)name</div><div class=\"line\">&#123;</div><div class=\"line\">   // 这里调用imageWithName，相当于调用imageName</div><div class=\"line\">   UIImage *image = [self imageWithName:name];</div><div class=\"line\">   if (image == nil) </div><div class=\"line\">   &#123;</div><div class=\"line\">       NSLog(@&quot;加载空的图片&quot;);</div><div class=\"line\">   &#125;</div><div class=\"line\">   return image;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"动态添加方法\"><a href=\"#动态添加方法\" class=\"headerlink\" title=\"动态添加方法\"></a>动态添加方法</h3><ul>\n<li>开发使用场景:如果一个类方法非常多,加载类到内存的时候也比较耗费资源,需给每个方法生成映射表,可以使用动态给某个类添加方法解决.</li>\n<li>经典面试题:有没有使用过performSelector,其实主要实现问你有没有动态添加过方法.</li>\n<li><p>简单使用.</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad &#123;</div><div class=\"line\">  [<span class=\"keyword\">super</span> viewDidLoad];</div><div class=\"line\">  Person *p = [[Person alloc] init];</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// 默认person，没有实现eat方法，可以通过performSelector调用，但是会报错。</span></div><div class=\"line\">  <span class=\"comment\">// 动态添加方法就不会报错</span></div><div class=\"line\">  [p performSelector:<span class=\"keyword\">@selector</span>(eat)];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">Person</span></span></div><div class=\"line\"><span class=\"comment\">// void(*)()</span></div><div class=\"line\"><span class=\"comment\">// 默认方法都有两个隐式参数，</span></div><div class=\"line\"><span class=\"keyword\">void</span> eat(<span class=\"keyword\">id</span> <span class=\"keyword\">self</span>,SEL sel)</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@ %@\"</span>,<span class=\"keyword\">self</span>,<span class=\"built_in\">NSStringFromSelector</span>(sel));</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 当一个对象调用未实现的方法，会调用这个方法处理,并且会把对应的方法列表传过来.</span></div><div class=\"line\"><span class=\"comment\">// 刚好可以用来判断，未实现的方法是不是我们想要动态添加的方法</span></div><div class=\"line\"> + (<span class=\"built_in\">BOOL</span>)resolveInstanceMethod:(SEL)sel</div><div class=\"line\"> &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (sel == <span class=\"keyword\">@selector</span>(eat)) </div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"comment\">/* </span></div><div class=\"line\">            动态添加eat方法</div><div class=\"line\">             第一个参数：给哪个类添加方法</div><div class=\"line\">             第二个参数：添加方法的方法编号</div><div class=\"line\">             第三个参数：添加方法的函数实现（函数地址）</div><div class=\"line\">             第四个参数：函数的类型，(返回值+参数类型) v:void @:对象-&gt;self :表示SEL-&gt;_cmd</div><div class=\"line\">         */</div><div class=\"line\">        class_addMethod(<span class=\"keyword\">self</span>, <span class=\"keyword\">@selector</span>(eat), eat, <span class=\"string\">\"v@:\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"keyword\">super</span> resolveInstanceMethod:sel];</div><div class=\"line\"> &#125;</div><div class=\"line\"> <span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"给分类添加属性\"><a href=\"#给分类添加属性\" class=\"headerlink\" title=\"给分类添加属性\"></a>给分类添加属性</h3><ul>\n<li><p>原理:给一个类声明属性,其实本质就是给这个类添加关联,并不是直接把这个值得内存空间添加到类的空间.</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad </div><div class=\"line\">&#123;</div><div class=\"line\">      [<span class=\"keyword\">super</span> viewDidLoad];</div><div class=\"line\">      <span class=\"comment\">// 给系统NSObject类动态添加属性name</span></div><div class=\"line\">      <span class=\"built_in\">NSObject</span> *objc = [[<span class=\"built_in\">NSObject</span> alloc] init];</div><div class=\"line\">      objc.name = <span class=\"string\">@\"jen\"</span>;</div><div class=\"line\">      <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>,objc.name);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">```objc</div><div class=\"line\">@implementation NSObject (Property)</div><div class=\"line\">static const char *key = &quot;name&quot;;// 定义关联的key</div><div class=\"line\">- (NSString *)name</div><div class=\"line\">&#123;</div><div class=\"line\">     // 根据关联的key，获取关联的值。</div><div class=\"line\">     return objc_getAssociatedObject(self, key);</div><div class=\"line\"> &#125;</div><div class=\"line\">   </div><div class=\"line\"> - (void)setName:(NSString *)name</div><div class=\"line\"> &#123;</div><div class=\"line\">     // 第一个参数：给哪个对象添加关联</div><div class=\"line\">     // 第二个参数：关联的key，通过这个key获取</div><div class=\"line\">     // 第三个参数：关联的value</div><div class=\"line\">     // 第四个参数:关联的策略</div><div class=\"line\">     objc_setAssociatedObject(self, key, name, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"字典转模型\"><a href=\"#字典转模型\" class=\"headerlink\" title=\"字典转模型\"></a>字典转模型</h3><ul>\n<li><p>设计模型:字典转模型的第一步</p>\n<ul>\n<li>模型属性,通常需要跟字典中的key一一对应</li>\n<li>问题:一个一个的生成模型属性?很慢!</li>\n<li>需求:能不能自动根据一个字典,生成对应的属性.</li>\n<li>解决:提供一个分类,专门根据字典生成对应属性的字符串.</li>\n</ul>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 自动打印属性字符串</span></div><div class=\"line\">+ (<span class=\"keyword\">void</span>)resolveDict:(<span class=\"built_in\">NSDictionary</span> *)dict</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"comment\">// 拼接属性字符串代码</span></div><div class=\"line\">    <span class=\"built_in\">NSMutableString</span> *strM = [<span class=\"built_in\">NSMutableString</span> string];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 1.遍历字典，把字典中的所有key取出来，生成对应的属性代码</span></div><div class=\"line\">    [dict   enumerateKeysAndObjectsUsingBlock:^(<span class=\"keyword\">id</span>  _Nonnull key, <span class=\"keyword\">id</span>  _Nonnull obj, <span class=\"built_in\">BOOL</span> * _Nonnull stop) &#123;</div><div class=\"line\">        <span class=\"comment\">// 类型经常变，抽出来</span></div><div class=\"line\">        <span class=\"built_in\">NSString</span> *type = <span class=\"literal\">nil</span>;</div><div class=\"line\">        <span class=\"keyword\">if</span> ([obj isKindOfClass:<span class=\"built_in\">NSClassFromString</span>(<span class=\"string\">@\"__NSCFString\"</span>)]) </div><div class=\"line\">        &#123;</div><div class=\"line\">            type = <span class=\"string\">@\"NSString\"</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ([obj isKindOfClass:<span class=\"built_in\">NSClassFromString</span>(<span class=\"string\">@\"__NSCFArray\"</span>)])</div><div class=\"line\">        &#123;</div><div class=\"line\">            type = <span class=\"string\">@\"NSArray\"</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ([obj isKindOfClass:<span class=\"built_in\">NSClassFromString</span>(<span class=\"string\">@\"__NSCFNumber\"</span>)])</div><div class=\"line\">        &#123;</div><div class=\"line\">            type = <span class=\"string\">@\"int\"</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ([obj isKindOfClass:<span class=\"built_in\">NSClassFromString</span>(<span class=\"string\">@\"__NSCFDictionary\"</span>)])</div><div class=\"line\">        &#123;</div><div class=\"line\">            type = <span class=\"string\">@\"NSDictionary\"</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// 属性字符串</span></div><div class=\"line\">        <span class=\"built_in\">NSString</span> *str = <span class=\"literal\">nil</span>;</div><div class=\"line\">        <span class=\"keyword\">if</span> ([type containsString:<span class=\"string\">@\"NS\"</span>])</div><div class=\"line\">        &#123;</div><div class=\"line\">            str = [<span class=\"built_in\">NSString</span> stringWithFormat:<span class=\"string\">@\"@property (nonatomic, strong) %@ *%@;\"</span>,type,key];</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">else</span></div><div class=\"line\">        &#123;</div><div class=\"line\">            str = [<span class=\"built_in\">NSString</span> stringWithFormat:<span class=\"string\">@\"@property (nonatomic, assign) %@ %@;\"</span>,type,key];</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"comment\">// 每生成属性字符串，就自动换行。</span></div><div class=\"line\">        [strM appendFormat:<span class=\"string\">@\"\\n%@\\n\"</span>,str];</div><div class=\"line\">    &#125;];</div><div class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>,strM);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"字典转模型的方式一-KVC\"><a href=\"#字典转模型的方式一-KVC\" class=\"headerlink\" title=\"字典转模型的方式一:KVC\"></a>字典转模型的方式一:KVC</h4><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">+ (<span class=\"keyword\">instancetype</span>)statusWithDict:(<span class=\"built_in\">NSDictionary</span> *)dict</div><div class=\"line\">&#123;</div><div class=\"line\">    Status *status = [[<span class=\"keyword\">self</span> alloc] init];</div><div class=\"line\">    [status setValuesForKeysWithDictionary:dict];</div><div class=\"line\">    <span class=\"keyword\">return</span> status;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>KVC字典转模型的弊端:必须保证模型中的属性和字典中的key一一对应</li>\n<li>如果不一致,就会调用<code>[&lt;Status 0x7fa74b545d60&gt; setValue:forUndefinedKey:]</code>方法,报<code>key</code>找不到</li>\n<li>分析:模型中的属性和字典的key不一一对应,系统就会调用<code>setValue:forUndefinedKey:</code>报错.</li>\n<li><p>解决:重写对象的<code>setValue:forUndefinedKey:</code>把系统的方法覆盖,就能继续使用KVC字典转模型了</p>\n   <figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)setValue:(<span class=\"keyword\">id</span>)value forUndefinedKey:(<span class=\"built_in\">NSString</span> *)key</div><div class=\"line\">&#123;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"字典转模型方式二-runtime\"><a href=\"#字典转模型方式二-runtime\" class=\"headerlink\" title=\"字典转模型方式二:runtime\"></a>字典转模型方式二:runtime</h4><ul>\n<li><p>思路:利用运行时 便利模型中所有属性,根据属性名,去字典中查找key,取出对应的值,给模型属性赋值.</p>\n<ul>\n<li>步骤:提供一个<code>NSObject</code>分类,专门字典转模型,以后所有模型都可以通过这个分类转.<br>​    <figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad </div><div class=\"line\">&#123;</div><div class=\"line\">     [<span class=\"keyword\">super</span> viewDidLoad];</div><div class=\"line\">     </div><div class=\"line\">     <span class=\"comment\">// 解析Plist文件</span></div><div class=\"line\">     <span class=\"built_in\">NSString</span> *filePath = [[<span class=\"built_in\">NSBundle</span> mainBundle] pathForResource:<span class=\"string\">@\"status.plist\"</span> ofType:<span class=\"literal\">nil</span>];</div><div class=\"line\">     <span class=\"built_in\">NSDictionary</span> *statusDict = [<span class=\"built_in\">NSDictionary</span> dictionaryWithContentsOfFile:filePath];</div><div class=\"line\"></div><div class=\"line\">     <span class=\"comment\">// 获取字典数组</span></div><div class=\"line\">     <span class=\"built_in\">NSArray</span> *dictArr = statusDict[<span class=\"string\">@\"statuses\"</span>];</div><div class=\"line\">     </div><div class=\"line\">     <span class=\"comment\">// 自动生成模型的属性字符串</span></div><div class=\"line\">     [<span class=\"built_in\">NSObject</span> resolveDict:dictArr[<span class=\"number\">0</span>][<span class=\"string\">@\"user\"</span>]];</div><div class=\"line\">     _statuses = [<span class=\"built_in\">NSMutableArray</span> array];</div><div class=\"line\">     </div><div class=\"line\">     <span class=\"comment\">// 遍历字典数组</span></div><div class=\"line\">     <span class=\"keyword\">for</span> (<span class=\"built_in\">NSDictionary</span> *dict <span class=\"keyword\">in</span> dictArr) </div><div class=\"line\">     &#123;</div><div class=\"line\">         Status *status = [Status modelWithDict:dict]; </div><div class=\"line\">         [_statuses addObject:status];</div><div class=\"line\">     &#125;</div><div class=\"line\">     <span class=\"comment\">// 测试数据</span></div><div class=\"line\">     <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@ %@\"</span>,_statuses,[_statuses[<span class=\"number\">0</span>] user]);</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">NSObject</span> (<span class=\"title\">Model</span>)</span></div><div class=\"line\">  <span class=\"comment\">// 思路：遍历模型中所有属性-&gt; 使用运行时</span></div><div class=\"line\">+ (<span class=\"keyword\">instancetype</span>)modelWithDict:(<span class=\"built_in\">NSDictionary</span> *)dict</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">id</span> objc = [[<span class=\"keyword\">self</span> alloc] init];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 1.利用runtime给对象中的成员属性赋值</span></div><div class=\"line\">    <span class=\"comment\">/*  </span></div><div class=\"line\">      类似下面这种写法</div><div class=\"line\">      Ivar ivar;</div><div class=\"line\">      Ivar ivar1;</div><div class=\"line\">      Ivar ivar2;</div><div class=\"line\">      Ivar a[] = &#123;ivar,ivar1,ivar2&#125;; // 定义一个ivar的数组a</div><div class=\"line\">      Ivar *ivarList = a; // 用一个Ivar *指针指向数组第一个元素</div><div class=\"line\">      ivarList[0]; // 根据指针访问数组第一个元素</div><div class=\"line\">    */</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> count;</div><div class=\"line\">    <span class=\"comment\">/* </span></div><div class=\"line\">      获取类中的所有成员属性</div><div class=\"line\">      class_copyIvarList:获取类中的所有成员属性</div><div class=\"line\">      Ivar：成员属性的意思</div><div class=\"line\">      第一个参数：表示获取哪个类中的成员属性</div><div class=\"line\">      第二个参数：表示这个类有多少成员属性，传入一个Int变量地址，会自动给这个变量赋值</div><div class=\"line\">      返回值Ivar *：指的是一个ivar数组，会把所有成员属性放在一个数组中，通过返回的数组就能全部获取到。</div><div class=\"line\">    */</div><div class=\"line\">    Ivar *ivarList = class_copyIvarList(<span class=\"keyword\">self</span>, &amp;count);</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; count; i++) </div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"comment\">// 根据角标，从数组取出对应的成员属性</span></div><div class=\"line\">        Ivar ivar = ivarList[i];</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"comment\">// 获取成员属性名</span></div><div class=\"line\">        <span class=\"built_in\">NSString</span> *name = [<span class=\"built_in\">NSString</span> stringWithUTF8String:ivar_getName(ivar)];</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"comment\">// 处理成员属性名-&gt;字典中的key</span></div><div class=\"line\">        <span class=\"comment\">// 从第一个角标开始截取</span></div><div class=\"line\">        <span class=\"built_in\">NSString</span> *key = [name substringFromIndex:<span class=\"number\">1</span>];</div><div class=\"line\">        <span class=\"comment\">// 根据成员属性名去字典中查找对应的value</span></div><div class=\"line\">        <span class=\"keyword\">id</span> value = dict[key];</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// 二级转换:如果字典中还有字典，也需要把对应的字典转换成模型</span></div><div class=\"line\">        <span class=\"comment\">// 判断下value是否是字典</span></div><div class=\"line\">        <span class=\"keyword\">if</span> ([value isKindOfClass:[<span class=\"built_in\">NSDictionary</span> <span class=\"keyword\">class</span>]]) </div><div class=\"line\">        &#123;</div><div class=\"line\">            <span class=\"comment\">// 字典转模型</span></div><div class=\"line\">            <span class=\"comment\">// 获取模型的类对象，调用modelWithDict</span></div><div class=\"line\">            <span class=\"comment\">// 模型的类名已知，就是成员属性的类型</span></div><div class=\"line\"></div><div class=\"line\">            <span class=\"comment\">// 获取成员属性类型</span></div><div class=\"line\">            <span class=\"built_in\">NSString</span> *type = [<span class=\"built_in\">NSString</span> stringWithUTF8String:ivar_getTypeEncoding(ivar)];</div><div class=\"line\">            <span class=\"comment\">// 生成的是这种@\"@\\\"User\\\"\" 类型 -&gt; @\"User\"  在OC字符串中 \\\" -&gt; \"，\\是转义的意思，不占用字符</span></div><div class=\"line\">            <span class=\"comment\">// 裁剪类型字符串</span></div><div class=\"line\">            <span class=\"built_in\">NSRange</span> range = [type rangeOfString:<span class=\"string\">@\"\\\"\"</span>];</div><div class=\"line\">            type = [type substringFromIndex:range.location + range.length];</div><div class=\"line\">            range = [type rangeOfString:<span class=\"string\">@\"\\\"\"</span>];</div><div class=\"line\"></div><div class=\"line\">            <span class=\"comment\">// 裁剪到哪个角标，不包括当前角标</span></div><div class=\"line\">            type = [type substringToIndex:range.location];</div><div class=\"line\"></div><div class=\"line\">            <span class=\"comment\">// 根据字符串类名生成类对象</span></div><div class=\"line\">            Class modelClass = <span class=\"built_in\">NSClassFromString</span>(type);</div><div class=\"line\"></div><div class=\"line\">            <span class=\"keyword\">if</span> (modelClass) <span class=\"comment\">// 有对应的模型才需要转</span></div><div class=\"line\">            &#123;</div><div class=\"line\">                <span class=\"comment\">// 把字典转模型</span></div><div class=\"line\">                value  =  [modelClass modelWithDict:value];</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// 三级转换：NSArray中也是字典，把数组中的字典转换成模型.</span></div><div class=\"line\">        <span class=\"keyword\">if</span> ([value isKindOfClass:[<span class=\"built_in\">NSArray</span> <span class=\"keyword\">class</span>]]) <span class=\"comment\">// 判断值是否是数组</span></div><div class=\"line\">        &#123;</div><div class=\"line\">            <span class=\"comment\">// 判断对应类有没有实现字典数组转模型数组的协议</span></div><div class=\"line\">            <span class=\"keyword\">if</span> ([<span class=\"keyword\">self</span> respondsToSelector:<span class=\"keyword\">@selector</span>(arrayContainModelClass)])</div><div class=\"line\">            &#123;</div><div class=\"line\">                <span class=\"comment\">// 转换成id类型，就能调用任何对象的方法</span></div><div class=\"line\">                <span class=\"keyword\">id</span> idSelf = <span class=\"keyword\">self</span>;</div><div class=\"line\"></div><div class=\"line\">                <span class=\"comment\">// 获取数组中字典对应的模型</span></div><div class=\"line\">                <span class=\"built_in\">NSString</span> *type =  [idSelf arrayContainModelClass][key];</div><div class=\"line\"></div><div class=\"line\">                <span class=\"comment\">// 生成模型</span></div><div class=\"line\">                Class classModel = <span class=\"built_in\">NSClassFromString</span>(type);</div><div class=\"line\">                <span class=\"built_in\">NSMutableArray</span> *arrM = [<span class=\"built_in\">NSMutableArray</span> array];</div><div class=\"line\">                <span class=\"comment\">// 遍历字典数组，生成模型数组</span></div><div class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"built_in\">NSDictionary</span> *dict <span class=\"keyword\">in</span> value) <span class=\"comment\">// 字典转模型</span></div><div class=\"line\">                &#123;</div><div class=\"line\">                    <span class=\"keyword\">id</span> model =  [classModel modelWithDict:dict];</div><div class=\"line\">                    [arrM addObject:model];</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                <span class=\"comment\">// 把模型数组赋值给value</span></div><div class=\"line\">                value = arrM;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (value) <span class=\"comment\">// 有值，才需要给模型的属性赋值</span></div><div class=\"line\">        &#123;    </div><div class=\"line\">            <span class=\"comment\">// 利用KVC给模型中的属性赋值</span></div><div class=\"line\">            [objc setValue:value forKey:key];</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\">        </div><div class=\"line\">    <span class=\"keyword\">return</span> objc;</div><div class=\"line\"> &#125;</div><div class=\"line\"> <span class=\"keyword\">@end</span></div></pre></td></tr></table></figure>\n</li>\n</ul>"},{"title":"短发姑娘也很美","date":"2016-12-08T05:52:20.000Z","_content":"\n> 其实, 短发姑娘也好看...\n> https://zy.yuxiang.ren\n\n<img src=\"https://ww4.sinaimg.cn/large/65e4f1e6gw1fajlrwunrsj20pm0zkwgl.jpg\" width = \"300\" />\n\n## 长发的时候\n\n<!-- more -->\n\n<img src=\"https://ww3.sinaimg.cn/large/65e4f1e6gw1fajc9arj76j20k00zkn0a.jpg\" width = \"300\" />\n\n## 短发了\n<img src=\"https://ww1.sinaimg.cn/large/65e4f1e6gw1fajca03y5fj20k00zk0vj.jpg\" width = \"300\" />   <img src=\"https://ww4.sinaimg.cn/large/65e4f1e6gw1fajlrdqhtej20k00zk0uq.jpg\" width = \"300\" />\n\n\n> 每一个剪短发的姑娘都是一个有故事的人...\n\n\n","source":"_posts/short-haired-girl-is-also-good.md","raw":"---\ntitle: 短发姑娘也很美\ndate: 2016-12-08 13:52:20\ncategories: 杂碎\ntags: 杂碎\n---\n\n> 其实, 短发姑娘也好看...\n> https://zy.yuxiang.ren\n\n<img src=\"https://ww4.sinaimg.cn/large/65e4f1e6gw1fajlrwunrsj20pm0zkwgl.jpg\" width = \"300\" />\n\n## 长发的时候\n\n<!-- more -->\n\n<img src=\"https://ww3.sinaimg.cn/large/65e4f1e6gw1fajc9arj76j20k00zkn0a.jpg\" width = \"300\" />\n\n## 短发了\n<img src=\"https://ww1.sinaimg.cn/large/65e4f1e6gw1fajca03y5fj20k00zk0vj.jpg\" width = \"300\" />   <img src=\"https://ww4.sinaimg.cn/large/65e4f1e6gw1fajlrdqhtej20k00zk0uq.jpg\" width = \"300\" />\n\n\n> 每一个剪短发的姑娘都是一个有故事的人...\n\n\n","slug":"short-haired-girl-is-also-good","published":1,"updated":"2017-04-28T08:42:10.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6686xmq0020xe9z02vuj32r","content":"<blockquote>\n<p>其实, 短发姑娘也好看…<br><a href=\"https://zy.yuxiang.ren\" target=\"_blank\" rel=\"external\">https://zy.yuxiang.ren</a></p>\n</blockquote>\n<p><img src=\"https://ww4.sinaimg.cn/large/65e4f1e6gw1fajlrwunrsj20pm0zkwgl.jpg\" width=\"300\"></p>\n<h2 id=\"长发的时候\"><a href=\"#长发的时候\" class=\"headerlink\" title=\"长发的时候\"></a>长发的时候</h2><a id=\"more\"></a>\n<p><img src=\"https://ww3.sinaimg.cn/large/65e4f1e6gw1fajc9arj76j20k00zkn0a.jpg\" width=\"300\"></p>\n<h2 id=\"短发了\"><a href=\"#短发了\" class=\"headerlink\" title=\"短发了\"></a>短发了</h2><p><img src=\"https://ww1.sinaimg.cn/large/65e4f1e6gw1fajca03y5fj20k00zk0vj.jpg\" width=\"300\">   <img src=\"https://ww4.sinaimg.cn/large/65e4f1e6gw1fajlrdqhtej20k00zk0uq.jpg\" width=\"300\"></p>\n<blockquote>\n<p>每一个剪短发的姑娘都是一个有故事的人…</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>其实, 短发姑娘也好看…<br><a href=\"https://zy.yuxiang.ren\" target=\"_blank\" rel=\"external\">https://zy.yuxiang.ren</a></p>\n</blockquote>\n<p><img src=\"https://ww4.sinaimg.cn/large/65e4f1e6gw1fajlrwunrsj20pm0zkwgl.jpg\" width=\"300\"></p>\n<h2 id=\"长发的时候\"><a href=\"#长发的时候\" class=\"headerlink\" title=\"长发的时候\"></a>长发的时候</h2>","more":"<p><img src=\"https://ww3.sinaimg.cn/large/65e4f1e6gw1fajc9arj76j20k00zkn0a.jpg\" width=\"300\"></p>\n<h2 id=\"短发了\"><a href=\"#短发了\" class=\"headerlink\" title=\"短发了\"></a>短发了</h2><p><img src=\"https://ww1.sinaimg.cn/large/65e4f1e6gw1fajca03y5fj20k00zk0vj.jpg\" width=\"300\">   <img src=\"https://ww4.sinaimg.cn/large/65e4f1e6gw1fajlrdqhtej20k00zk0uq.jpg\" width=\"300\"></p>\n<blockquote>\n<p>每一个剪短发的姑娘都是一个有故事的人…</p>\n</blockquote>"},{"title":"使用gem更新报错的问题","date":"2016-12-02T06:01:01.000Z","_content":"\n## gem install cocoapods\n\n使用`gem install cocoapods`更新报`You don't have write permissions for the /Library/Ruby/Gems/2.0.0 directory`错.\n解决方法: 使用`sudo gem install cocoapods` 更新\n\n<!-- more -->\n\n## sudo gem install cocoapods\n使用`sudo gem install cocoapods`更新报`Operation not permitted - /usr/bin/pod`错\n\n解决方法: 使用`sudo gem install -n /usr/local/bin cocoapods`\n\n\n","source":"_posts/use-gem-update-with-error.md","raw":"---\ntitle: 使用gem更新报错的问题\ndate: 2016-12-02 14:01:01\ncategories: error\ntags: [命令, error]\n---\n\n## gem install cocoapods\n\n使用`gem install cocoapods`更新报`You don't have write permissions for the /Library/Ruby/Gems/2.0.0 directory`错.\n解决方法: 使用`sudo gem install cocoapods` 更新\n\n<!-- more -->\n\n## sudo gem install cocoapods\n使用`sudo gem install cocoapods`更新报`Operation not permitted - /usr/bin/pod`错\n\n解决方法: 使用`sudo gem install -n /usr/local/bin cocoapods`\n\n\n","slug":"use-gem-update-with-error","published":1,"updated":"2017-04-13T08:01:14.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6686xmu0023xe9zo7q8jwx4","content":"<h2 id=\"gem-install-cocoapods\"><a href=\"#gem-install-cocoapods\" class=\"headerlink\" title=\"gem install cocoapods\"></a>gem install cocoapods</h2><p>使用<code>gem install cocoapods</code>更新报<code>You don&#39;t have write permissions for the /Library/Ruby/Gems/2.0.0 directory</code>错.<br>解决方法: 使用<code>sudo gem install cocoapods</code> 更新</p>\n<a id=\"more\"></a>\n<h2 id=\"sudo-gem-install-cocoapods\"><a href=\"#sudo-gem-install-cocoapods\" class=\"headerlink\" title=\"sudo gem install cocoapods\"></a>sudo gem install cocoapods</h2><p>使用<code>sudo gem install cocoapods</code>更新报<code>Operation not permitted - /usr/bin/pod</code>错</p>\n<p>解决方法: 使用<code>sudo gem install -n /usr/local/bin cocoapods</code></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"gem-install-cocoapods\"><a href=\"#gem-install-cocoapods\" class=\"headerlink\" title=\"gem install cocoapods\"></a>gem install cocoapods</h2><p>使用<code>gem install cocoapods</code>更新报<code>You don&#39;t have write permissions for the /Library/Ruby/Gems/2.0.0 directory</code>错.<br>解决方法: 使用<code>sudo gem install cocoapods</code> 更新</p>","more":"<h2 id=\"sudo-gem-install-cocoapods\"><a href=\"#sudo-gem-install-cocoapods\" class=\"headerlink\" title=\"sudo gem install cocoapods\"></a>sudo gem install cocoapods</h2><p>使用<code>sudo gem install cocoapods</code>更新报<code>Operation not permitted - /usr/bin/pod</code>错</p>\n<p>解决方法: 使用<code>sudo gem install -n /usr/local/bin cocoapods</code></p>"},{"title":"在阿里云上使用hexo并且用git更新","date":"2017-04-24T03:28:17.000Z","_content":"\n本文基于https://hexo.io 博客框架. 基于Node.js\n\n* 本文在<a href=\"/2016/12/02/install-hexo-on-vps-and-update-with-git/\">原文</a>基础上加以修改完善\n* 本文所使用的阿里云服务器系统为: `Ubuntu 16.04.2 LTS`\n* 本地测试环境为: `MacOS 10.12.4`\n* 本文为本人自己搭建博客环境时所记录的步骤, 他人按照此步骤 可能会出现我没有遇到的问题, 请自行百度/google\n* 本文非图文并茂, 全程都是命令行, 也没有什么图可以贴的\n* 为了防止命令输入错误, 可以直接`command+c`\n* 大致为: 在本地电脑上使用hexo撰写文章, 部署并测试成功后, 通过git提交到服务器上.完成博客的更新\n  1. 首先在服务器上部署web环境,以及git等\n  2. 然后在本地电脑上安装hexo, git等所需环境\n  3. 撰写文章并且更新\n  4. 其他完善: 主题, 插件,SEO等...\n* 初来乍到, 勿喷......\n\n# 一. 准备工作\n\n1. 云服务器: 这里我使用的阿里云服务器ECS, 需要配置web环境,git等\n2. 本地测试环境: 需要安装hexo, git等\n3. 域名(非必须)\n\n\n<!-- more -->\n\n# 二. 配置服务器端\n\n* 说明: 为方便,**下文中的`yuxiang.ren(域名)`,`106.14.9.43(主机ip)`...请自行替换**\n\n1. 登录服务器\n   * `ssh root@ip`\n\n2. 安装所需服务\n\n   * 依次执行下面命令(过程有点漫长, 耐心等待)\n\n     ```shell\n      apt update && apt upgrade -y # 14.04 使用apt-get\n      apt install git -y\n      curl -sL https://deb.nodesource.com/setup | bash\n      apt install nodejs -y\n      apt install nginx -y\n      cd /etc/nginx/sites-available\n      rm -rf default\n     ```\n\n   * 访问ip`106.14.9.43`出现nginx默认页面表示nginx安装成功,后面还需要对ngin进一步配置\n\n3. 安装git并且初始化git仓库\n\n   * 依次执行一下命令\n\n     ```shell\n     cd ~\n     mkdir repos && cd repos\n     mkdir yuxiang.ren.git && cd yuxiang.ren.git #yuxiang.ren.git 为存放博客的git仓库(.git后缀) 名称并没有什么要求, 我只是为了方便才这样写的\n     git init --bare\n     cd hooks\n     touch post-receive\n     vi post-receive #此命令是编辑`post-receive`文件, 也可在本地编辑完上传到对应目录替换\n     ```\n\n4. 在出现的编辑页面中输入以下内容,注意`yuxiang.ren`的替换,然后保存退出。\n\n   * 这是一个自动更新博客源文件的脚本, 将仓库里的源文件拷贝到对应博客的源文件目录\n\n   ```bash\n   #!/bin/bash -l\n   GIT_REPO=$HOME/repos/yuxiang.ren.git\n   TMP_GIT_CLONE=$HOME/tmp/git/renyuxiang.ren\n   PUBLIC_WWW=/var/www/yuxiang.ren #网站的根目录 如果`wwww/` 下没有该文件夹 需要手动创建\n   rm -rf ${TMP_GIT_CLONE}\n   git clone $GIT_REPO $TMP_GIT_CLONE\n   rm -rf ${PUBLIC_WWW}/*\n   cp -rf ${TMP_GIT_CLONE}/* ${PUBLIC_WWW}\n   cd ~\n   exit\n   ```\n\n5. 执行下面命令\n\n   * `chmod +x post-receive`\n\n6. 配置`nginx.conf`文件(配置nginx服务器)\n\n   * `vi /etc/nginx/nginx.conf ` (也可在本地编辑完上传到对应目录替换)\n\n   * 在`http` 里添加一下内容\n\n     ```bash\n     server {\n     \t listen 80; # 监听80端口(http), 如需配置https 可自行百度\n          server_name yuxiang.ren www.yuxiang.ren; # URL名字, 需要去域名服务商解析, 如何解析 自己百度\n     \t root /var/www/yuxiang.ren/public/; # 这个是网站的根目录 要与上面`PUBLIC_WWW`一致\n     \t index index.html index.htm index.txt; #这个是让nginx默认读取的文件名\n     }\n     ```\n\n   * 保存退出\n\n   * 重启nginx : `service nginx restart`\n\n     * 如果重启失败 可通过`nginx -t`错误路径以方便处理错误\n\n   * 这时候访问`106.14.9.43` 出现的应该是nginx 404页面\n\n\n# 三. 配置本地环境\n\n* 可能需要安装Xcode命令行工具, 我也不清楚, 因为我电脑本就安装了Xcode, 所以可以直接使用\n\n1. 安装 `Homebrew`\n\n   - `/usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"`\n\n2. 安装`Node.js`\n\n   - `brew install node`\n\n3. 选择博客存放目录我放在文档目录下\n\n   * `cd ~/Documents`\n\n4. 将刚刚再服务器上创建的仓库clone到文档目录下\n\n   - `git clone root@106.14.9.43:repos/yuxiang.ren.git`\n     - `106.14.9.43` 为主机ip地址\n     - `repos/yuxiang.ren.git` 为博客的仓库路径\n   - 会让你输入服务器登录密码\n   - 然后clone一份空的git仓库\n\n5. 给本地电脑安装`Hexo`\n\n   - `npm install -g hexo-cli`\n\n6. 初始化Hexo\n\n   - 进入刚刚从服务器clone下的`yuxiang.ren`文件夹\n\n   - 依次执行下面命令\n\n     ```shell\n     hexo init #初始化 一个博客环境, 需要下载相关文件,耐心等待\n     hexo d -fg #部署\n     hexo s #开启本地预览服务\n     ```\n\n   然后访问 http://localhost:4000  (本地的4000端口)如果看到网页表示Hexo配置成功\n\n\n# 四. 提交到服务器\n\n1. git的更新命令如下\n\n   * 进入博客目录\n\n   * 执行以下命令更新\n\n     ```shell\n     git add . #把需要更新的所有文件添加到本地仓库\n     git commit -m \"update message\" # 提交到本地仓库\n     git push # 提交到远程仓库 这里只服务器\n     ```\n\n   * 如果提示需要输入密码 输入服务器密码即可\n\n2. 如果提交的时候提示` cp: target '* * *' is not a directory`意思是这不是一个目录, 所以要去创建一个目录\n\n   * 上文`PUBLIC_WWW`表示网站的根目录, \n   * 直接执行`mkdir /var/www/yuxiang.ren` 创建网站根目录\n   * 再次提交\n     * 提示`Everything up-to-date`\n     * 那就随便改一下重新部署并提交呗\n\n\n# 五. 博客的配置, 主体更换,\n\n 插件: https://hexo.io/plugins/\n\n主题: https://hexo.io/themes/\n\n…...\n\n自行 百度/Google\n\n# 六. 发布文章 \n\n1. 进入网站根目录\n\n2. `hexo new 文章名字`\n\n3. 编辑`/source/_posts/文章名字.md` 文件使用的是MarkDown语法\n\n   ```markdown\n   \ttitle: title  #文章的标题\n   \tdate: yyyy-mm-dd #创建时间\n       categories: category #分类\n       tags: tag #标签\n          \n       #多标签请这样写：tags: [tag1,tag2,tag3]\n       #或者这样写： \n        #tags: \n          #- tag1\n          #- tag2 \n          #- tag3 \n       ---  \n         \n       #正文\n   ```\n\n4. 正文写完后可以再本地此时下\n\n   * `hexo d -fg`\n   * `hexo s`\n   * 然后访问 http://localhost:4000 \n\n5. 提交到服务器\n\n   ```shell\n   git add .\n   git commit -m \"操作内容\"\n   git push\n   ```\n\n\n# 七. 域名绑定\n\n自行 百度/Google\n\n# 八. 最后\n\n当然你也可以放在Github上, 请自行 百度/Google","source":"_posts/use-hexo-on-aliyun-and-update-with-git.md","raw":"---\ntitle: 在阿里云上使用hexo并且用git更新\ndate: 2017-4-24 11:28:17\ncategories: 教程\ntags: [教程,命令]\n\n---\n\n本文基于https://hexo.io 博客框架. 基于Node.js\n\n* 本文在<a href=\"/2016/12/02/install-hexo-on-vps-and-update-with-git/\">原文</a>基础上加以修改完善\n* 本文所使用的阿里云服务器系统为: `Ubuntu 16.04.2 LTS`\n* 本地测试环境为: `MacOS 10.12.4`\n* 本文为本人自己搭建博客环境时所记录的步骤, 他人按照此步骤 可能会出现我没有遇到的问题, 请自行百度/google\n* 本文非图文并茂, 全程都是命令行, 也没有什么图可以贴的\n* 为了防止命令输入错误, 可以直接`command+c`\n* 大致为: 在本地电脑上使用hexo撰写文章, 部署并测试成功后, 通过git提交到服务器上.完成博客的更新\n  1. 首先在服务器上部署web环境,以及git等\n  2. 然后在本地电脑上安装hexo, git等所需环境\n  3. 撰写文章并且更新\n  4. 其他完善: 主题, 插件,SEO等...\n* 初来乍到, 勿喷......\n\n# 一. 准备工作\n\n1. 云服务器: 这里我使用的阿里云服务器ECS, 需要配置web环境,git等\n2. 本地测试环境: 需要安装hexo, git等\n3. 域名(非必须)\n\n\n<!-- more -->\n\n# 二. 配置服务器端\n\n* 说明: 为方便,**下文中的`yuxiang.ren(域名)`,`106.14.9.43(主机ip)`...请自行替换**\n\n1. 登录服务器\n   * `ssh root@ip`\n\n2. 安装所需服务\n\n   * 依次执行下面命令(过程有点漫长, 耐心等待)\n\n     ```shell\n      apt update && apt upgrade -y # 14.04 使用apt-get\n      apt install git -y\n      curl -sL https://deb.nodesource.com/setup | bash\n      apt install nodejs -y\n      apt install nginx -y\n      cd /etc/nginx/sites-available\n      rm -rf default\n     ```\n\n   * 访问ip`106.14.9.43`出现nginx默认页面表示nginx安装成功,后面还需要对ngin进一步配置\n\n3. 安装git并且初始化git仓库\n\n   * 依次执行一下命令\n\n     ```shell\n     cd ~\n     mkdir repos && cd repos\n     mkdir yuxiang.ren.git && cd yuxiang.ren.git #yuxiang.ren.git 为存放博客的git仓库(.git后缀) 名称并没有什么要求, 我只是为了方便才这样写的\n     git init --bare\n     cd hooks\n     touch post-receive\n     vi post-receive #此命令是编辑`post-receive`文件, 也可在本地编辑完上传到对应目录替换\n     ```\n\n4. 在出现的编辑页面中输入以下内容,注意`yuxiang.ren`的替换,然后保存退出。\n\n   * 这是一个自动更新博客源文件的脚本, 将仓库里的源文件拷贝到对应博客的源文件目录\n\n   ```bash\n   #!/bin/bash -l\n   GIT_REPO=$HOME/repos/yuxiang.ren.git\n   TMP_GIT_CLONE=$HOME/tmp/git/renyuxiang.ren\n   PUBLIC_WWW=/var/www/yuxiang.ren #网站的根目录 如果`wwww/` 下没有该文件夹 需要手动创建\n   rm -rf ${TMP_GIT_CLONE}\n   git clone $GIT_REPO $TMP_GIT_CLONE\n   rm -rf ${PUBLIC_WWW}/*\n   cp -rf ${TMP_GIT_CLONE}/* ${PUBLIC_WWW}\n   cd ~\n   exit\n   ```\n\n5. 执行下面命令\n\n   * `chmod +x post-receive`\n\n6. 配置`nginx.conf`文件(配置nginx服务器)\n\n   * `vi /etc/nginx/nginx.conf ` (也可在本地编辑完上传到对应目录替换)\n\n   * 在`http` 里添加一下内容\n\n     ```bash\n     server {\n     \t listen 80; # 监听80端口(http), 如需配置https 可自行百度\n          server_name yuxiang.ren www.yuxiang.ren; # URL名字, 需要去域名服务商解析, 如何解析 自己百度\n     \t root /var/www/yuxiang.ren/public/; # 这个是网站的根目录 要与上面`PUBLIC_WWW`一致\n     \t index index.html index.htm index.txt; #这个是让nginx默认读取的文件名\n     }\n     ```\n\n   * 保存退出\n\n   * 重启nginx : `service nginx restart`\n\n     * 如果重启失败 可通过`nginx -t`错误路径以方便处理错误\n\n   * 这时候访问`106.14.9.43` 出现的应该是nginx 404页面\n\n\n# 三. 配置本地环境\n\n* 可能需要安装Xcode命令行工具, 我也不清楚, 因为我电脑本就安装了Xcode, 所以可以直接使用\n\n1. 安装 `Homebrew`\n\n   - `/usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"`\n\n2. 安装`Node.js`\n\n   - `brew install node`\n\n3. 选择博客存放目录我放在文档目录下\n\n   * `cd ~/Documents`\n\n4. 将刚刚再服务器上创建的仓库clone到文档目录下\n\n   - `git clone root@106.14.9.43:repos/yuxiang.ren.git`\n     - `106.14.9.43` 为主机ip地址\n     - `repos/yuxiang.ren.git` 为博客的仓库路径\n   - 会让你输入服务器登录密码\n   - 然后clone一份空的git仓库\n\n5. 给本地电脑安装`Hexo`\n\n   - `npm install -g hexo-cli`\n\n6. 初始化Hexo\n\n   - 进入刚刚从服务器clone下的`yuxiang.ren`文件夹\n\n   - 依次执行下面命令\n\n     ```shell\n     hexo init #初始化 一个博客环境, 需要下载相关文件,耐心等待\n     hexo d -fg #部署\n     hexo s #开启本地预览服务\n     ```\n\n   然后访问 http://localhost:4000  (本地的4000端口)如果看到网页表示Hexo配置成功\n\n\n# 四. 提交到服务器\n\n1. git的更新命令如下\n\n   * 进入博客目录\n\n   * 执行以下命令更新\n\n     ```shell\n     git add . #把需要更新的所有文件添加到本地仓库\n     git commit -m \"update message\" # 提交到本地仓库\n     git push # 提交到远程仓库 这里只服务器\n     ```\n\n   * 如果提示需要输入密码 输入服务器密码即可\n\n2. 如果提交的时候提示` cp: target '* * *' is not a directory`意思是这不是一个目录, 所以要去创建一个目录\n\n   * 上文`PUBLIC_WWW`表示网站的根目录, \n   * 直接执行`mkdir /var/www/yuxiang.ren` 创建网站根目录\n   * 再次提交\n     * 提示`Everything up-to-date`\n     * 那就随便改一下重新部署并提交呗\n\n\n# 五. 博客的配置, 主体更换,\n\n 插件: https://hexo.io/plugins/\n\n主题: https://hexo.io/themes/\n\n…...\n\n自行 百度/Google\n\n# 六. 发布文章 \n\n1. 进入网站根目录\n\n2. `hexo new 文章名字`\n\n3. 编辑`/source/_posts/文章名字.md` 文件使用的是MarkDown语法\n\n   ```markdown\n   \ttitle: title  #文章的标题\n   \tdate: yyyy-mm-dd #创建时间\n       categories: category #分类\n       tags: tag #标签\n          \n       #多标签请这样写：tags: [tag1,tag2,tag3]\n       #或者这样写： \n        #tags: \n          #- tag1\n          #- tag2 \n          #- tag3 \n       ---  \n         \n       #正文\n   ```\n\n4. 正文写完后可以再本地此时下\n\n   * `hexo d -fg`\n   * `hexo s`\n   * 然后访问 http://localhost:4000 \n\n5. 提交到服务器\n\n   ```shell\n   git add .\n   git commit -m \"操作内容\"\n   git push\n   ```\n\n\n# 七. 域名绑定\n\n自行 百度/Google\n\n# 八. 最后\n\n当然你也可以放在Github上, 请自行 百度/Google","slug":"use-hexo-on-aliyun-and-update-with-git","published":1,"updated":"2017-04-28T08:40:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6686xmw0028xe9zepi3s0wj","content":"<p>本文基于<a href=\"https://hexo.io\" target=\"_blank\" rel=\"external\">https://hexo.io</a> 博客框架. 基于Node.js</p>\n<ul>\n<li>本文在<a href=\"/2016/12/02/install-hexo-on-vps-and-update-with-git/\">原文</a>基础上加以修改完善</li>\n<li>本文所使用的阿里云服务器系统为: <code>Ubuntu 16.04.2 LTS</code></li>\n<li>本地测试环境为: <code>MacOS 10.12.4</code></li>\n<li>本文为本人自己搭建博客环境时所记录的步骤, 他人按照此步骤 可能会出现我没有遇到的问题, 请自行百度/google</li>\n<li>本文非图文并茂, 全程都是命令行, 也没有什么图可以贴的</li>\n<li>为了防止命令输入错误, 可以直接<code>command+c</code></li>\n<li>大致为: 在本地电脑上使用hexo撰写文章, 部署并测试成功后, 通过git提交到服务器上.完成博客的更新<ol>\n<li>首先在服务器上部署web环境,以及git等</li>\n<li>然后在本地电脑上安装hexo, git等所需环境</li>\n<li>撰写文章并且更新</li>\n<li>其他完善: 主题, 插件,SEO等…</li>\n</ol>\n</li>\n<li>初来乍到, 勿喷……</li>\n</ul>\n<h1 id=\"一-准备工作\"><a href=\"#一-准备工作\" class=\"headerlink\" title=\"一. 准备工作\"></a>一. 准备工作</h1><ol>\n<li>云服务器: 这里我使用的阿里云服务器ECS, 需要配置web环境,git等</li>\n<li>本地测试环境: 需要安装hexo, git等</li>\n<li>域名(非必须)</li>\n</ol>\n<a id=\"more\"></a>\n<h1 id=\"二-配置服务器端\"><a href=\"#二-配置服务器端\" class=\"headerlink\" title=\"二. 配置服务器端\"></a>二. 配置服务器端</h1><ul>\n<li>说明: 为方便,<strong>下文中的<code>yuxiang.ren(域名)</code>,<code>106.14.9.43(主机ip)</code>…请自行替换</strong></li>\n</ul>\n<ol>\n<li><p>登录服务器</p>\n<ul>\n<li><code>ssh root@ip</code></li>\n</ul>\n</li>\n<li><p>安装所需服务</p>\n<ul>\n<li><p>依次执行下面命令(过程有点漫长, 耐心等待)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">apt update &amp;&amp; apt upgrade -y # 14.04 使用apt-get</div><div class=\"line\">apt install git -y</div><div class=\"line\">curl -sL https://deb.nodesource.com/setup | bash</div><div class=\"line\">apt install nodejs -y</div><div class=\"line\">apt install nginx -y</div><div class=\"line\">cd /etc/nginx/sites-available</div><div class=\"line\">rm -rf default</div></pre></td></tr></table></figure>\n</li>\n<li><p>访问ip<code>106.14.9.43</code>出现nginx默认页面表示nginx安装成功,后面还需要对ngin进一步配置</p>\n</li>\n</ul>\n</li>\n<li><p>安装git并且初始化git仓库</p>\n<ul>\n<li><p>依次执行一下命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">cd ~</div><div class=\"line\">mkdir repos &amp;&amp; cd repos</div><div class=\"line\">mkdir yuxiang.ren.git &amp;&amp; cd yuxiang.ren.git #yuxiang.ren.git 为存放博客的git仓库(.git后缀) 名称并没有什么要求, 我只是为了方便才这样写的</div><div class=\"line\">git init --bare</div><div class=\"line\">cd hooks</div><div class=\"line\">touch post-receive</div><div class=\"line\">vi post-receive #此命令是编辑`post-receive`文件, 也可在本地编辑完上传到对应目录替换</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>在出现的编辑页面中输入以下内容,注意<code>yuxiang.ren</code>的替换,然后保存退出。</p>\n<ul>\n<li>这是一个自动更新博客源文件的脚本, 将仓库里的源文件拷贝到对应博客的源文件目录</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">#!/bin/bash -l</span></div><div class=\"line\">GIT_REPO=<span class=\"variable\">$HOME</span>/repos/yuxiang.ren.git</div><div class=\"line\">TMP_GIT_CLONE=<span class=\"variable\">$HOME</span>/tmp/git/renyuxiang.ren</div><div class=\"line\">PUBLIC_WWW=/var/www/yuxiang.ren <span class=\"comment\">#网站的根目录 如果`wwww/` 下没有该文件夹 需要手动创建</span></div><div class=\"line\">rm -rf <span class=\"variable\">$&#123;TMP_GIT_CLONE&#125;</span></div><div class=\"line\">git <span class=\"built_in\">clone</span> <span class=\"variable\">$GIT_REPO</span> <span class=\"variable\">$TMP_GIT_CLONE</span></div><div class=\"line\">rm -rf <span class=\"variable\">$&#123;PUBLIC_WWW&#125;</span>/*</div><div class=\"line\">cp -rf <span class=\"variable\">$&#123;TMP_GIT_CLONE&#125;</span>/* <span class=\"variable\">$&#123;PUBLIC_WWW&#125;</span></div><div class=\"line\"><span class=\"built_in\">cd</span> ~</div><div class=\"line\"><span class=\"built_in\">exit</span></div></pre></td></tr></table></figure>\n</li>\n<li><p>执行下面命令</p>\n<ul>\n<li><code>chmod +x post-receive</code></li>\n</ul>\n</li>\n<li><p>配置<code>nginx.conf</code>文件(配置nginx服务器)</p>\n<ul>\n<li><p><code>vi /etc/nginx/nginx.conf</code> (也可在本地编辑完上传到对应目录替换)</p>\n</li>\n<li><p>在<code>http</code> 里添加一下内容</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">server &#123;</div><div class=\"line\">\t listen 80; <span class=\"comment\"># 监听80端口(http), 如需配置https 可自行百度</span></div><div class=\"line\">     server_name yuxiang.ren www.yuxiang.ren; <span class=\"comment\"># URL名字, 需要去域名服务商解析, 如何解析 自己百度</span></div><div class=\"line\">\t root /var/www/yuxiang.ren/public/; <span class=\"comment\"># 这个是网站的根目录 要与上面`PUBLIC_WWW`一致</span></div><div class=\"line\">\t index index.html index.htm index.txt; <span class=\"comment\">#这个是让nginx默认读取的文件名</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>保存退出</p>\n</li>\n<li><p>重启nginx : <code>service nginx restart</code></p>\n<ul>\n<li>如果重启失败 可通过<code>nginx -t</code>错误路径以方便处理错误</li>\n</ul>\n</li>\n<li><p>这时候访问<code>106.14.9.43</code> 出现的应该是nginx 404页面</p>\n</li>\n</ul>\n</li>\n</ol>\n<h1 id=\"三-配置本地环境\"><a href=\"#三-配置本地环境\" class=\"headerlink\" title=\"三. 配置本地环境\"></a>三. 配置本地环境</h1><ul>\n<li>可能需要安装Xcode命令行工具, 我也不清楚, 因为我电脑本就安装了Xcode, 所以可以直接使用</li>\n</ul>\n<ol>\n<li><p>安装 <code>Homebrew</code></p>\n<ul>\n<li><code>/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</code></li>\n</ul>\n</li>\n<li><p>安装<code>Node.js</code></p>\n<ul>\n<li><code>brew install node</code></li>\n</ul>\n</li>\n<li><p>选择博客存放目录我放在文档目录下</p>\n<ul>\n<li><code>cd ~/Documents</code></li>\n</ul>\n</li>\n<li><p>将刚刚再服务器上创建的仓库clone到文档目录下</p>\n<ul>\n<li><code>git clone root@106.14.9.43:repos/yuxiang.ren.git</code><ul>\n<li><code>106.14.9.43</code> 为主机ip地址</li>\n<li><code>repos/yuxiang.ren.git</code> 为博客的仓库路径</li>\n</ul>\n</li>\n<li>会让你输入服务器登录密码</li>\n<li>然后clone一份空的git仓库</li>\n</ul>\n</li>\n<li><p>给本地电脑安装<code>Hexo</code></p>\n<ul>\n<li><code>npm install -g hexo-cli</code></li>\n</ul>\n</li>\n<li><p>初始化Hexo</p>\n<ul>\n<li><p>进入刚刚从服务器clone下的<code>yuxiang.ren</code>文件夹</p>\n</li>\n<li><p>依次执行下面命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo init #初始化 一个博客环境, 需要下载相关文件,耐心等待</div><div class=\"line\">hexo d -fg #部署</div><div class=\"line\">hexo s #开启本地预览服务</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>然后访问 <a href=\"http://localhost:4000\" target=\"_blank\" rel=\"external\">http://localhost:4000</a>  (本地的4000端口)如果看到网页表示Hexo配置成功</p>\n</li>\n</ol>\n<h1 id=\"四-提交到服务器\"><a href=\"#四-提交到服务器\" class=\"headerlink\" title=\"四. 提交到服务器\"></a>四. 提交到服务器</h1><ol>\n<li><p>git的更新命令如下</p>\n<ul>\n<li><p>进入博客目录</p>\n</li>\n<li><p>执行以下命令更新</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">git add . #把需要更新的所有文件添加到本地仓库</div><div class=\"line\">git commit -m &quot;update message&quot; # 提交到本地仓库</div><div class=\"line\">git push # 提交到远程仓库 这里只服务器</div></pre></td></tr></table></figure>\n</li>\n<li><p>如果提示需要输入密码 输入服务器密码即可</p>\n</li>\n</ul>\n</li>\n<li><p>如果提交的时候提示<code>cp: target &#39;* * *&#39; is not a directory</code>意思是这不是一个目录, 所以要去创建一个目录</p>\n<ul>\n<li>上文<code>PUBLIC_WWW</code>表示网站的根目录, </li>\n<li>直接执行<code>mkdir /var/www/yuxiang.ren</code> 创建网站根目录</li>\n<li>再次提交<ul>\n<li>提示<code>Everything up-to-date</code></li>\n<li>那就随便改一下重新部署并提交呗</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h1 id=\"五-博客的配置-主体更换\"><a href=\"#五-博客的配置-主体更换\" class=\"headerlink\" title=\"五. 博客的配置, 主体更换,\"></a>五. 博客的配置, 主体更换,</h1><p> 插件: <a href=\"https://hexo.io/plugins/\" target=\"_blank\" rel=\"external\">https://hexo.io/plugins/</a></p>\n<p>主题: <a href=\"https://hexo.io/themes/\" target=\"_blank\" rel=\"external\">https://hexo.io/themes/</a></p>\n<p>……</p>\n<p>自行 百度/Google</p>\n<h1 id=\"六-发布文章\"><a href=\"#六-发布文章\" class=\"headerlink\" title=\"六. 发布文章\"></a>六. 发布文章</h1><ol>\n<li><p>进入网站根目录</p>\n</li>\n<li><p><code>hexo new 文章名字</code></p>\n</li>\n<li><p>编辑<code>/source/_posts/文章名字.md</code> 文件使用的是MarkDown语法</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">title: title  #文章的标题</div><div class=\"line\">date: yyyy-mm-dd #创建时间</div><div class=\"line\">   categories: category #分类</div><div class=\"line\">   tags: tag #标签</div><div class=\"line\"><span class=\"code\">      </span></div><div class=\"line\">   #多标签请这样写：tags: [tag1,tag2,tag3]</div><div class=\"line\">   #或者这样写： </div><div class=\"line\"><span class=\"code\">    #tags: </span></div><div class=\"line\"><span class=\"code\">      #- tag1</span></div><div class=\"line\"><span class=\"code\">      #- tag2 </span></div><div class=\"line\"><span class=\"code\">      #- tag3 </span></div><div class=\"line\">   ---  </div><div class=\"line\"><span class=\"code\">     </span></div><div class=\"line\">   #正文</div></pre></td></tr></table></figure>\n</li>\n<li><p>正文写完后可以再本地此时下</p>\n<ul>\n<li><code>hexo d -fg</code></li>\n<li><code>hexo s</code></li>\n<li>然后访问 <a href=\"http://localhost:4000\" target=\"_blank\" rel=\"external\">http://localhost:4000</a> </li>\n</ul>\n</li>\n<li><p>提交到服务器</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">git add .</div><div class=\"line\">git commit -m &quot;操作内容&quot;</div><div class=\"line\">git push</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<h1 id=\"七-域名绑定\"><a href=\"#七-域名绑定\" class=\"headerlink\" title=\"七. 域名绑定\"></a>七. 域名绑定</h1><p>自行 百度/Google</p>\n<h1 id=\"八-最后\"><a href=\"#八-最后\" class=\"headerlink\" title=\"八. 最后\"></a>八. 最后</h1><p>当然你也可以放在Github上, 请自行 百度/Google</p>\n","site":{"data":{}},"excerpt":"<p>本文基于<a href=\"https://hexo.io\" target=\"_blank\" rel=\"external\">https://hexo.io</a> 博客框架. 基于Node.js</p>\n<ul>\n<li>本文在<a href=\"/2016/12/02/install-hexo-on-vps-and-update-with-git/\">原文</a>基础上加以修改完善</li>\n<li>本文所使用的阿里云服务器系统为: <code>Ubuntu 16.04.2 LTS</code></li>\n<li>本地测试环境为: <code>MacOS 10.12.4</code></li>\n<li>本文为本人自己搭建博客环境时所记录的步骤, 他人按照此步骤 可能会出现我没有遇到的问题, 请自行百度/google</li>\n<li>本文非图文并茂, 全程都是命令行, 也没有什么图可以贴的</li>\n<li>为了防止命令输入错误, 可以直接<code>command+c</code></li>\n<li>大致为: 在本地电脑上使用hexo撰写文章, 部署并测试成功后, 通过git提交到服务器上.完成博客的更新<ol>\n<li>首先在服务器上部署web环境,以及git等</li>\n<li>然后在本地电脑上安装hexo, git等所需环境</li>\n<li>撰写文章并且更新</li>\n<li>其他完善: 主题, 插件,SEO等…</li>\n</ol>\n</li>\n<li>初来乍到, 勿喷……</li>\n</ul>\n<h1 id=\"一-准备工作\"><a href=\"#一-准备工作\" class=\"headerlink\" title=\"一. 准备工作\"></a>一. 准备工作</h1><ol>\n<li>云服务器: 这里我使用的阿里云服务器ECS, 需要配置web环境,git等</li>\n<li>本地测试环境: 需要安装hexo, git等</li>\n<li>域名(非必须)</li>\n</ol>","more":"<h1 id=\"二-配置服务器端\"><a href=\"#二-配置服务器端\" class=\"headerlink\" title=\"二. 配置服务器端\"></a>二. 配置服务器端</h1><ul>\n<li>说明: 为方便,<strong>下文中的<code>yuxiang.ren(域名)</code>,<code>106.14.9.43(主机ip)</code>…请自行替换</strong></li>\n</ul>\n<ol>\n<li><p>登录服务器</p>\n<ul>\n<li><code>ssh root@ip</code></li>\n</ul>\n</li>\n<li><p>安装所需服务</p>\n<ul>\n<li><p>依次执行下面命令(过程有点漫长, 耐心等待)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">apt update &amp;&amp; apt upgrade -y # 14.04 使用apt-get</div><div class=\"line\">apt install git -y</div><div class=\"line\">curl -sL https://deb.nodesource.com/setup | bash</div><div class=\"line\">apt install nodejs -y</div><div class=\"line\">apt install nginx -y</div><div class=\"line\">cd /etc/nginx/sites-available</div><div class=\"line\">rm -rf default</div></pre></td></tr></table></figure>\n</li>\n<li><p>访问ip<code>106.14.9.43</code>出现nginx默认页面表示nginx安装成功,后面还需要对ngin进一步配置</p>\n</li>\n</ul>\n</li>\n<li><p>安装git并且初始化git仓库</p>\n<ul>\n<li><p>依次执行一下命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">cd ~</div><div class=\"line\">mkdir repos &amp;&amp; cd repos</div><div class=\"line\">mkdir yuxiang.ren.git &amp;&amp; cd yuxiang.ren.git #yuxiang.ren.git 为存放博客的git仓库(.git后缀) 名称并没有什么要求, 我只是为了方便才这样写的</div><div class=\"line\">git init --bare</div><div class=\"line\">cd hooks</div><div class=\"line\">touch post-receive</div><div class=\"line\">vi post-receive #此命令是编辑`post-receive`文件, 也可在本地编辑完上传到对应目录替换</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>在出现的编辑页面中输入以下内容,注意<code>yuxiang.ren</code>的替换,然后保存退出。</p>\n<ul>\n<li>这是一个自动更新博客源文件的脚本, 将仓库里的源文件拷贝到对应博客的源文件目录</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">#!/bin/bash -l</span></div><div class=\"line\">GIT_REPO=<span class=\"variable\">$HOME</span>/repos/yuxiang.ren.git</div><div class=\"line\">TMP_GIT_CLONE=<span class=\"variable\">$HOME</span>/tmp/git/renyuxiang.ren</div><div class=\"line\">PUBLIC_WWW=/var/www/yuxiang.ren <span class=\"comment\">#网站的根目录 如果`wwww/` 下没有该文件夹 需要手动创建</span></div><div class=\"line\">rm -rf <span class=\"variable\">$&#123;TMP_GIT_CLONE&#125;</span></div><div class=\"line\">git <span class=\"built_in\">clone</span> <span class=\"variable\">$GIT_REPO</span> <span class=\"variable\">$TMP_GIT_CLONE</span></div><div class=\"line\">rm -rf <span class=\"variable\">$&#123;PUBLIC_WWW&#125;</span>/*</div><div class=\"line\">cp -rf <span class=\"variable\">$&#123;TMP_GIT_CLONE&#125;</span>/* <span class=\"variable\">$&#123;PUBLIC_WWW&#125;</span></div><div class=\"line\"><span class=\"built_in\">cd</span> ~</div><div class=\"line\"><span class=\"built_in\">exit</span></div></pre></td></tr></table></figure>\n</li>\n<li><p>执行下面命令</p>\n<ul>\n<li><code>chmod +x post-receive</code></li>\n</ul>\n</li>\n<li><p>配置<code>nginx.conf</code>文件(配置nginx服务器)</p>\n<ul>\n<li><p><code>vi /etc/nginx/nginx.conf</code> (也可在本地编辑完上传到对应目录替换)</p>\n</li>\n<li><p>在<code>http</code> 里添加一下内容</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">server &#123;</div><div class=\"line\">\t listen 80; <span class=\"comment\"># 监听80端口(http), 如需配置https 可自行百度</span></div><div class=\"line\">     server_name yuxiang.ren www.yuxiang.ren; <span class=\"comment\"># URL名字, 需要去域名服务商解析, 如何解析 自己百度</span></div><div class=\"line\">\t root /var/www/yuxiang.ren/public/; <span class=\"comment\"># 这个是网站的根目录 要与上面`PUBLIC_WWW`一致</span></div><div class=\"line\">\t index index.html index.htm index.txt; <span class=\"comment\">#这个是让nginx默认读取的文件名</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>保存退出</p>\n</li>\n<li><p>重启nginx : <code>service nginx restart</code></p>\n<ul>\n<li>如果重启失败 可通过<code>nginx -t</code>错误路径以方便处理错误</li>\n</ul>\n</li>\n<li><p>这时候访问<code>106.14.9.43</code> 出现的应该是nginx 404页面</p>\n</li>\n</ul>\n</li>\n</ol>\n<h1 id=\"三-配置本地环境\"><a href=\"#三-配置本地环境\" class=\"headerlink\" title=\"三. 配置本地环境\"></a>三. 配置本地环境</h1><ul>\n<li>可能需要安装Xcode命令行工具, 我也不清楚, 因为我电脑本就安装了Xcode, 所以可以直接使用</li>\n</ul>\n<ol>\n<li><p>安装 <code>Homebrew</code></p>\n<ul>\n<li><code>/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</code></li>\n</ul>\n</li>\n<li><p>安装<code>Node.js</code></p>\n<ul>\n<li><code>brew install node</code></li>\n</ul>\n</li>\n<li><p>选择博客存放目录我放在文档目录下</p>\n<ul>\n<li><code>cd ~/Documents</code></li>\n</ul>\n</li>\n<li><p>将刚刚再服务器上创建的仓库clone到文档目录下</p>\n<ul>\n<li><code>git clone root@106.14.9.43:repos/yuxiang.ren.git</code><ul>\n<li><code>106.14.9.43</code> 为主机ip地址</li>\n<li><code>repos/yuxiang.ren.git</code> 为博客的仓库路径</li>\n</ul>\n</li>\n<li>会让你输入服务器登录密码</li>\n<li>然后clone一份空的git仓库</li>\n</ul>\n</li>\n<li><p>给本地电脑安装<code>Hexo</code></p>\n<ul>\n<li><code>npm install -g hexo-cli</code></li>\n</ul>\n</li>\n<li><p>初始化Hexo</p>\n<ul>\n<li><p>进入刚刚从服务器clone下的<code>yuxiang.ren</code>文件夹</p>\n</li>\n<li><p>依次执行下面命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo init #初始化 一个博客环境, 需要下载相关文件,耐心等待</div><div class=\"line\">hexo d -fg #部署</div><div class=\"line\">hexo s #开启本地预览服务</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>然后访问 <a href=\"http://localhost:4000\" target=\"_blank\" rel=\"external\">http://localhost:4000</a>  (本地的4000端口)如果看到网页表示Hexo配置成功</p>\n</li>\n</ol>\n<h1 id=\"四-提交到服务器\"><a href=\"#四-提交到服务器\" class=\"headerlink\" title=\"四. 提交到服务器\"></a>四. 提交到服务器</h1><ol>\n<li><p>git的更新命令如下</p>\n<ul>\n<li><p>进入博客目录</p>\n</li>\n<li><p>执行以下命令更新</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">git add . #把需要更新的所有文件添加到本地仓库</div><div class=\"line\">git commit -m &quot;update message&quot; # 提交到本地仓库</div><div class=\"line\">git push # 提交到远程仓库 这里只服务器</div></pre></td></tr></table></figure>\n</li>\n<li><p>如果提示需要输入密码 输入服务器密码即可</p>\n</li>\n</ul>\n</li>\n<li><p>如果提交的时候提示<code>cp: target &#39;* * *&#39; is not a directory</code>意思是这不是一个目录, 所以要去创建一个目录</p>\n<ul>\n<li>上文<code>PUBLIC_WWW</code>表示网站的根目录, </li>\n<li>直接执行<code>mkdir /var/www/yuxiang.ren</code> 创建网站根目录</li>\n<li>再次提交<ul>\n<li>提示<code>Everything up-to-date</code></li>\n<li>那就随便改一下重新部署并提交呗</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h1 id=\"五-博客的配置-主体更换\"><a href=\"#五-博客的配置-主体更换\" class=\"headerlink\" title=\"五. 博客的配置, 主体更换,\"></a>五. 博客的配置, 主体更换,</h1><p> 插件: <a href=\"https://hexo.io/plugins/\" target=\"_blank\" rel=\"external\">https://hexo.io/plugins/</a></p>\n<p>主题: <a href=\"https://hexo.io/themes/\" target=\"_blank\" rel=\"external\">https://hexo.io/themes/</a></p>\n<p>……</p>\n<p>自行 百度/Google</p>\n<h1 id=\"六-发布文章\"><a href=\"#六-发布文章\" class=\"headerlink\" title=\"六. 发布文章\"></a>六. 发布文章</h1><ol>\n<li><p>进入网站根目录</p>\n</li>\n<li><p><code>hexo new 文章名字</code></p>\n</li>\n<li><p>编辑<code>/source/_posts/文章名字.md</code> 文件使用的是MarkDown语法</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">title: title  #文章的标题</div><div class=\"line\">date: yyyy-mm-dd #创建时间</div><div class=\"line\">   categories: category #分类</div><div class=\"line\">   tags: tag #标签</div><div class=\"line\"><span class=\"code\">      </span></div><div class=\"line\">   #多标签请这样写：tags: [tag1,tag2,tag3]</div><div class=\"line\">   #或者这样写： </div><div class=\"line\"><span class=\"code\">    #tags: </span></div><div class=\"line\"><span class=\"code\">      #- tag1</span></div><div class=\"line\"><span class=\"code\">      #- tag2 </span></div><div class=\"line\"><span class=\"code\">      #- tag3 </span></div><div class=\"line\">   ---  </div><div class=\"line\"><span class=\"code\">     </span></div><div class=\"line\">   #正文</div></pre></td></tr></table></figure>\n</li>\n<li><p>正文写完后可以再本地此时下</p>\n<ul>\n<li><code>hexo d -fg</code></li>\n<li><code>hexo s</code></li>\n<li>然后访问 <a href=\"http://localhost:4000\" target=\"_blank\" rel=\"external\">http://localhost:4000</a> </li>\n</ul>\n</li>\n<li><p>提交到服务器</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">git add .</div><div class=\"line\">git commit -m &quot;操作内容&quot;</div><div class=\"line\">git push</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<h1 id=\"七-域名绑定\"><a href=\"#七-域名绑定\" class=\"headerlink\" title=\"七. 域名绑定\"></a>七. 域名绑定</h1><p>自行 百度/Google</p>\n<h1 id=\"八-最后\"><a href=\"#八-最后\" class=\"headerlink\" title=\"八. 最后\"></a>八. 最后</h1><p>当然你也可以放在Github上, 请自行 百度/Google</p>"},{"title":"利用pods给你的程序添加第三方库","date":"2016-03-21T06:31:45.000Z","_content":"\n## CocoaPods的安装\n* 打开Terminal执行:\n  `$ sudo gem install cocoapods`\n* 执行完这句如果报告以下错误：\n\n        ERROR: Could not find a valid gem 'cocoapods' (>= 0), here is why:\n        Unable to download data from https://rubygems.org/ - Errno::ETIMEDOUT: Operation timed out - connect(2) (https://rubygems.org/latest_specs.4.8.gz)\n        ERROR: Possible alternatives: cocoapods\n\n<!-- more -->\n* 这是因为ruby的软件源rubygems.org因为使用亚马逊的云服务，被我天朝屏蔽了，需要更新一下ruby的源，过程如下：\n\n```\n$ gem sources -l (查看当前ruby的源)\n$ gem sources --remove https://rubygems.org/\n$ gem sources -a https://ruby.taobao.org/\n$ gem sources -l\n```\n* 如果gem太老，可以尝试用如下命令升级gem\n    `$ sudo gem update --system`\n* 升级成功后会提示:**RubyGems system software updated**\n* 然后重新执行安装下载命令:\n  `$ sudo gem install cocoapods`\n* 接下来进行安装，执行：:\n  `$ pod setup`\n* Terminal会停留在 Setting up CocoaPods master repo 这个状态一段时间,是因为要进行下载安装,而且目录比较大,需要耐心等待一下.如果想加快速度,可使用cocoapods的镜像索引.\n* 至此,cocoapods已经成功\n\n## 利用cocoapods给你的程序添加第三方库\n* 打开Terminal,cd到你程序目录\n* 创建**Podfile**文件(一定要创建在跟.xcodeproj同级的目录下):\n  `$ touch Podfile`\n* 以安装AFN为例:\n  `$ pod search AFNetWorking`\n* 找到**-> AFNetworking**,如下显示,复制`pod 'AFNetworking', '~> 3.0.4'`\n```\n-> AFNetworking (3.0.4)\nA delightful iOS and OS X networking framework.\npod 'AFNetworking', '~> 3.0.4'\n- Homepage: https://github.com/AFNetworking/AFNetworking\n- Source:   https://github.com/AFNetworking/AFNetworking.git\n```\n* 编辑Podfile文件,推荐使用`vi`命令或Xcode编辑。不建议其他编辑器编辑，不然后面更新pods会有警告的。Terminal命令 :\n    `$ vim Podfile`\n* 将下面代码粘进去,然后保存退出 ,`#`为注释\n```\nuse_frameworks! #用于swift\nplatform :ios, '8.0' # 支持的ios版本\n#下面放需要导入的第三方库的名字\npod 'AFNetworking', '~> 3.0.4'\n```\n* 安装:\n  `pod install --verbose --no-repo-update`\n* 安装成功后项目文件夹里会出现`.xcwoekspace`的文件.以后只要写代码就打开xcworkspace这个文件写就好了。 打开之前的那个xocdeproj写的话会出现问题。\n* 新建的项目添加的话 会遇到搜索不到头文件。。需要配置点东西\n    点击项目->Build->Settings,搜索`header`,找到`User Header Search Patchs`,添加参数**${SRCROOT}**并将后边的属性改为**recursive**。\n* 或者通过`#import <>`导入\n\n\n## 其他命令\n* 卸载原有的CocoaPod:\n  `sudo gem uninstall cocoapods`\n* 重新安装cocoapod:\n  `sudo gem install -n /usr/local/bin cocoapods`\n\n## 常见问题\n1. 卡在Updating local specs repositories:**pod install**被墙了，请大家换成:\n    `pod install --verbose --no-repo-update`\n    `pod update --verbose --no-repo-update`\n2. 出现这种警告:\n\n        Your Podfile has had smart quotes sanitised. To avoid issues in the future, you should not use TextEdit for editing it. If you are not using TextEdit, you should turn off smart quotes in your editor of choice.\n* **解决方法**:不要使用文本编辑去编辑Podfile，使用Xcode编辑，或者使用终端敲命令去编辑。或者输入格式错误，没输入运行版本：`$platform:ios, ‘8.0‘`\n3. 使用cocoapods导入第三方类库后头文件没有代码提示**解决方法**:\n    选择Target -> Build Settings 菜单，找到`User Header Search Paths`设置项，新增一个值**${SRCROOT}**，并且选择**Recursive**\n4. `pod setup` 报**CocoaPods was not able to update the `master` repo** 错误**解决方法**\n    * 先删除全局的缓存：\n       `$ sudo rm -fr ~/Library/Caches/CocoaPods/`\n        `$ sudo rm -fr ~/.cocoapods/repos/master/`\n    * 还不行的话就把当前 Pods 目录清空：\n       `$ sudo rm -fr Pods/`\n    * 再执行\n      `$ sudo gem install cocoapods`\n    * 重新执行\n      `$ pod setup`\n\n\n","source":"_posts/利用pods给你的程序添加第三方库.md","raw":"---\ntitle: 利用pods给你的程序添加第三方库\ndate: 2016-03-21 14:31:45\ncategories: 教程\ntags: CocoaPods\n---\n\n## CocoaPods的安装\n* 打开Terminal执行:\n  `$ sudo gem install cocoapods`\n* 执行完这句如果报告以下错误：\n\n        ERROR: Could not find a valid gem 'cocoapods' (>= 0), here is why:\n        Unable to download data from https://rubygems.org/ - Errno::ETIMEDOUT: Operation timed out - connect(2) (https://rubygems.org/latest_specs.4.8.gz)\n        ERROR: Possible alternatives: cocoapods\n\n<!-- more -->\n* 这是因为ruby的软件源rubygems.org因为使用亚马逊的云服务，被我天朝屏蔽了，需要更新一下ruby的源，过程如下：\n\n```\n$ gem sources -l (查看当前ruby的源)\n$ gem sources --remove https://rubygems.org/\n$ gem sources -a https://ruby.taobao.org/\n$ gem sources -l\n```\n* 如果gem太老，可以尝试用如下命令升级gem\n    `$ sudo gem update --system`\n* 升级成功后会提示:**RubyGems system software updated**\n* 然后重新执行安装下载命令:\n  `$ sudo gem install cocoapods`\n* 接下来进行安装，执行：:\n  `$ pod setup`\n* Terminal会停留在 Setting up CocoaPods master repo 这个状态一段时间,是因为要进行下载安装,而且目录比较大,需要耐心等待一下.如果想加快速度,可使用cocoapods的镜像索引.\n* 至此,cocoapods已经成功\n\n## 利用cocoapods给你的程序添加第三方库\n* 打开Terminal,cd到你程序目录\n* 创建**Podfile**文件(一定要创建在跟.xcodeproj同级的目录下):\n  `$ touch Podfile`\n* 以安装AFN为例:\n  `$ pod search AFNetWorking`\n* 找到**-> AFNetworking**,如下显示,复制`pod 'AFNetworking', '~> 3.0.4'`\n```\n-> AFNetworking (3.0.4)\nA delightful iOS and OS X networking framework.\npod 'AFNetworking', '~> 3.0.4'\n- Homepage: https://github.com/AFNetworking/AFNetworking\n- Source:   https://github.com/AFNetworking/AFNetworking.git\n```\n* 编辑Podfile文件,推荐使用`vi`命令或Xcode编辑。不建议其他编辑器编辑，不然后面更新pods会有警告的。Terminal命令 :\n    `$ vim Podfile`\n* 将下面代码粘进去,然后保存退出 ,`#`为注释\n```\nuse_frameworks! #用于swift\nplatform :ios, '8.0' # 支持的ios版本\n#下面放需要导入的第三方库的名字\npod 'AFNetworking', '~> 3.0.4'\n```\n* 安装:\n  `pod install --verbose --no-repo-update`\n* 安装成功后项目文件夹里会出现`.xcwoekspace`的文件.以后只要写代码就打开xcworkspace这个文件写就好了。 打开之前的那个xocdeproj写的话会出现问题。\n* 新建的项目添加的话 会遇到搜索不到头文件。。需要配置点东西\n    点击项目->Build->Settings,搜索`header`,找到`User Header Search Patchs`,添加参数**${SRCROOT}**并将后边的属性改为**recursive**。\n* 或者通过`#import <>`导入\n\n\n## 其他命令\n* 卸载原有的CocoaPod:\n  `sudo gem uninstall cocoapods`\n* 重新安装cocoapod:\n  `sudo gem install -n /usr/local/bin cocoapods`\n\n## 常见问题\n1. 卡在Updating local specs repositories:**pod install**被墙了，请大家换成:\n    `pod install --verbose --no-repo-update`\n    `pod update --verbose --no-repo-update`\n2. 出现这种警告:\n\n        Your Podfile has had smart quotes sanitised. To avoid issues in the future, you should not use TextEdit for editing it. If you are not using TextEdit, you should turn off smart quotes in your editor of choice.\n* **解决方法**:不要使用文本编辑去编辑Podfile，使用Xcode编辑，或者使用终端敲命令去编辑。或者输入格式错误，没输入运行版本：`$platform:ios, ‘8.0‘`\n3. 使用cocoapods导入第三方类库后头文件没有代码提示**解决方法**:\n    选择Target -> Build Settings 菜单，找到`User Header Search Paths`设置项，新增一个值**${SRCROOT}**，并且选择**Recursive**\n4. `pod setup` 报**CocoaPods was not able to update the `master` repo** 错误**解决方法**\n    * 先删除全局的缓存：\n       `$ sudo rm -fr ~/Library/Caches/CocoaPods/`\n        `$ sudo rm -fr ~/.cocoapods/repos/master/`\n    * 还不行的话就把当前 Pods 目录清空：\n       `$ sudo rm -fr Pods/`\n    * 再执行\n      `$ sudo gem install cocoapods`\n    * 重新执行\n      `$ pod setup`\n\n\n","slug":"利用pods给你的程序添加第三方库","published":1,"updated":"2017-04-28T08:34:43.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6686xmz002bxe9zrarsy2w3","content":"<h2 id=\"CocoaPods的安装\"><a href=\"#CocoaPods的安装\" class=\"headerlink\" title=\"CocoaPods的安装\"></a>CocoaPods的安装</h2><ul>\n<li>打开Terminal执行:<br><code>$ sudo gem install cocoapods</code></li>\n<li><p>执行完这句如果报告以下错误：</p>\n<pre><code>ERROR: Could not find a valid gem &apos;cocoapods&apos; (&gt;= 0), here is why:\nUnable to download data from https://rubygems.org/ - Errno::ETIMEDOUT: Operation timed out - connect(2) (https://rubygems.org/latest_specs.4.8.gz)\nERROR: Possible alternatives: cocoapods\n</code></pre></li>\n</ul>\n<a id=\"more\"></a>\n<ul>\n<li>这是因为ruby的软件源rubygems.org因为使用亚马逊的云服务，被我天朝屏蔽了，需要更新一下ruby的源，过程如下：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ gem sources -l (查看当前ruby的源)</div><div class=\"line\">$ gem sources --remove https://rubygems.org/</div><div class=\"line\">$ gem sources -a https://ruby.taobao.org/</div><div class=\"line\">$ gem sources -l</div></pre></td></tr></table></figure>\n<ul>\n<li>如果gem太老，可以尝试用如下命令升级gem<br>  <code>$ sudo gem update --system</code></li>\n<li>升级成功后会提示:<strong>RubyGems system software updated</strong></li>\n<li>然后重新执行安装下载命令:<br><code>$ sudo gem install cocoapods</code></li>\n<li>接下来进行安装，执行：:<br><code>$ pod setup</code></li>\n<li>Terminal会停留在 Setting up CocoaPods master repo 这个状态一段时间,是因为要进行下载安装,而且目录比较大,需要耐心等待一下.如果想加快速度,可使用cocoapods的镜像索引.</li>\n<li>至此,cocoapods已经成功</li>\n</ul>\n<h2 id=\"利用cocoapods给你的程序添加第三方库\"><a href=\"#利用cocoapods给你的程序添加第三方库\" class=\"headerlink\" title=\"利用cocoapods给你的程序添加第三方库\"></a>利用cocoapods给你的程序添加第三方库</h2><ul>\n<li>打开Terminal,cd到你程序目录</li>\n<li>创建<strong>Podfile</strong>文件(一定要创建在跟.xcodeproj同级的目录下):<br><code>$ touch Podfile</code></li>\n<li>以安装AFN为例:<br><code>$ pod search AFNetWorking</code></li>\n<li><p>找到<strong>-&gt; AFNetworking</strong>,如下显示,复制<code>pod &#39;AFNetworking&#39;, &#39;~&gt; 3.0.4&#39;</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">-&gt; AFNetworking (3.0.4)</div><div class=\"line\">A delightful iOS and OS X networking framework.</div><div class=\"line\">pod &apos;AFNetworking&apos;, &apos;~&gt; 3.0.4&apos;</div><div class=\"line\">- Homepage: https://github.com/AFNetworking/AFNetworking</div><div class=\"line\">- Source:   https://github.com/AFNetworking/AFNetworking.git</div></pre></td></tr></table></figure>\n</li>\n<li><p>编辑Podfile文件,推荐使用<code>vi</code>命令或Xcode编辑。不建议其他编辑器编辑，不然后面更新pods会有警告的。Terminal命令 :<br>  <code>$ vim Podfile</code></p>\n</li>\n<li><p>将下面代码粘进去,然后保存退出 ,<code>#</code>为注释</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">use_frameworks! #用于swift</div><div class=\"line\">platform :ios, &apos;8.0&apos; # 支持的ios版本</div><div class=\"line\">#下面放需要导入的第三方库的名字</div><div class=\"line\">pod &apos;AFNetworking&apos;, &apos;~&gt; 3.0.4&apos;</div></pre></td></tr></table></figure>\n</li>\n<li><p>安装:<br><code>pod install --verbose --no-repo-update</code></p>\n</li>\n<li>安装成功后项目文件夹里会出现<code>.xcwoekspace</code>的文件.以后只要写代码就打开xcworkspace这个文件写就好了。 打开之前的那个xocdeproj写的话会出现问题。</li>\n<li>新建的项目添加的话 会遇到搜索不到头文件。。需要配置点东西<br>  点击项目-&gt;Build-&gt;Settings,搜索<code>header</code>,找到<code>User Header Search Patchs</code>,添加参数<strong>${SRCROOT}</strong>并将后边的属性改为<strong>recursive</strong>。</li>\n<li>或者通过<code>#import &lt;&gt;</code>导入</li>\n</ul>\n<h2 id=\"其他命令\"><a href=\"#其他命令\" class=\"headerlink\" title=\"其他命令\"></a>其他命令</h2><ul>\n<li>卸载原有的CocoaPod:<br><code>sudo gem uninstall cocoapods</code></li>\n<li>重新安装cocoapod:<br><code>sudo gem install -n /usr/local/bin cocoapods</code></li>\n</ul>\n<h2 id=\"常见问题\"><a href=\"#常见问题\" class=\"headerlink\" title=\"常见问题\"></a>常见问题</h2><ol>\n<li>卡在Updating local specs repositories:<strong>pod install</strong>被墙了，请大家换成:<br> <code>pod install --verbose --no-repo-update</code><br> <code>pod update --verbose --no-repo-update</code></li>\n<li><p>出现这种警告:</p>\n<pre><code>Your Podfile has had smart quotes sanitised. To avoid issues in the future, you should not use TextEdit for editing it. If you are not using TextEdit, you should turn off smart quotes in your editor of choice.\n</code></pre></li>\n</ol>\n<ul>\n<li><strong>解决方法</strong>:不要使用文本编辑去编辑Podfile，使用Xcode编辑，或者使用终端敲命令去编辑。或者输入格式错误，没输入运行版本：<code>$platform:ios, ‘8.0‘</code></li>\n</ul>\n<ol>\n<li>使用cocoapods导入第三方类库后头文件没有代码提示<strong>解决方法</strong>:<br> 选择Target -&gt; Build Settings 菜单，找到<code>User Header Search Paths</code>设置项，新增一个值<strong>${SRCROOT}</strong>，并且选择<strong>Recursive</strong></li>\n<li><code>pod setup</code> 报<strong>CocoaPods was not able to update the <code>master</code> repo</strong> 错误<strong>解决方法</strong><ul>\n<li>先删除全局的缓存：<br> <code>$ sudo rm -fr ~/Library/Caches/CocoaPods/</code><br>  <code>$ sudo rm -fr ~/.cocoapods/repos/master/</code></li>\n<li>还不行的话就把当前 Pods 目录清空：<br> <code>$ sudo rm -fr Pods/</code></li>\n<li>再执行<br><code>$ sudo gem install cocoapods</code></li>\n<li>重新执行<br><code>$ pod setup</code></li>\n</ul>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"<h2 id=\"CocoaPods的安装\"><a href=\"#CocoaPods的安装\" class=\"headerlink\" title=\"CocoaPods的安装\"></a>CocoaPods的安装</h2><ul>\n<li>打开Terminal执行:<br><code>$ sudo gem install cocoapods</code></li>\n<li><p>执行完这句如果报告以下错误：</p>\n<pre><code>ERROR: Could not find a valid gem &apos;cocoapods&apos; (&gt;= 0), here is why:\nUnable to download data from https://rubygems.org/ - Errno::ETIMEDOUT: Operation timed out - connect(2) (https://rubygems.org/latest_specs.4.8.gz)\nERROR: Possible alternatives: cocoapods\n</code></pre></li>\n</ul>","more":"<ul>\n<li>这是因为ruby的软件源rubygems.org因为使用亚马逊的云服务，被我天朝屏蔽了，需要更新一下ruby的源，过程如下：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ gem sources -l (查看当前ruby的源)</div><div class=\"line\">$ gem sources --remove https://rubygems.org/</div><div class=\"line\">$ gem sources -a https://ruby.taobao.org/</div><div class=\"line\">$ gem sources -l</div></pre></td></tr></table></figure>\n<ul>\n<li>如果gem太老，可以尝试用如下命令升级gem<br>  <code>$ sudo gem update --system</code></li>\n<li>升级成功后会提示:<strong>RubyGems system software updated</strong></li>\n<li>然后重新执行安装下载命令:<br><code>$ sudo gem install cocoapods</code></li>\n<li>接下来进行安装，执行：:<br><code>$ pod setup</code></li>\n<li>Terminal会停留在 Setting up CocoaPods master repo 这个状态一段时间,是因为要进行下载安装,而且目录比较大,需要耐心等待一下.如果想加快速度,可使用cocoapods的镜像索引.</li>\n<li>至此,cocoapods已经成功</li>\n</ul>\n<h2 id=\"利用cocoapods给你的程序添加第三方库\"><a href=\"#利用cocoapods给你的程序添加第三方库\" class=\"headerlink\" title=\"利用cocoapods给你的程序添加第三方库\"></a>利用cocoapods给你的程序添加第三方库</h2><ul>\n<li>打开Terminal,cd到你程序目录</li>\n<li>创建<strong>Podfile</strong>文件(一定要创建在跟.xcodeproj同级的目录下):<br><code>$ touch Podfile</code></li>\n<li>以安装AFN为例:<br><code>$ pod search AFNetWorking</code></li>\n<li><p>找到<strong>-&gt; AFNetworking</strong>,如下显示,复制<code>pod &#39;AFNetworking&#39;, &#39;~&gt; 3.0.4&#39;</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">-&gt; AFNetworking (3.0.4)</div><div class=\"line\">A delightful iOS and OS X networking framework.</div><div class=\"line\">pod &apos;AFNetworking&apos;, &apos;~&gt; 3.0.4&apos;</div><div class=\"line\">- Homepage: https://github.com/AFNetworking/AFNetworking</div><div class=\"line\">- Source:   https://github.com/AFNetworking/AFNetworking.git</div></pre></td></tr></table></figure>\n</li>\n<li><p>编辑Podfile文件,推荐使用<code>vi</code>命令或Xcode编辑。不建议其他编辑器编辑，不然后面更新pods会有警告的。Terminal命令 :<br>  <code>$ vim Podfile</code></p>\n</li>\n<li><p>将下面代码粘进去,然后保存退出 ,<code>#</code>为注释</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">use_frameworks! #用于swift</div><div class=\"line\">platform :ios, &apos;8.0&apos; # 支持的ios版本</div><div class=\"line\">#下面放需要导入的第三方库的名字</div><div class=\"line\">pod &apos;AFNetworking&apos;, &apos;~&gt; 3.0.4&apos;</div></pre></td></tr></table></figure>\n</li>\n<li><p>安装:<br><code>pod install --verbose --no-repo-update</code></p>\n</li>\n<li>安装成功后项目文件夹里会出现<code>.xcwoekspace</code>的文件.以后只要写代码就打开xcworkspace这个文件写就好了。 打开之前的那个xocdeproj写的话会出现问题。</li>\n<li>新建的项目添加的话 会遇到搜索不到头文件。。需要配置点东西<br>  点击项目-&gt;Build-&gt;Settings,搜索<code>header</code>,找到<code>User Header Search Patchs</code>,添加参数<strong>${SRCROOT}</strong>并将后边的属性改为<strong>recursive</strong>。</li>\n<li>或者通过<code>#import &lt;&gt;</code>导入</li>\n</ul>\n<h2 id=\"其他命令\"><a href=\"#其他命令\" class=\"headerlink\" title=\"其他命令\"></a>其他命令</h2><ul>\n<li>卸载原有的CocoaPod:<br><code>sudo gem uninstall cocoapods</code></li>\n<li>重新安装cocoapod:<br><code>sudo gem install -n /usr/local/bin cocoapods</code></li>\n</ul>\n<h2 id=\"常见问题\"><a href=\"#常见问题\" class=\"headerlink\" title=\"常见问题\"></a>常见问题</h2><ol>\n<li>卡在Updating local specs repositories:<strong>pod install</strong>被墙了，请大家换成:<br> <code>pod install --verbose --no-repo-update</code><br> <code>pod update --verbose --no-repo-update</code></li>\n<li><p>出现这种警告:</p>\n<pre><code>Your Podfile has had smart quotes sanitised. To avoid issues in the future, you should not use TextEdit for editing it. If you are not using TextEdit, you should turn off smart quotes in your editor of choice.\n</code></pre></li>\n</ol>\n<ul>\n<li><strong>解决方法</strong>:不要使用文本编辑去编辑Podfile，使用Xcode编辑，或者使用终端敲命令去编辑。或者输入格式错误，没输入运行版本：<code>$platform:ios, ‘8.0‘</code></li>\n</ul>\n<ol>\n<li>使用cocoapods导入第三方类库后头文件没有代码提示<strong>解决方法</strong>:<br> 选择Target -&gt; Build Settings 菜单，找到<code>User Header Search Paths</code>设置项，新增一个值<strong>${SRCROOT}</strong>，并且选择<strong>Recursive</strong></li>\n<li><code>pod setup</code> 报<strong>CocoaPods was not able to update the <code>master</code> repo</strong> 错误<strong>解决方法</strong><ul>\n<li>先删除全局的缓存：<br> <code>$ sudo rm -fr ~/Library/Caches/CocoaPods/</code><br>  <code>$ sudo rm -fr ~/.cocoapods/repos/master/</code></li>\n<li>还不行的话就把当前 Pods 目录清空：<br> <code>$ sudo rm -fr Pods/</code></li>\n<li>再执行<br><code>$ sudo gem install cocoapods</code></li>\n<li>重新执行<br><code>$ pod setup</code></li>\n</ul>\n</li>\n</ol>"},{"title":"命令安装Mac系统","date":"2016-03-21T10:12:35.000Z","_content":"\n1. 下载MAC Install OS X El Capitan系统并放到application中\n2. 格式化U盘(8GB以上),命名为Untitled\n3. 打开Terminal执行命令:\n   `sudo /Applications/Install\\ OS\\ X\\ El\\ Capitan.app/Contents/Resources/createinstallmedia --volume /Volumes/Untitled --applicationpath /Applications/Install\\ OS\\ X\\ El\\ Capitan.app --nointeraction`\n\n<!-- more -->\n4. 当Terminal出现**Done**字样时表示制作完成\n5. 启动MAC并按住`option`键,选择**Install OS X El Capitan**\n6. 进入磁盘工具,格式化电脑主硬盘\n7. 安装OS X El Capitan\n\n\n","source":"_posts/命令安装Mac系统.md","raw":"---\ntitle: 命令安装Mac系统\ndate: 2016-03-21 18:12:35\ncategories: 教程\ntags: [命令, MacOS]\n---\n\n1. 下载MAC Install OS X El Capitan系统并放到application中\n2. 格式化U盘(8GB以上),命名为Untitled\n3. 打开Terminal执行命令:\n   `sudo /Applications/Install\\ OS\\ X\\ El\\ Capitan.app/Contents/Resources/createinstallmedia --volume /Volumes/Untitled --applicationpath /Applications/Install\\ OS\\ X\\ El\\ Capitan.app --nointeraction`\n\n<!-- more -->\n4. 当Terminal出现**Done**字样时表示制作完成\n5. 启动MAC并按住`option`键,选择**Install OS X El Capitan**\n6. 进入磁盘工具,格式化电脑主硬盘\n7. 安装OS X El Capitan\n\n\n","slug":"命令安装Mac系统","published":1,"updated":"2017-04-28T08:36:13.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6686xn2002gxe9z7jzjyvmd","content":"<ol>\n<li>下载MAC Install OS X El Capitan系统并放到application中</li>\n<li>格式化U盘(8GB以上),命名为Untitled</li>\n<li>打开Terminal执行命令:<br><code>sudo /Applications/Install\\ OS\\ X\\ El\\ Capitan.app/Contents/Resources/createinstallmedia --volume /Volumes/Untitled --applicationpath /Applications/Install\\ OS\\ X\\ El\\ Capitan.app --nointeraction</code></li>\n</ol>\n<a id=\"more\"></a>\n<ol>\n<li>当Terminal出现<strong>Done</strong>字样时表示制作完成</li>\n<li>启动MAC并按住<code>option</code>键,选择<strong>Install OS X El Capitan</strong></li>\n<li>进入磁盘工具,格式化电脑主硬盘</li>\n<li>安装OS X El Capitan</li>\n</ol>\n","site":{"data":{}},"excerpt":"<ol>\n<li>下载MAC Install OS X El Capitan系统并放到application中</li>\n<li>格式化U盘(8GB以上),命名为Untitled</li>\n<li>打开Terminal执行命令:<br><code>sudo /Applications/Install\\ OS\\ X\\ El\\ Capitan.app/Contents/Resources/createinstallmedia --volume /Volumes/Untitled --applicationpath /Applications/Install\\ OS\\ X\\ El\\ Capitan.app --nointeraction</code></li>\n</ol>","more":"<ol>\n<li>当Terminal出现<strong>Done</strong>字样时表示制作完成</li>\n<li>启动MAC并按住<code>option</code>键,选择<strong>Install OS X El Capitan</strong></li>\n<li>进入磁盘工具,格式化电脑主硬盘</li>\n<li>安装OS X El Capitan</li>\n</ol>"},{"title":"命令给安卓程序打包","date":"2017-04-12T03:05:07.000Z","_content":"\n在命令行，进入到项目（project，一定是project，而不是Module）对应的目录。\n\n1. 先执行改变gradle的权限。\n\n   ```shell\n   chmod +x gradlew\n   ```\n\n\n2. 然后运行打包\n\n   ```shell\n   ./gradlew assembleRelease\n   ```\n   <!-- more -->\n\n3. 出现`BUILD SUCCESSFUL`后安装到手机\n\n   ```shell\n   adb install <apk路径>\n   ```\n","source":"_posts/命令给安卓程序打包.md","raw":"---\ntitle: 命令给安卓程序打包\ndate: 2017-04-12 11:05:07\ncategories: Android\ntags: Android\n---\n\n在命令行，进入到项目（project，一定是project，而不是Module）对应的目录。\n\n1. 先执行改变gradle的权限。\n\n   ```shell\n   chmod +x gradlew\n   ```\n\n\n2. 然后运行打包\n\n   ```shell\n   ./gradlew assembleRelease\n   ```\n   <!-- more -->\n\n3. 出现`BUILD SUCCESSFUL`后安装到手机\n\n   ```shell\n   adb install <apk路径>\n   ```\n","slug":"命令给安卓程序打包","published":1,"updated":"2017-04-28T08:36:22.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6686xn3002ixe9zgfydnmju","content":"<p>在命令行，进入到项目（project，一定是project，而不是Module）对应的目录。</p>\n<ol>\n<li><p>先执行改变gradle的权限。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">chmod +x gradlew</div></pre></td></tr></table></figure>\n</li>\n<li><p>然后运行打包</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">./gradlew assembleRelease</div></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n</li>\n<li><p>出现<code>BUILD SUCCESSFUL</code>后安装到手机</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">adb install &lt;apk路径&gt;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>在命令行，进入到项目（project，一定是project，而不是Module）对应的目录。</p>\n<ol>\n<li><p>先执行改变gradle的权限。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">chmod +x gradlew</div></pre></td></tr></table></figure>\n</li>\n<li><p>然后运行打包</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">./gradlew assembleRelease</div></pre></td></tr></table></figure>","more":"</li>\n<li><p>出现<code>BUILD SUCCESSFUL</code>后安装到手机</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">adb install &lt;apk路径&gt;</div></pre></td></tr></table></figure>\n</li>\n</ol>"},{"title":"在Mac上配置Rect Native开发环境","date":"2017-03-30T07:06:25.000Z","_content":"\n\n\n## 一. 环境需求\n\n1 .  安装Homebrew(可选)\n\n```shell\nruby -e \"$(curl -fsSL <a href=\"https://raw.githubusercontent.com/Homebrew/install/master/install\">https://raw.githubusercontent.com/Homebrew/install/master/install</a>)\n```\n\n\n2. 安装`watchman` (用于监控bug文件)\n\n   ```Shell\n   brew install watchman\n   ```\n\n3. 安装`flow`(用于找出代码中可能存在的类型错误)\n\n   ```shell\n   bew install flow\n   ```\n\n\n<!-- more -->\n\n### 二. ios环境\n\n* Xcode7及以上版本\n\n### 三. 安装`React Native`\n\n1. 安装命令\n\n   ```shell\n   npm install -fg react-native-cli\n   ```\n\n   * 出现下图情况需要用管理员权限\n   * ![690](https://ww4.sinaimg.cn/mw690/6a80ef0fgw1f4a5eimqh5j214m0t6ti8.jpg)\n\n### 四. 创建`RReact Native`工程\n\n* react-native init demo\n\n  ```\n  react-native init demo\n  ```\n\n* 可能需要等待一段时间\n\n  ![](https://ww1.sinaimg.cn/mw690/6a80ef0fgw1f4a4q7xtxij20v404ywfr.jpg)\n\n* 出现下图所示表示初始化成功\n\n  ![](https://ww2.sinaimg.cn/mw690/6a80ef0fgw1f4a4q94jjsj20us0e60wh.jpg)\n\n* 目录结构分析\n\n  * 默认生成`iOS`和`Android`两个平台的项目\n  * 其中, `index.android.js`和`index.ios.js`是`Android`和`iOS`的空壳应用文件\n  * `node_modules`文件夹是为`Node.js`存放和管理npm包资源,也包含`react-native`框架文件\n\n* 运行`iOS`程序\n\n  * 打开`ios`文件夹下的`demo.xcodeproj`,`command+r`运行\n\n  * 启动`React native`服务器,不要关闭此窗口\n\n    ![](https://ww4.sinaimg.cn/mw690/6a80ef0fgw1f4a57e98fwj20vo0lojvz.jpg)\n\n  * 客户端运行界面\n\n    ![](https://ww4.sinaimg.cn/mw690/6a80ef0fgw1f4a58cn2ukj20ku12a75q.jpg)","source":"_posts/在Mac上配置Rect-Native开发环境.md","raw":"---\ntitle: 在Mac上配置Rect Native开发环境\ndate: 2017-03-30 15:06:25\ncategories: 教程\ntags: [教程 MacOS]\n---\n\n\n\n## 一. 环境需求\n\n1 .  安装Homebrew(可选)\n\n```shell\nruby -e \"$(curl -fsSL <a href=\"https://raw.githubusercontent.com/Homebrew/install/master/install\">https://raw.githubusercontent.com/Homebrew/install/master/install</a>)\n```\n\n\n2. 安装`watchman` (用于监控bug文件)\n\n   ```Shell\n   brew install watchman\n   ```\n\n3. 安装`flow`(用于找出代码中可能存在的类型错误)\n\n   ```shell\n   bew install flow\n   ```\n\n\n<!-- more -->\n\n### 二. ios环境\n\n* Xcode7及以上版本\n\n### 三. 安装`React Native`\n\n1. 安装命令\n\n   ```shell\n   npm install -fg react-native-cli\n   ```\n\n   * 出现下图情况需要用管理员权限\n   * ![690](https://ww4.sinaimg.cn/mw690/6a80ef0fgw1f4a5eimqh5j214m0t6ti8.jpg)\n\n### 四. 创建`RReact Native`工程\n\n* react-native init demo\n\n  ```\n  react-native init demo\n  ```\n\n* 可能需要等待一段时间\n\n  ![](https://ww1.sinaimg.cn/mw690/6a80ef0fgw1f4a4q7xtxij20v404ywfr.jpg)\n\n* 出现下图所示表示初始化成功\n\n  ![](https://ww2.sinaimg.cn/mw690/6a80ef0fgw1f4a4q94jjsj20us0e60wh.jpg)\n\n* 目录结构分析\n\n  * 默认生成`iOS`和`Android`两个平台的项目\n  * 其中, `index.android.js`和`index.ios.js`是`Android`和`iOS`的空壳应用文件\n  * `node_modules`文件夹是为`Node.js`存放和管理npm包资源,也包含`react-native`框架文件\n\n* 运行`iOS`程序\n\n  * 打开`ios`文件夹下的`demo.xcodeproj`,`command+r`运行\n\n  * 启动`React native`服务器,不要关闭此窗口\n\n    ![](https://ww4.sinaimg.cn/mw690/6a80ef0fgw1f4a57e98fwj20vo0lojvz.jpg)\n\n  * 客户端运行界面\n\n    ![](https://ww4.sinaimg.cn/mw690/6a80ef0fgw1f4a58cn2ukj20ku12a75q.jpg)","slug":"在Mac上配置Rect-Native开发环境","published":1,"updated":"2017-04-28T08:36:43.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6686xn6002mxe9z9t9akzp4","content":"<h2 id=\"一-环境需求\"><a href=\"#一-环境需求\" class=\"headerlink\" title=\"一. 环境需求\"></a>一. 环境需求</h2><p>1 .  安装Homebrew(可选)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">ruby -e &quot;$(curl -fsSL &lt;a href=&quot;https://raw.githubusercontent.com/Homebrew/install/master/install&quot;&gt;https://raw.githubusercontent.com/Homebrew/install/master/install&lt;/a&gt;)</div></pre></td></tr></table></figure>\n<ol>\n<li><p>安装<code>watchman</code> (用于监控bug文件)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">brew install watchman</div></pre></td></tr></table></figure>\n</li>\n<li><p>安装<code>flow</code>(用于找出代码中可能存在的类型错误)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">bew install flow</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<a id=\"more\"></a>\n<h3 id=\"二-ios环境\"><a href=\"#二-ios环境\" class=\"headerlink\" title=\"二. ios环境\"></a>二. ios环境</h3><ul>\n<li>Xcode7及以上版本</li>\n</ul>\n<h3 id=\"三-安装React-Native\"><a href=\"#三-安装React-Native\" class=\"headerlink\" title=\"三. 安装React Native\"></a>三. 安装<code>React Native</code></h3><ol>\n<li><p>安装命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install -fg react-native-cli</div></pre></td></tr></table></figure>\n<ul>\n<li>出现下图情况需要用管理员权限</li>\n<li><img src=\"https://ww4.sinaimg.cn/mw690/6a80ef0fgw1f4a5eimqh5j214m0t6ti8.jpg\" alt=\"690\"></li>\n</ul>\n</li>\n</ol>\n<h3 id=\"四-创建RReact-Native工程\"><a href=\"#四-创建RReact-Native工程\" class=\"headerlink\" title=\"四. 创建RReact Native工程\"></a>四. 创建<code>RReact Native</code>工程</h3><ul>\n<li><p>react-native init demo</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">react-native init demo</div></pre></td></tr></table></figure>\n</li>\n<li><p>可能需要等待一段时间</p>\n<p><img src=\"https://ww1.sinaimg.cn/mw690/6a80ef0fgw1f4a4q7xtxij20v404ywfr.jpg\" alt=\"\"></p>\n</li>\n<li><p>出现下图所示表示初始化成功</p>\n<p><img src=\"https://ww2.sinaimg.cn/mw690/6a80ef0fgw1f4a4q94jjsj20us0e60wh.jpg\" alt=\"\"></p>\n</li>\n<li><p>目录结构分析</p>\n<ul>\n<li>默认生成<code>iOS</code>和<code>Android</code>两个平台的项目</li>\n<li>其中, <code>index.android.js</code>和<code>index.ios.js</code>是<code>Android</code>和<code>iOS</code>的空壳应用文件</li>\n<li><code>node_modules</code>文件夹是为<code>Node.js</code>存放和管理npm包资源,也包含<code>react-native</code>框架文件</li>\n</ul>\n</li>\n<li><p>运行<code>iOS</code>程序</p>\n<ul>\n<li><p>打开<code>ios</code>文件夹下的<code>demo.xcodeproj</code>,<code>command+r</code>运行</p>\n</li>\n<li><p>启动<code>React native</code>服务器,不要关闭此窗口</p>\n<p><img src=\"https://ww4.sinaimg.cn/mw690/6a80ef0fgw1f4a57e98fwj20vo0lojvz.jpg\" alt=\"\"></p>\n</li>\n<li><p>客户端运行界面</p>\n<p><img src=\"https://ww4.sinaimg.cn/mw690/6a80ef0fgw1f4a58cn2ukj20ku12a75q.jpg\" alt=\"\"></p>\n</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"一-环境需求\"><a href=\"#一-环境需求\" class=\"headerlink\" title=\"一. 环境需求\"></a>一. 环境需求</h2><p>1 .  安装Homebrew(可选)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">ruby -e &quot;$(curl -fsSL &lt;a href=&quot;https://raw.githubusercontent.com/Homebrew/install/master/install&quot;&gt;https://raw.githubusercontent.com/Homebrew/install/master/install&lt;/a&gt;)</div></pre></td></tr></table></figure>\n<ol>\n<li><p>安装<code>watchman</code> (用于监控bug文件)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">brew install watchman</div></pre></td></tr></table></figure>\n</li>\n<li><p>安装<code>flow</code>(用于找出代码中可能存在的类型错误)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">bew install flow</div></pre></td></tr></table></figure>\n</li>\n</ol>","more":"<h3 id=\"二-ios环境\"><a href=\"#二-ios环境\" class=\"headerlink\" title=\"二. ios环境\"></a>二. ios环境</h3><ul>\n<li>Xcode7及以上版本</li>\n</ul>\n<h3 id=\"三-安装React-Native\"><a href=\"#三-安装React-Native\" class=\"headerlink\" title=\"三. 安装React Native\"></a>三. 安装<code>React Native</code></h3><ol>\n<li><p>安装命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install -fg react-native-cli</div></pre></td></tr></table></figure>\n<ul>\n<li>出现下图情况需要用管理员权限</li>\n<li><img src=\"https://ww4.sinaimg.cn/mw690/6a80ef0fgw1f4a5eimqh5j214m0t6ti8.jpg\" alt=\"690\"></li>\n</ul>\n</li>\n</ol>\n<h3 id=\"四-创建RReact-Native工程\"><a href=\"#四-创建RReact-Native工程\" class=\"headerlink\" title=\"四. 创建RReact Native工程\"></a>四. 创建<code>RReact Native</code>工程</h3><ul>\n<li><p>react-native init demo</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">react-native init demo</div></pre></td></tr></table></figure>\n</li>\n<li><p>可能需要等待一段时间</p>\n<p><img src=\"https://ww1.sinaimg.cn/mw690/6a80ef0fgw1f4a4q7xtxij20v404ywfr.jpg\" alt=\"\"></p>\n</li>\n<li><p>出现下图所示表示初始化成功</p>\n<p><img src=\"https://ww2.sinaimg.cn/mw690/6a80ef0fgw1f4a4q94jjsj20us0e60wh.jpg\" alt=\"\"></p>\n</li>\n<li><p>目录结构分析</p>\n<ul>\n<li>默认生成<code>iOS</code>和<code>Android</code>两个平台的项目</li>\n<li>其中, <code>index.android.js</code>和<code>index.ios.js</code>是<code>Android</code>和<code>iOS</code>的空壳应用文件</li>\n<li><code>node_modules</code>文件夹是为<code>Node.js</code>存放和管理npm包资源,也包含<code>react-native</code>框架文件</li>\n</ul>\n</li>\n<li><p>运行<code>iOS</code>程序</p>\n<ul>\n<li><p>打开<code>ios</code>文件夹下的<code>demo.xcodeproj</code>,<code>command+r</code>运行</p>\n</li>\n<li><p>启动<code>React native</code>服务器,不要关闭此窗口</p>\n<p><img src=\"https://ww4.sinaimg.cn/mw690/6a80ef0fgw1f4a57e98fwj20vo0lojvz.jpg\" alt=\"\"></p>\n</li>\n<li><p>客户端运行界面</p>\n<p><img src=\"https://ww4.sinaimg.cn/mw690/6a80ef0fgw1f4a58cn2ukj20ku12a75q.jpg\" alt=\"\"></p>\n</li>\n</ul>\n</li>\n</ul>"},{"title":"多线程","date":"2016-03-17T16:00:00.000Z","_content":"```\n异步函数+主队列    不会开线程,串行执行\n异步函数+并发队列  开多条线程,并发执行\n异步函数+串行队列  开一条线程,串行执行\n同步函数+并发队列  不会开线程,串行执行\n同步函数+串行执行  不会开线程,串行执行\n```\n\n<!-- more -->\n## 一、容易混淆的俗语\n　　有四个术语比较容易混淆：`同步`、`异步`、`并发`、`串行`.\n1. 同步和异步主要影响有:能不能开启新线程\n* 同步: 只能在当前线程中执行任务, 不具备开启新线程的能力\n* 异步: 可以在新的线程中执行任务, 具备开启新线程的能力\n2. 并发金和串行的只要影响: 任务的执行方式\n* 并发: 允许多个任务并发(同事执行)\n* 串行: 一个任务执行完毕后,在执行下一个任务\n\n## 二、执行任务\n 1、GCD中有2个用来执行任务的常用函数\n \t　用同步的方式执行任务\n 　\t`dispatch_sync(dispatch_queue_t queue, dispatch_block_t block);`\n\t\t　• queue  队列  \n\t\t　• block  任务\n\t　用异步的方式执行任务\n\t　`dispatch_async(dispatch_queue_t queue, dispatch_block_t block);`\n 2、GCD中还有个用来执行任务的函数：\n 　　`dispatch_barrier_async(dispatch_queue_t queue, dispatch_block_t block);`\n 　　在前面的任务执行结束后它才执行，而且它后面的任务执行完成后才会执行\n\t**注意**：这个`queue`不能是全局的并发列队\n\n## 三、列队的类型\n 1、并发列队\n\t　　可以让并发任务并发(同时)执行(自动开启多个线程同时执行任务)\n\t　　并发功能只有在异步(`dispatch_async`) 函数下才有效\n\t使用 `dispatch_queue_create` 函数创建队列\n\t​```\n\tdispatch_queue_t \n\tdispatch_queue_create(const char *label, //队列名称\n\tdispatch_queue_attr_t attr); //队列的类型\n\tdispatch_queue_t queue = dispatch_queue_create(\"re.yuxiang\",  DISPATCH_QUEUE_CONCURRENT); //  创建并发队列\n\t​```\nGCD默认已经提供了全局的并发队列,供整个应用使用, 可以无需受用创建\n使用`dispatch_get_global_queue`函数获得全局的并发队列\n\t​```\n\tdispatch_queue_t dispatch_get_global_queue(\n\tdispatch_queue_priority_t priority, //队列的优先级\n\tlong flags); //此参数暂时无用 用0即可\n\tdispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); //获得全局并发队列\n\t​```\n\n* 全局并发队列的优先级\n ```\n #define DISPATCH_QUEUE_PRIORITY_HIGH 2     // 高\n #define DISPATCH_QUEUE_PRIORITY_DEFAULT 0  //默认(中)\n #define DISPATCH_QUEUE_PRIORITY_LOW (-2)   // 低\n #define DISPATCH_QUEUE_PRIORITY_BACKGROUND INT16_MIN // 后台\n ```\n\n2、串行列队\n　　让任务一个接着一个执行(一个任务执行完毕后,在执行下一个任务)\n　　GCD中获得串行有2种途径\n\t\t使用`dispatch_queue_creat`函数创建串行队列\n\n    dispatch_queue_creat queue = dispatch_queue_creat(\"yuxiang.ren\", NULL); // 队列类型传递NULL或者DISPATCH_QUEUE_SERIAL \n\n3、主队列(跟主线程相关联的队列)\n　　主队列是GCD自带的一种特殊的串行队列\n　　放在主队列中的任务, 都会返回主线程中执行\n　　使用`dispatch_get_main_queue()`获得主队列\n  > `dispatch_queue_t queue = dispatch_get_main_queue();`\n\n## 四、NSOperation\n 1. 相关概念\n    NSOperation是对**GCD的包装**\n    两个核心概念[**队列**+**操作**]\n 2. 基本使用\n   `NSOperation`本身是抽象类,只能只有他的子类\n    \t三个子类分别是:`NSBlockOperation`,`NSInvocationOperation`,以及自定义继承自`NSOperation`的类\n    `NSOperation`和`NSOperationQueue`结合使用实现多线程开发\n 3. `NSoperationQueue`\n* `NSOperation`中的两种队列  \n  + 主队列: 通过mainQueue获得,凡是放到主队列中的人物都将在主线程中完成\n  + 非主队列: 直接[alloc init]出来的队列, 非主队列同时具备了并发和串行的功能, 通过设置最大并发数属性来控制任务是并发执行还是串行执行\n\n## 五、GCD和NSOperation的对比\n1. **GCD**和**NSOperation**的区别\n* `GCD`是**纯C语言的API**，而`操作队列`则是**OC对象**\n* 在GCD中,任务用快(`block`)来表示, 而块是轻量级的数据结构;相反操作队列中的[操作]`NSOperation`则是个更加重量级的OC对象\n* 具体该使用`GCD`还是使用`NSOperation`需要看具体情况\n2. `NSOperation`和`NSoperationQueue`相对`GCD`的好处\n* `NSOperationQueue`可以方便的调用`cancel`方法来取消某个操作, 而**GCD**中的任务是无法取消的\n* `NSOperation`可以方便的制定操作间的依赖关系\n* `NSOperation`可以通**KVO**提供对`NSOperation`对象的精细控制(比如监听当前的操作是否取消)\n* `NSOperation`可以方便的制定操作的优先级,操作优先级表示此操作与队列中其他操作间的优先关系\n* 通过自定义`NSOperation`的子类可以实现操作重用\n\n## 六、单例\n1. 基本概念\n* 单利模式\n   在程序运行过程中,一个类只有一个实例\n* 使用场合\n   在整个应用程序中,功效一份资源(这份资源只需要创建初始化一次)\n2. ARC实现单利\n  * 在类的内部提供一个`static`修饰的全局变量\n  * 提供一个类方法, 方便外接访问\n  * 重写`+allocWithZone`方法,保证永远只为单例对象分配一次内存空间\n  * 严谨写法, 重写`-CopyWithZone`方法和`-MutableCopyWithZone`方法\n\n\n\n\n\n\n​\t\n\n","source":"_posts/多线程.md","raw":"\ntitle: 多线程\ndate: 2016-03-18\ncategories: iOS\ntags: Objective-C\n\n---\n```\n异步函数+主队列    不会开线程,串行执行\n异步函数+并发队列  开多条线程,并发执行\n异步函数+串行队列  开一条线程,串行执行\n同步函数+并发队列  不会开线程,串行执行\n同步函数+串行执行  不会开线程,串行执行\n```\n\n<!-- more -->\n## 一、容易混淆的俗语\n　　有四个术语比较容易混淆：`同步`、`异步`、`并发`、`串行`.\n1. 同步和异步主要影响有:能不能开启新线程\n* 同步: 只能在当前线程中执行任务, 不具备开启新线程的能力\n* 异步: 可以在新的线程中执行任务, 具备开启新线程的能力\n2. 并发金和串行的只要影响: 任务的执行方式\n* 并发: 允许多个任务并发(同事执行)\n* 串行: 一个任务执行完毕后,在执行下一个任务\n\n## 二、执行任务\n 1、GCD中有2个用来执行任务的常用函数\n \t　用同步的方式执行任务\n 　\t`dispatch_sync(dispatch_queue_t queue, dispatch_block_t block);`\n\t\t　• queue  队列  \n\t\t　• block  任务\n\t　用异步的方式执行任务\n\t　`dispatch_async(dispatch_queue_t queue, dispatch_block_t block);`\n 2、GCD中还有个用来执行任务的函数：\n 　　`dispatch_barrier_async(dispatch_queue_t queue, dispatch_block_t block);`\n 　　在前面的任务执行结束后它才执行，而且它后面的任务执行完成后才会执行\n\t**注意**：这个`queue`不能是全局的并发列队\n\n## 三、列队的类型\n 1、并发列队\n\t　　可以让并发任务并发(同时)执行(自动开启多个线程同时执行任务)\n\t　　并发功能只有在异步(`dispatch_async`) 函数下才有效\n\t使用 `dispatch_queue_create` 函数创建队列\n\t​```\n\tdispatch_queue_t \n\tdispatch_queue_create(const char *label, //队列名称\n\tdispatch_queue_attr_t attr); //队列的类型\n\tdispatch_queue_t queue = dispatch_queue_create(\"re.yuxiang\",  DISPATCH_QUEUE_CONCURRENT); //  创建并发队列\n\t​```\nGCD默认已经提供了全局的并发队列,供整个应用使用, 可以无需受用创建\n使用`dispatch_get_global_queue`函数获得全局的并发队列\n\t​```\n\tdispatch_queue_t dispatch_get_global_queue(\n\tdispatch_queue_priority_t priority, //队列的优先级\n\tlong flags); //此参数暂时无用 用0即可\n\tdispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); //获得全局并发队列\n\t​```\n\n* 全局并发队列的优先级\n ```\n #define DISPATCH_QUEUE_PRIORITY_HIGH 2     // 高\n #define DISPATCH_QUEUE_PRIORITY_DEFAULT 0  //默认(中)\n #define DISPATCH_QUEUE_PRIORITY_LOW (-2)   // 低\n #define DISPATCH_QUEUE_PRIORITY_BACKGROUND INT16_MIN // 后台\n ```\n\n2、串行列队\n　　让任务一个接着一个执行(一个任务执行完毕后,在执行下一个任务)\n　　GCD中获得串行有2种途径\n\t\t使用`dispatch_queue_creat`函数创建串行队列\n\n    dispatch_queue_creat queue = dispatch_queue_creat(\"yuxiang.ren\", NULL); // 队列类型传递NULL或者DISPATCH_QUEUE_SERIAL \n\n3、主队列(跟主线程相关联的队列)\n　　主队列是GCD自带的一种特殊的串行队列\n　　放在主队列中的任务, 都会返回主线程中执行\n　　使用`dispatch_get_main_queue()`获得主队列\n  > `dispatch_queue_t queue = dispatch_get_main_queue();`\n\n## 四、NSOperation\n 1. 相关概念\n    NSOperation是对**GCD的包装**\n    两个核心概念[**队列**+**操作**]\n 2. 基本使用\n   `NSOperation`本身是抽象类,只能只有他的子类\n    \t三个子类分别是:`NSBlockOperation`,`NSInvocationOperation`,以及自定义继承自`NSOperation`的类\n    `NSOperation`和`NSOperationQueue`结合使用实现多线程开发\n 3. `NSoperationQueue`\n* `NSOperation`中的两种队列  \n  + 主队列: 通过mainQueue获得,凡是放到主队列中的人物都将在主线程中完成\n  + 非主队列: 直接[alloc init]出来的队列, 非主队列同时具备了并发和串行的功能, 通过设置最大并发数属性来控制任务是并发执行还是串行执行\n\n## 五、GCD和NSOperation的对比\n1. **GCD**和**NSOperation**的区别\n* `GCD`是**纯C语言的API**，而`操作队列`则是**OC对象**\n* 在GCD中,任务用快(`block`)来表示, 而块是轻量级的数据结构;相反操作队列中的[操作]`NSOperation`则是个更加重量级的OC对象\n* 具体该使用`GCD`还是使用`NSOperation`需要看具体情况\n2. `NSOperation`和`NSoperationQueue`相对`GCD`的好处\n* `NSOperationQueue`可以方便的调用`cancel`方法来取消某个操作, 而**GCD**中的任务是无法取消的\n* `NSOperation`可以方便的制定操作间的依赖关系\n* `NSOperation`可以通**KVO**提供对`NSOperation`对象的精细控制(比如监听当前的操作是否取消)\n* `NSOperation`可以方便的制定操作的优先级,操作优先级表示此操作与队列中其他操作间的优先关系\n* 通过自定义`NSOperation`的子类可以实现操作重用\n\n## 六、单例\n1. 基本概念\n* 单利模式\n   在程序运行过程中,一个类只有一个实例\n* 使用场合\n   在整个应用程序中,功效一份资源(这份资源只需要创建初始化一次)\n2. ARC实现单利\n  * 在类的内部提供一个`static`修饰的全局变量\n  * 提供一个类方法, 方便外接访问\n  * 重写`+allocWithZone`方法,保证永远只为单例对象分配一次内存空间\n  * 严谨写法, 重写`-CopyWithZone`方法和`-MutableCopyWithZone`方法\n\n\n\n\n\n\n​\t\n\n","slug":"多线程","published":1,"updated":"2017-04-28T08:34:03.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6686xn7002pxe9zr8jyppx5","content":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">异步函数+主队列    不会开线程,串行执行</div><div class=\"line\">异步函数+并发队列  开多条线程,并发执行</div><div class=\"line\">异步函数+串行队列  开一条线程,串行执行</div><div class=\"line\">同步函数+并发队列  不会开线程,串行执行</div><div class=\"line\">同步函数+串行执行  不会开线程,串行执行</div></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<h2 id=\"一、容易混淆的俗语\"><a href=\"#一、容易混淆的俗语\" class=\"headerlink\" title=\"一、容易混淆的俗语\"></a>一、容易混淆的俗语</h2><p>　　有四个术语比较容易混淆：<code>同步</code>、<code>异步</code>、<code>并发</code>、<code>串行</code>.</p>\n<ol>\n<li>同步和异步主要影响有:能不能开启新线程</li>\n</ol>\n<ul>\n<li>同步: 只能在当前线程中执行任务, 不具备开启新线程的能力</li>\n<li>异步: 可以在新的线程中执行任务, 具备开启新线程的能力</li>\n</ul>\n<ol>\n<li>并发金和串行的只要影响: 任务的执行方式</li>\n</ol>\n<ul>\n<li>并发: 允许多个任务并发(同事执行)</li>\n<li>串行: 一个任务执行完毕后,在执行下一个任务</li>\n</ul>\n<h2 id=\"二、执行任务\"><a href=\"#二、执行任务\" class=\"headerlink\" title=\"二、执行任务\"></a>二、执行任务</h2><p> 1、GCD中有2个用来执行任务的常用函数<br>     　用同步的方式执行任务<br> 　    <code>dispatch_sync(dispatch_queue_t queue, dispatch_block_t block);</code><br>        　• queue  队列<br>        　• block  任务<br>    　用异步的方式执行任务<br>    　<code>dispatch_async(dispatch_queue_t queue, dispatch_block_t block);</code><br> 2、GCD中还有个用来执行任务的函数：<br> 　　<code>dispatch_barrier_async(dispatch_queue_t queue, dispatch_block_t block);</code><br> 　　在前面的任务执行结束后它才执行，而且它后面的任务执行完成后才会执行<br>    <strong>注意</strong>：这个<code>queue</code>不能是全局的并发列队</p>\n<h2 id=\"三、列队的类型\"><a href=\"#三、列队的类型\" class=\"headerlink\" title=\"三、列队的类型\"></a>三、列队的类型</h2><p> 1、并发列队<br>    　　可以让并发任务并发(同时)执行(自动开启多个线程同时执行任务)<br>    　　并发功能只有在异步(<code>dispatch_async</code>) 函数下才有效<br>    使用 <code>dispatch_queue_create</code> 函数创建队列<br>    ​<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">dispatch_queue_t </div><div class=\"line\">dispatch_queue_create(const char *label, //队列名称</div><div class=\"line\">dispatch_queue_attr_t attr); //队列的类型</div><div class=\"line\">dispatch_queue_t queue = dispatch_queue_create(&quot;re.yuxiang&quot;,  DISPATCH_QUEUE_CONCURRENT); //  创建并发队列</div><div class=\"line\">​</div></pre></td></tr></table></figure></p>\n<p>GCD默认已经提供了全局的并发队列,供整个应用使用, 可以无需受用创建<br>使用<code>dispatch_get_global_queue</code>函数获得全局的并发队列<br>    ​<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">dispatch_queue_t dispatch_get_global_queue(</div><div class=\"line\">dispatch_queue_priority_t priority, //队列的优先级</div><div class=\"line\">long flags); //此参数暂时无用 用0即可</div><div class=\"line\">dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); //获得全局并发队列</div><div class=\"line\">​</div></pre></td></tr></table></figure></p>\n<ul>\n<li>全局并发队列的优先级<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">#define DISPATCH_QUEUE_PRIORITY_HIGH 2     // 高</div><div class=\"line\">#define DISPATCH_QUEUE_PRIORITY_DEFAULT 0  //默认(中)</div><div class=\"line\">#define DISPATCH_QUEUE_PRIORITY_LOW (-2)   // 低</div><div class=\"line\">#define DISPATCH_QUEUE_PRIORITY_BACKGROUND INT16_MIN // 后台</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>2、串行列队<br>　　让任务一个接着一个执行(一个任务执行完毕后,在执行下一个任务)<br>　　GCD中获得串行有2种途径<br>        使用<code>dispatch_queue_creat</code>函数创建串行队列</p>\n<pre><code>dispatch_queue_creat queue = dispatch_queue_creat(&quot;yuxiang.ren&quot;, NULL); // 队列类型传递NULL或者DISPATCH_QUEUE_SERIAL \n</code></pre><p>3、主队列(跟主线程相关联的队列)<br>　　主队列是GCD自带的一种特殊的串行队列<br>　　放在主队列中的任务, 都会返回主线程中执行<br>　　使用<code>dispatch_get_main_queue()</code>获得主队列</p>\n<blockquote>\n<p><code>dispatch_queue_t queue = dispatch_get_main_queue();</code></p>\n</blockquote>\n<h2 id=\"四、NSOperation\"><a href=\"#四、NSOperation\" class=\"headerlink\" title=\"四、NSOperation\"></a>四、NSOperation</h2><ol>\n<li>相关概念<br>NSOperation是对<strong>GCD的包装</strong><br>两个核心概念[<strong>队列</strong>+<strong>操作</strong>]</li>\n<li>基本使用<br><code>NSOperation</code>本身是抽象类,只能只有他的子类<pre><code>三个子类分别是:`NSBlockOperation`,`NSInvocationOperation`,以及自定义继承自`NSOperation`的类\n</code></pre><code>NSOperation</code>和<code>NSOperationQueue</code>结合使用实现多线程开发</li>\n<li><code>NSoperationQueue</code><ul>\n<li><code>NSOperation</code>中的两种队列  </li>\n</ul>\n<ul>\n<li>主队列: 通过mainQueue获得,凡是放到主队列中的人物都将在主线程中完成</li>\n<li>非主队列: 直接[alloc init]出来的队列, 非主队列同时具备了并发和串行的功能, 通过设置最大并发数属性来控制任务是并发执行还是串行执行</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"五、GCD和NSOperation的对比\"><a href=\"#五、GCD和NSOperation的对比\" class=\"headerlink\" title=\"五、GCD和NSOperation的对比\"></a>五、GCD和NSOperation的对比</h2><ol>\n<li><strong>GCD</strong>和<strong>NSOperation</strong>的区别</li>\n</ol>\n<ul>\n<li><code>GCD</code>是<strong>纯C语言的API</strong>，而<code>操作队列</code>则是<strong>OC对象</strong></li>\n<li>在GCD中,任务用快(<code>block</code>)来表示, 而块是轻量级的数据结构;相反操作队列中的[操作]<code>NSOperation</code>则是个更加重量级的OC对象</li>\n<li>具体该使用<code>GCD</code>还是使用<code>NSOperation</code>需要看具体情况</li>\n</ul>\n<ol>\n<li><code>NSOperation</code>和<code>NSoperationQueue</code>相对<code>GCD</code>的好处</li>\n</ol>\n<ul>\n<li><code>NSOperationQueue</code>可以方便的调用<code>cancel</code>方法来取消某个操作, 而<strong>GCD</strong>中的任务是无法取消的</li>\n<li><code>NSOperation</code>可以方便的制定操作间的依赖关系</li>\n<li><code>NSOperation</code>可以通<strong>KVO</strong>提供对<code>NSOperation</code>对象的精细控制(比如监听当前的操作是否取消)</li>\n<li><code>NSOperation</code>可以方便的制定操作的优先级,操作优先级表示此操作与队列中其他操作间的优先关系</li>\n<li>通过自定义<code>NSOperation</code>的子类可以实现操作重用</li>\n</ul>\n<h2 id=\"六、单例\"><a href=\"#六、单例\" class=\"headerlink\" title=\"六、单例\"></a>六、单例</h2><ol>\n<li>基本概念</li>\n</ol>\n<ul>\n<li>单利模式<br> 在程序运行过程中,一个类只有一个实例</li>\n<li>使用场合<br> 在整个应用程序中,功效一份资源(这份资源只需要创建初始化一次)</li>\n</ul>\n<ol>\n<li>ARC实现单利<ul>\n<li>在类的内部提供一个<code>static</code>修饰的全局变量</li>\n<li>提供一个类方法, 方便外接访问</li>\n<li>重写<code>+allocWithZone</code>方法,保证永远只为单例对象分配一次内存空间</li>\n<li>严谨写法, 重写<code>-CopyWithZone</code>方法和<code>-MutableCopyWithZone</code>方法</li>\n</ul>\n</li>\n</ol>\n<p>​    </p>\n","site":{"data":{}},"excerpt":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">异步函数+主队列    不会开线程,串行执行</div><div class=\"line\">异步函数+并发队列  开多条线程,并发执行</div><div class=\"line\">异步函数+串行队列  开一条线程,串行执行</div><div class=\"line\">同步函数+并发队列  不会开线程,串行执行</div><div class=\"line\">同步函数+串行执行  不会开线程,串行执行</div></pre></td></tr></table></figure>","more":"<h2 id=\"一、容易混淆的俗语\"><a href=\"#一、容易混淆的俗语\" class=\"headerlink\" title=\"一、容易混淆的俗语\"></a>一、容易混淆的俗语</h2><p>　　有四个术语比较容易混淆：<code>同步</code>、<code>异步</code>、<code>并发</code>、<code>串行</code>.</p>\n<ol>\n<li>同步和异步主要影响有:能不能开启新线程</li>\n</ol>\n<ul>\n<li>同步: 只能在当前线程中执行任务, 不具备开启新线程的能力</li>\n<li>异步: 可以在新的线程中执行任务, 具备开启新线程的能力</li>\n</ul>\n<ol>\n<li>并发金和串行的只要影响: 任务的执行方式</li>\n</ol>\n<ul>\n<li>并发: 允许多个任务并发(同事执行)</li>\n<li>串行: 一个任务执行完毕后,在执行下一个任务</li>\n</ul>\n<h2 id=\"二、执行任务\"><a href=\"#二、执行任务\" class=\"headerlink\" title=\"二、执行任务\"></a>二、执行任务</h2><p> 1、GCD中有2个用来执行任务的常用函数<br>     　用同步的方式执行任务<br> 　    <code>dispatch_sync(dispatch_queue_t queue, dispatch_block_t block);</code><br>        　• queue  队列<br>        　• block  任务<br>    　用异步的方式执行任务<br>    　<code>dispatch_async(dispatch_queue_t queue, dispatch_block_t block);</code><br> 2、GCD中还有个用来执行任务的函数：<br> 　　<code>dispatch_barrier_async(dispatch_queue_t queue, dispatch_block_t block);</code><br> 　　在前面的任务执行结束后它才执行，而且它后面的任务执行完成后才会执行<br>    <strong>注意</strong>：这个<code>queue</code>不能是全局的并发列队</p>\n<h2 id=\"三、列队的类型\"><a href=\"#三、列队的类型\" class=\"headerlink\" title=\"三、列队的类型\"></a>三、列队的类型</h2><p> 1、并发列队<br>    　　可以让并发任务并发(同时)执行(自动开启多个线程同时执行任务)<br>    　　并发功能只有在异步(<code>dispatch_async</code>) 函数下才有效<br>    使用 <code>dispatch_queue_create</code> 函数创建队列<br>    ​<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">dispatch_queue_t </div><div class=\"line\">dispatch_queue_create(const char *label, //队列名称</div><div class=\"line\">dispatch_queue_attr_t attr); //队列的类型</div><div class=\"line\">dispatch_queue_t queue = dispatch_queue_create(&quot;re.yuxiang&quot;,  DISPATCH_QUEUE_CONCURRENT); //  创建并发队列</div><div class=\"line\">​</div></pre></td></tr></table></figure></p>\n<p>GCD默认已经提供了全局的并发队列,供整个应用使用, 可以无需受用创建<br>使用<code>dispatch_get_global_queue</code>函数获得全局的并发队列<br>    ​<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">dispatch_queue_t dispatch_get_global_queue(</div><div class=\"line\">dispatch_queue_priority_t priority, //队列的优先级</div><div class=\"line\">long flags); //此参数暂时无用 用0即可</div><div class=\"line\">dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); //获得全局并发队列</div><div class=\"line\">​</div></pre></td></tr></table></figure></p>\n<ul>\n<li>全局并发队列的优先级<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">#define DISPATCH_QUEUE_PRIORITY_HIGH 2     // 高</div><div class=\"line\">#define DISPATCH_QUEUE_PRIORITY_DEFAULT 0  //默认(中)</div><div class=\"line\">#define DISPATCH_QUEUE_PRIORITY_LOW (-2)   // 低</div><div class=\"line\">#define DISPATCH_QUEUE_PRIORITY_BACKGROUND INT16_MIN // 后台</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>2、串行列队<br>　　让任务一个接着一个执行(一个任务执行完毕后,在执行下一个任务)<br>　　GCD中获得串行有2种途径<br>        使用<code>dispatch_queue_creat</code>函数创建串行队列</p>\n<pre><code>dispatch_queue_creat queue = dispatch_queue_creat(&quot;yuxiang.ren&quot;, NULL); // 队列类型传递NULL或者DISPATCH_QUEUE_SERIAL \n</code></pre><p>3、主队列(跟主线程相关联的队列)<br>　　主队列是GCD自带的一种特殊的串行队列<br>　　放在主队列中的任务, 都会返回主线程中执行<br>　　使用<code>dispatch_get_main_queue()</code>获得主队列</p>\n<blockquote>\n<p><code>dispatch_queue_t queue = dispatch_get_main_queue();</code></p>\n</blockquote>\n<h2 id=\"四、NSOperation\"><a href=\"#四、NSOperation\" class=\"headerlink\" title=\"四、NSOperation\"></a>四、NSOperation</h2><ol>\n<li>相关概念<br>NSOperation是对<strong>GCD的包装</strong><br>两个核心概念[<strong>队列</strong>+<strong>操作</strong>]</li>\n<li>基本使用<br><code>NSOperation</code>本身是抽象类,只能只有他的子类<pre><code>三个子类分别是:`NSBlockOperation`,`NSInvocationOperation`,以及自定义继承自`NSOperation`的类\n</code></pre><code>NSOperation</code>和<code>NSOperationQueue</code>结合使用实现多线程开发</li>\n<li><code>NSoperationQueue</code><ul>\n<li><code>NSOperation</code>中的两种队列  </li>\n</ul>\n<ul>\n<li>主队列: 通过mainQueue获得,凡是放到主队列中的人物都将在主线程中完成</li>\n<li>非主队列: 直接[alloc init]出来的队列, 非主队列同时具备了并发和串行的功能, 通过设置最大并发数属性来控制任务是并发执行还是串行执行</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"五、GCD和NSOperation的对比\"><a href=\"#五、GCD和NSOperation的对比\" class=\"headerlink\" title=\"五、GCD和NSOperation的对比\"></a>五、GCD和NSOperation的对比</h2><ol>\n<li><strong>GCD</strong>和<strong>NSOperation</strong>的区别</li>\n</ol>\n<ul>\n<li><code>GCD</code>是<strong>纯C语言的API</strong>，而<code>操作队列</code>则是<strong>OC对象</strong></li>\n<li>在GCD中,任务用快(<code>block</code>)来表示, 而块是轻量级的数据结构;相反操作队列中的[操作]<code>NSOperation</code>则是个更加重量级的OC对象</li>\n<li>具体该使用<code>GCD</code>还是使用<code>NSOperation</code>需要看具体情况</li>\n</ul>\n<ol>\n<li><code>NSOperation</code>和<code>NSoperationQueue</code>相对<code>GCD</code>的好处</li>\n</ol>\n<ul>\n<li><code>NSOperationQueue</code>可以方便的调用<code>cancel</code>方法来取消某个操作, 而<strong>GCD</strong>中的任务是无法取消的</li>\n<li><code>NSOperation</code>可以方便的制定操作间的依赖关系</li>\n<li><code>NSOperation</code>可以通<strong>KVO</strong>提供对<code>NSOperation</code>对象的精细控制(比如监听当前的操作是否取消)</li>\n<li><code>NSOperation</code>可以方便的制定操作的优先级,操作优先级表示此操作与队列中其他操作间的优先关系</li>\n<li>通过自定义<code>NSOperation</code>的子类可以实现操作重用</li>\n</ul>\n<h2 id=\"六、单例\"><a href=\"#六、单例\" class=\"headerlink\" title=\"六、单例\"></a>六、单例</h2><ol>\n<li>基本概念</li>\n</ol>\n<ul>\n<li>单利模式<br> 在程序运行过程中,一个类只有一个实例</li>\n<li>使用场合<br> 在整个应用程序中,功效一份资源(这份资源只需要创建初始化一次)</li>\n</ul>\n<ol>\n<li>ARC实现单利<ul>\n<li>在类的内部提供一个<code>static</code>修饰的全局变量</li>\n<li>提供一个类方法, 方便外接访问</li>\n<li>重写<code>+allocWithZone</code>方法,保证永远只为单例对象分配一次内存空间</li>\n<li>严谨写法, 重写<code>-CopyWithZone</code>方法和<code>-MutableCopyWithZone</code>方法</li>\n</ul>\n</li>\n</ol>\n<p>​    </p>"},{"title":"很久以前","date":"2016-06-05T08:31:47.000Z","_content":"\n<p>很久很久以前，我想过很多次以后的情景，我想过有一天我终于放弃你时候的样子。</p>\n<p>我以为我会在某个晴朗的早晨,兴国来的霎那间发现我不在喜欢你了,然后开始我的新生活。</p>\n<p>然而我发现我错了。<br>\n<!-- more -->\n<p></p>\n\n<p>其实是我开始了新生活之后，在潜移默化里，会在某一个品番的时刻里，我乍然发现，我竟然已经忘记你很久了。</p>\n<p>这种乍然是哼悲哀的。</p>\n<p>我总以为我依你的感情是伟大的，那它的小事也该是意见轰动的事情。</p>\n<p>然而事实上它的小事是悄然无息的。</p>\n<p></p>\n\n<p>现在的某天里，我跟古又说，我好像喜欢上了一个人。</p>\n<p>固有也不会提起你的名字，二十安静的听我的新恋。</p>\n<p>偶尔会有人问起你——那xxx呢？还有联系么？</p>\n<p>然后我才会想起你，一时间会不知道该说什么好了。</p>\n<p></p>\n\n<p>我曾经，是真的那样真实地喜欢过你。这种喜欢我想我此生大概都不会有第二次了。</p>\n<p>你何止是我的上帝，你简直是我的全部。</p>\n<p>我依然清晰地记得跟你说过的话，跟你聊过的事，我还记得你对我的评价，记得你说的玩笑或者是真话。</p>\n<p>我记得你跟我说的第一句话，也记得你说最近跟我说的最后一句话。</p>\n<p>我记得你跟我说过的好听的话。</p>\n<p>也记得你对我说过的残忍的话。</p>\n<p>这么多的话我不知道我还会记得多久，我知道我回忆这些的时候还会有一点开心或者难过。</p>\n<p>但是我想我再也不会那样入戏了。</p>\n<p>我已经不了解你的最近的生活了。</p>\n<p></p>\n\n<p>我也不再那样感兴趣。</p>\n<p>我也不再期望自己会在你心里留下怎么样的印象，不会想象在你心里占着怎样的一个地位。</p>\n<p>你或者跟我说话或者不跟我说话。</p>\n<p>你或者出现在我的生活或者消失。</p>\n<p>我已经不再那样介意了。</p>\n<p>我已经不会再向别人宣布我对你的放弃了。</p>\n<p>因为真正的放弃永远是悄无声息的。</p>\n<p></p>\n\n<p>某年某月某一天某一个时刻。</p>\n<p>我模糊而清晰地发觉，我不喜欢你了。</p>\n<p>而很久很久以前，我以为这样的发觉会让我欣喜。</p>\n<p>然而事实是此时此刻我打下这段文字，我的内心是悲凉的。</p>\n<p>我最害怕的事情，原来不是我无法放弃你。</p>\n<p>而是有那样一天，我突然不喜欢你了。</p>\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"https://music.163.com/outchain/player?type=2&id=65528&auto=1&height=66\"></iframe>\n","source":"_posts/很久以前.md","raw":"---\ntitle: 很久以前\ndate: 2016-06-05 16:31:47\ncategories: 杂碎\ntags:\n---\n\n<p>很久很久以前，我想过很多次以后的情景，我想过有一天我终于放弃你时候的样子。</p>\n<p>我以为我会在某个晴朗的早晨,兴国来的霎那间发现我不在喜欢你了,然后开始我的新生活。</p>\n<p>然而我发现我错了。<br>\n<!-- more -->\n<p></p>\n\n<p>其实是我开始了新生活之后，在潜移默化里，会在某一个品番的时刻里，我乍然发现，我竟然已经忘记你很久了。</p>\n<p>这种乍然是哼悲哀的。</p>\n<p>我总以为我依你的感情是伟大的，那它的小事也该是意见轰动的事情。</p>\n<p>然而事实上它的小事是悄然无息的。</p>\n<p></p>\n\n<p>现在的某天里，我跟古又说，我好像喜欢上了一个人。</p>\n<p>固有也不会提起你的名字，二十安静的听我的新恋。</p>\n<p>偶尔会有人问起你——那xxx呢？还有联系么？</p>\n<p>然后我才会想起你，一时间会不知道该说什么好了。</p>\n<p></p>\n\n<p>我曾经，是真的那样真实地喜欢过你。这种喜欢我想我此生大概都不会有第二次了。</p>\n<p>你何止是我的上帝，你简直是我的全部。</p>\n<p>我依然清晰地记得跟你说过的话，跟你聊过的事，我还记得你对我的评价，记得你说的玩笑或者是真话。</p>\n<p>我记得你跟我说的第一句话，也记得你说最近跟我说的最后一句话。</p>\n<p>我记得你跟我说过的好听的话。</p>\n<p>也记得你对我说过的残忍的话。</p>\n<p>这么多的话我不知道我还会记得多久，我知道我回忆这些的时候还会有一点开心或者难过。</p>\n<p>但是我想我再也不会那样入戏了。</p>\n<p>我已经不了解你的最近的生活了。</p>\n<p></p>\n\n<p>我也不再那样感兴趣。</p>\n<p>我也不再期望自己会在你心里留下怎么样的印象，不会想象在你心里占着怎样的一个地位。</p>\n<p>你或者跟我说话或者不跟我说话。</p>\n<p>你或者出现在我的生活或者消失。</p>\n<p>我已经不再那样介意了。</p>\n<p>我已经不会再向别人宣布我对你的放弃了。</p>\n<p>因为真正的放弃永远是悄无声息的。</p>\n<p></p>\n\n<p>某年某月某一天某一个时刻。</p>\n<p>我模糊而清晰地发觉，我不喜欢你了。</p>\n<p>而很久很久以前，我以为这样的发觉会让我欣喜。</p>\n<p>然而事实是此时此刻我打下这段文字，我的内心是悲凉的。</p>\n<p>我最害怕的事情，原来不是我无法放弃你。</p>\n<p>而是有那样一天，我突然不喜欢你了。</p>\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"https://music.163.com/outchain/player?type=2&id=65528&auto=1&height=66\"></iframe>\n","slug":"很久以前","published":1,"updated":"2017-05-03T02:28:38.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6686xn8002txe9ztb5ts1g4","content":"<p>很久很久以前，我想过很多次以后的情景，我想过有一天我终于放弃你时候的样子。</p><br><p>我以为我会在某个晴朗的早晨,兴国来的霎那间发现我不在喜欢你了,然后开始我的新生活。</p><br><p>然而我发现我错了。<br><br><a id=\"more\"></a><br></p><p></p>\n\n<p>其实是我开始了新生活之后，在潜移默化里，会在某一个品番的时刻里，我乍然发现，我竟然已经忘记你很久了。</p><br><p>这种乍然是哼悲哀的。</p><br><p>我总以为我依你的感情是伟大的，那它的小事也该是意见轰动的事情。</p><br><p>然而事实上它的小事是悄然无息的。</p><br><p></p>\n\n<p>现在的某天里，我跟古又说，我好像喜欢上了一个人。</p><br><p>固有也不会提起你的名字，二十安静的听我的新恋。</p><br><p>偶尔会有人问起你——那xxx呢？还有联系么？</p><br><p>然后我才会想起你，一时间会不知道该说什么好了。</p><br><p></p>\n\n<p>我曾经，是真的那样真实地喜欢过你。这种喜欢我想我此生大概都不会有第二次了。</p><br><p>你何止是我的上帝，你简直是我的全部。</p><br><p>我依然清晰地记得跟你说过的话，跟你聊过的事，我还记得你对我的评价，记得你说的玩笑或者是真话。</p><br><p>我记得你跟我说的第一句话，也记得你说最近跟我说的最后一句话。</p><br><p>我记得你跟我说过的好听的话。</p><br><p>也记得你对我说过的残忍的话。</p><br><p>这么多的话我不知道我还会记得多久，我知道我回忆这些的时候还会有一点开心或者难过。</p><br><p>但是我想我再也不会那样入戏了。</p><br><p>我已经不了解你的最近的生活了。</p><br><p></p>\n\n<p>我也不再那样感兴趣。</p><br><p>我也不再期望自己会在你心里留下怎么样的印象，不会想象在你心里占着怎样的一个地位。</p><br><p>你或者跟我说话或者不跟我说话。</p><br><p>你或者出现在我的生活或者消失。</p><br><p>我已经不再那样介意了。</p><br><p>我已经不会再向别人宣布我对你的放弃了。</p><br><p>因为真正的放弃永远是悄无声息的。</p><br><p></p>\n\n<p>某年某月某一天某一个时刻。</p><br><p>我模糊而清晰地发觉，我不喜欢你了。</p><br><p>而很久很久以前，我以为这样的发觉会让我欣喜。</p><br><p>然而事实是此时此刻我打下这段文字，我的内心是悲凉的。</p><br><p>我最害怕的事情，原来不是我无法放弃你。</p><br><p>而是有那样一天，我突然不喜欢你了。</p>\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=\"330\" height=\"86\" src=\"https://music.163.com/outchain/player?type=2&id=65528&auto=1&height=66\"></iframe>\n","site":{"data":{}},"excerpt":"<p>很久很久以前，我想过很多次以后的情景，我想过有一天我终于放弃你时候的样子。</p><br><p>我以为我会在某个晴朗的早晨,兴国来的霎那间发现我不在喜欢你了,然后开始我的新生活。</p><br><p>然而我发现我错了。<br><br>","more":"<br></p><p></p>\n\n<p>其实是我开始了新生活之后，在潜移默化里，会在某一个品番的时刻里，我乍然发现，我竟然已经忘记你很久了。</p><br><p>这种乍然是哼悲哀的。</p><br><p>我总以为我依你的感情是伟大的，那它的小事也该是意见轰动的事情。</p><br><p>然而事实上它的小事是悄然无息的。</p><br><p></p>\n\n<p>现在的某天里，我跟古又说，我好像喜欢上了一个人。</p><br><p>固有也不会提起你的名字，二十安静的听我的新恋。</p><br><p>偶尔会有人问起你——那xxx呢？还有联系么？</p><br><p>然后我才会想起你，一时间会不知道该说什么好了。</p><br><p></p>\n\n<p>我曾经，是真的那样真实地喜欢过你。这种喜欢我想我此生大概都不会有第二次了。</p><br><p>你何止是我的上帝，你简直是我的全部。</p><br><p>我依然清晰地记得跟你说过的话，跟你聊过的事，我还记得你对我的评价，记得你说的玩笑或者是真话。</p><br><p>我记得你跟我说的第一句话，也记得你说最近跟我说的最后一句话。</p><br><p>我记得你跟我说过的好听的话。</p><br><p>也记得你对我说过的残忍的话。</p><br><p>这么多的话我不知道我还会记得多久，我知道我回忆这些的时候还会有一点开心或者难过。</p><br><p>但是我想我再也不会那样入戏了。</p><br><p>我已经不了解你的最近的生活了。</p><br><p></p>\n\n<p>我也不再那样感兴趣。</p><br><p>我也不再期望自己会在你心里留下怎么样的印象，不会想象在你心里占着怎样的一个地位。</p><br><p>你或者跟我说话或者不跟我说话。</p><br><p>你或者出现在我的生活或者消失。</p><br><p>我已经不再那样介意了。</p><br><p>我已经不会再向别人宣布我对你的放弃了。</p><br><p>因为真正的放弃永远是悄无声息的。</p><br><p></p>\n\n<p>某年某月某一天某一个时刻。</p><br><p>我模糊而清晰地发觉，我不喜欢你了。</p><br><p>而很久很久以前，我以为这样的发觉会让我欣喜。</p><br><p>然而事实是此时此刻我打下这段文字，我的内心是悲凉的。</p><br><p>我最害怕的事情，原来不是我无法放弃你。</p><br><p>而是有那样一天，我突然不喜欢你了。</p>\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=\"330\" height=\"86\" src=\"https://music.163.com/outchain/player?type=2&id=65528&auto=1&height=66\"></iframe>"},{"title":"撩妹招数","date":"2016-06-05T11:26:22.000Z","_content":"\n1. 江山如此多娇,而我...只为你折腰\n2. 比起欧洲大陆,我更想征服的是你的心\n3. 给我一个支点,让我撬动你的心\n4. 感谢万有引力,将我拉向你\n5. 爱你,还是更改你,这是一个值得深思的问题\n6. 我曾十步杀一人,却败给你的眼神\n\n<!-- more -->\n\n","source":"_posts/撩妹招数.md","raw":"---\ntitle: 撩妹招数\ndate: 2016-06-05 19:26:22\ncategories: 杂碎\ntags: 情感\n---\n\n1. 江山如此多娇,而我...只为你折腰\n2. 比起欧洲大陆,我更想征服的是你的心\n3. 给我一个支点,让我撬动你的心\n4. 感谢万有引力,将我拉向你\n5. 爱你,还是更改你,这是一个值得深思的问题\n6. 我曾十步杀一人,却败给你的眼神\n\n<!-- more -->\n\n","slug":"撩妹招数","published":1,"updated":"2017-04-28T08:35:32.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6686xna002xxe9zrxu0fue6","content":"<ol>\n<li>江山如此多娇,而我…只为你折腰</li>\n<li>比起欧洲大陆,我更想征服的是你的心</li>\n<li>给我一个支点,让我撬动你的心</li>\n<li>感谢万有引力,将我拉向你</li>\n<li>爱你,还是更改你,这是一个值得深思的问题</li>\n<li>我曾十步杀一人,却败给你的眼神</li>\n</ol>\n<a id=\"more\"></a>\n","site":{"data":{}},"excerpt":"<ol>\n<li>江山如此多娇,而我…只为你折腰</li>\n<li>比起欧洲大陆,我更想征服的是你的心</li>\n<li>给我一个支点,让我撬动你的心</li>\n<li>感谢万有引力,将我拉向你</li>\n<li>爱你,还是更改你,这是一个值得深思的问题</li>\n<li>我曾十步杀一人,却败给你的眼神</li>\n</ol>","more":""},{"title":"着手写一个APP","date":"2016-04-01T14:31:00.000Z","_content":"\n\n最近在写一个APP:\n代码地址:[ONE•一个](https://github.com/shlyren/oneIsAll)\n\n## 未实现的功能\n1. ~~阅读`连载`详情的列表按钮业务~~\n2. ~~阅读的`往期列表`~~\n3. 点击阅读轮播后tableview 下面的图片\n4. 音乐播放\n5. ~~视频播放~~\n6. 评论等需要登录的业务(登录未写)\n7. .....\n\n\n","source":"_posts/着手写一个APP.md","raw":"---\ntitle: 着手写一个APP\ndate: 2016-04-01 22:31:00\ncategories: iOS\ntags: [Objective-C]\n---\n\n\n最近在写一个APP:\n代码地址:[ONE•一个](https://github.com/shlyren/oneIsAll)\n\n## 未实现的功能\n1. ~~阅读`连载`详情的列表按钮业务~~\n2. ~~阅读的`往期列表`~~\n3. 点击阅读轮播后tableview 下面的图片\n4. 音乐播放\n5. ~~视频播放~~\n6. 评论等需要登录的业务(登录未写)\n7. .....\n\n\n","slug":"着手写一个APP","published":1,"updated":"2017-04-28T08:37:09.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6686xnc0031xe9zv1jlzsno","content":"<p>最近在写一个APP:<br>代码地址:<a href=\"https://github.com/shlyren/oneIsAll\" target=\"_blank\" rel=\"external\">ONE•一个</a></p>\n<h2 id=\"未实现的功能\"><a href=\"#未实现的功能\" class=\"headerlink\" title=\"未实现的功能\"></a>未实现的功能</h2><ol>\n<li><del>阅读<code>连载</code>详情的列表按钮业务</del></li>\n<li><del>阅读的<code>往期列表</code></del></li>\n<li>点击阅读轮播后tableview 下面的图片</li>\n<li>音乐播放</li>\n<li><del>视频播放</del></li>\n<li>评论等需要登录的业务(登录未写)</li>\n<li>…..</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>最近在写一个APP:<br>代码地址:<a href=\"https://github.com/shlyren/oneIsAll\" target=\"_blank\" rel=\"external\">ONE•一个</a></p>\n<h2 id=\"未实现的功能\"><a href=\"#未实现的功能\" class=\"headerlink\" title=\"未实现的功能\"></a>未实现的功能</h2><ol>\n<li><del>阅读<code>连载</code>详情的列表按钮业务</del></li>\n<li><del>阅读的<code>往期列表</code></del></li>\n<li>点击阅读轮播后tableview 下面的图片</li>\n<li>音乐播放</li>\n<li><del>视频播放</del></li>\n<li>评论等需要登录的业务(登录未写)</li>\n<li>…..</li>\n</ol>\n"},{"title":"面试题-01","date":"2016-05-23T10:16:23.000Z","_content":"\n## 语法\n### 一、 属性\n1. `readwrite, readonly, assign, retain, copy, nonatomic`属性的作用:\n    `@property`是一个属性访问声明, 括号内支持一下几个属性:\n    * `getter = getterName, setter = setterName`, 设置`setter`与`getter`方法名\n    * `assign`: `setter`方法直接赋值, 不进行任何`retain`操作, 解决原类型与循环引用问题\n    * `retain`: `setter`方法进行copy操作,与`retain`处理流程一样,先`release`旧值,在copy新的对象,`retainCount == 1`. 减少对上下文的依赖而引入的机制. `copy`是在你不希望a和b共享一块内存是会使用到,a和b有个字的内存\n    * `readwrite,readonly`: 设置可访问的级别\n    * `nonatomic`: 非原子性访问,不加同步,多线程并发访问会提高性能, 默认为院子性访问.\n\n<!-- more -->\n\n2. copy\n    * copy使用场景\n        当多个指针指向同一个对象时, 为避免一个指针对对象的改动对其他指针的使用产生影响,使用copy来修饰.\n\n    * 深拷贝、浅拷贝\n        对于非容器内对象,不可变对象进行copy操作为浅拷贝,引用计数器+1,其他\n\n\n\n","source":"_posts/面试题-01.md","raw":"---\ntitle: 面试题-01\ndate: 2016-05-23 18:16:23\ncategories: iOS\ntags: Objective-C\n---\n\n## 语法\n### 一、 属性\n1. `readwrite, readonly, assign, retain, copy, nonatomic`属性的作用:\n    `@property`是一个属性访问声明, 括号内支持一下几个属性:\n    * `getter = getterName, setter = setterName`, 设置`setter`与`getter`方法名\n    * `assign`: `setter`方法直接赋值, 不进行任何`retain`操作, 解决原类型与循环引用问题\n    * `retain`: `setter`方法进行copy操作,与`retain`处理流程一样,先`release`旧值,在copy新的对象,`retainCount == 1`. 减少对上下文的依赖而引入的机制. `copy`是在你不希望a和b共享一块内存是会使用到,a和b有个字的内存\n    * `readwrite,readonly`: 设置可访问的级别\n    * `nonatomic`: 非原子性访问,不加同步,多线程并发访问会提高性能, 默认为院子性访问.\n\n<!-- more -->\n\n2. copy\n    * copy使用场景\n        当多个指针指向同一个对象时, 为避免一个指针对对象的改动对其他指针的使用产生影响,使用copy来修饰.\n\n    * 深拷贝、浅拷贝\n        对于非容器内对象,不可变对象进行copy操作为浅拷贝,引用计数器+1,其他\n\n\n\n","slug":"面试题-01","published":1,"updated":"2017-04-28T08:35:46.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6686xnd0035xe9za03ujnyg","content":"<h2 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h2><h3 id=\"一、-属性\"><a href=\"#一、-属性\" class=\"headerlink\" title=\"一、 属性\"></a>一、 属性</h3><ol>\n<li><code>readwrite, readonly, assign, retain, copy, nonatomic</code>属性的作用:<br> <code>@property</code>是一个属性访问声明, 括号内支持一下几个属性:<ul>\n<li><code>getter = getterName, setter = setterName</code>, 设置<code>setter</code>与<code>getter</code>方法名</li>\n<li><code>assign</code>: <code>setter</code>方法直接赋值, 不进行任何<code>retain</code>操作, 解决原类型与循环引用问题</li>\n<li><code>retain</code>: <code>setter</code>方法进行copy操作,与<code>retain</code>处理流程一样,先<code>release</code>旧值,在copy新的对象,<code>retainCount == 1</code>. 减少对上下文的依赖而引入的机制. <code>copy</code>是在你不希望a和b共享一块内存是会使用到,a和b有个字的内存</li>\n<li><code>readwrite,readonly</code>: 设置可访问的级别</li>\n<li><code>nonatomic</code>: 非原子性访问,不加同步,多线程并发访问会提高性能, 默认为院子性访问.</li>\n</ul>\n</li>\n</ol>\n<a id=\"more\"></a>\n<ol>\n<li><p>copy</p>\n<ul>\n<li><p>copy使用场景<br>  当多个指针指向同一个对象时, 为避免一个指针对对象的改动对其他指针的使用产生影响,使用copy来修饰.</p>\n</li>\n<li><p>深拷贝、浅拷贝<br>  对于非容器内对象,不可变对象进行copy操作为浅拷贝,引用计数器+1,其他</p>\n</li>\n</ul>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"<h2 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h2><h3 id=\"一、-属性\"><a href=\"#一、-属性\" class=\"headerlink\" title=\"一、 属性\"></a>一、 属性</h3><ol>\n<li><code>readwrite, readonly, assign, retain, copy, nonatomic</code>属性的作用:<br> <code>@property</code>是一个属性访问声明, 括号内支持一下几个属性:<ul>\n<li><code>getter = getterName, setter = setterName</code>, 设置<code>setter</code>与<code>getter</code>方法名</li>\n<li><code>assign</code>: <code>setter</code>方法直接赋值, 不进行任何<code>retain</code>操作, 解决原类型与循环引用问题</li>\n<li><code>retain</code>: <code>setter</code>方法进行copy操作,与<code>retain</code>处理流程一样,先<code>release</code>旧值,在copy新的对象,<code>retainCount == 1</code>. 减少对上下文的依赖而引入的机制. <code>copy</code>是在你不希望a和b共享一块内存是会使用到,a和b有个字的内存</li>\n<li><code>readwrite,readonly</code>: 设置可访问的级别</li>\n<li><code>nonatomic</code>: 非原子性访问,不加同步,多线程并发访问会提高性能, 默认为院子性访问.</li>\n</ul>\n</li>\n</ol>","more":"<ol>\n<li><p>copy</p>\n<ul>\n<li><p>copy使用场景<br>  当多个指针指向同一个对象时, 为避免一个指针对对象的改动对其他指针的使用产生影响,使用copy来修饰.</p>\n</li>\n<li><p>深拷贝、浅拷贝<br>  对于非容器内对象,不可变对象进行copy操作为浅拷贝,引用计数器+1,其他</p>\n</li>\n</ul>\n</li>\n</ol>"}],"PostAsset":[],"PostCategory":[{"post_id":"cj6686xkb0000xe9z7qtlvsq1","category_id":"cj6686xkm0004xe9zr20wahse","_id":"cj6686xl2000dxe9zbf6nwj34"},{"post_id":"cj6686xkh0002xe9zzrxi8nli","category_id":"cj6686xky0009xe9zanasb77i","_id":"cj6686xl8000kxe9zfgnxq5wg"},{"post_id":"cj6686xkq0006xe9zf7c5ibrg","category_id":"cj6686xky0009xe9zanasb77i","_id":"cj6686xlb000qxe9zuhqd7ujz"},{"post_id":"cj6686xkt0007xe9zgwnua5mx","category_id":"cj6686xl8000lxe9z214w0yuy","_id":"cj6686xle000wxe9z6w00680t"},{"post_id":"cj6686xku0008xe9z73hjqe3p","category_id":"cj6686xlc000rxe9z9g6dnboy","_id":"cj6686xly0012xe9z8b6fmkwl"},{"post_id":"cj6686xlu000zxe9ze6lati9s","category_id":"cj6686xky0009xe9zanasb77i","_id":"cj6686xm00017xe9zlrb0uw0s"},{"post_id":"cj6686xkz000cxe9zz1sxve06","category_id":"cj6686xlc000rxe9z9g6dnboy","_id":"cj6686xm3001axe9z2fieadss"},{"post_id":"cj6686xlx0011xe9zhc0mbycx","category_id":"cj6686xlc000rxe9z9g6dnboy","_id":"cj6686xm7001fxe9zevbwhtkt"},{"post_id":"cj6686xl3000exe9zlmb7lqnz","category_id":"cj6686xly0014xe9z18mbxkms","_id":"cj6686xma001ixe9zu7yixh7o"},{"post_id":"cj6686xl6000hxe9z1xi23i6o","category_id":"cj6686xlc000rxe9z9g6dnboy","_id":"cj6686xmg001oxe9z5wm8vvza"},{"post_id":"cj6686xl7000jxe9z6tl6i5fc","category_id":"cj6686xlc000rxe9z9g6dnboy","_id":"cj6686xml001uxe9znks55qvu"},{"post_id":"cj6686xmh001pxe9z7x7lwntb","category_id":"cj6686xky0009xe9zanasb77i","_id":"cj6686xmq001zxe9z13xp3po3"},{"post_id":"cj6686xmj001sxe9z8xjno3fe","category_id":"cj6686xly0014xe9z18mbxkms","_id":"cj6686xmt0022xe9z6l9qq4b3"},{"post_id":"cj6686xl9000nxe9zz6yucg5z","category_id":"cj6686xlc000rxe9z9g6dnboy","_id":"cj6686xmv0027xe9zvwma51yg"},{"post_id":"cj6686xml001vxe9zese60i4z","category_id":"cj6686xlc000rxe9z9g6dnboy","_id":"cj6686xmz002axe9zhnxl4efm"},{"post_id":"cj6686xmq0020xe9z02vuj32r","category_id":"cj6686xkm0004xe9zr20wahse","_id":"cj6686xn2002fxe9zmro4h8bp"},{"post_id":"cj6686xla000pxe9z4qbove1i","category_id":"cj6686xly0014xe9z18mbxkms","_id":"cj6686xn3002hxe9ztidp3501"},{"post_id":"cj6686xlc000txe9zdripquqh","category_id":"cj6686xmv0024xe9zo112osoc","_id":"cj6686xn6002kxe9z7assfn1k"},{"post_id":"cj6686xn2002gxe9z7jzjyvmd","category_id":"cj6686xn1002dxe9ztwgm0xje","_id":"cj6686xn7002oxe9z0c6d7qh0"},{"post_id":"cj6686xld000vxe9z3g8rqlkh","category_id":"cj6686xn1002dxe9ztwgm0xje","_id":"cj6686xn8002sxe9z40i1onok"},{"post_id":"cj6686xn3002ixe9zgfydnmju","category_id":"cj6686xky0009xe9zanasb77i","_id":"cj6686xna002wxe9zibrg872h"},{"post_id":"cj6686xn6002mxe9z9t9akzp4","category_id":"cj6686xn1002dxe9ztwgm0xje","_id":"cj6686xnb0030xe9zr5f3jfd3"},{"post_id":"cj6686xlz0016xe9z53jjjpj4","category_id":"cj6686xn1002dxe9ztwgm0xje","_id":"cj6686xnc0034xe9z5vx98y8q"},{"post_id":"cj6686xn7002pxe9zr8jyppx5","category_id":"cj6686xlc000rxe9z9g6dnboy","_id":"cj6686xnf0038xe9zkc2a69de"},{"post_id":"cj6686xn8002txe9ztb5ts1g4","category_id":"cj6686xkm0004xe9zr20wahse","_id":"cj6686xnh003bxe9zqq8a8auq"},{"post_id":"cj6686xm10019xe9zj302ws47","category_id":"cj6686xn1002dxe9ztwgm0xje","_id":"cj6686xnh003exe9z29ovuey1"},{"post_id":"cj6686xna002xxe9zrxu0fue6","category_id":"cj6686xkm0004xe9zr20wahse","_id":"cj6686xni003hxe9zp9axnvzq"},{"post_id":"cj6686xnc0031xe9zv1jlzsno","category_id":"cj6686xlc000rxe9z9g6dnboy","_id":"cj6686xni003kxe9zlgwef6nd"},{"post_id":"cj6686xm4001cxe9z1iylg3z3","category_id":"cj6686xn1002dxe9ztwgm0xje","_id":"cj6686xnj003nxe9zffu129gd"},{"post_id":"cj6686xnd0035xe9za03ujnyg","category_id":"cj6686xlc000rxe9z9g6dnboy","_id":"cj6686xnm003qxe9z38bitx39"},{"post_id":"cj6686xm7001hxe9z7rketmo4","category_id":"cj6686xn1002dxe9ztwgm0xje","_id":"cj6686xnn003rxe9zyeelcheq"},{"post_id":"cj6686xma001jxe9z2ijqx018","category_id":"cj6686xn1002dxe9ztwgm0xje","_id":"cj6686xnp003vxe9zvd501zs3"},{"post_id":"cj6686xmf001mxe9zyxagdft3","category_id":"cj6686xni003ixe9zukjba7oj","_id":"cj6686xnp003wxe9z5m50azlq"},{"post_id":"cj6686xmu0023xe9zo7q8jwx4","category_id":"cj6686xmv0024xe9zo112osoc","_id":"cj6686xnq003zxe9zlwz4l48e"},{"post_id":"cj6686xmw0028xe9zepi3s0wj","category_id":"cj6686xn1002dxe9ztwgm0xje","_id":"cj6686xnr0042xe9zlesommme"},{"post_id":"cj6686xmz002bxe9zrarsy2w3","category_id":"cj6686xn1002dxe9ztwgm0xje","_id":"cj6686xns0046xe9zpwxtpd1f"}],"PostTag":[{"post_id":"cj6686xkb0000xe9z7qtlvsq1","tag_id":"cj6686xkp0005xe9zb1yead2y","_id":"cj6686xkz000bxe9zofgfa1ag"},{"post_id":"cj6686xkh0002xe9zzrxi8nli","tag_id":"cj6686xky000axe9zpuchmj7t","_id":"cj6686xl6000ixe9zfutj5ph7"},{"post_id":"cj6686xkq0006xe9zf7c5ibrg","tag_id":"cj6686xky000axe9zpuchmj7t","_id":"cj6686xla000oxe9z589gtubv"},{"post_id":"cj6686xkt0007xe9zgwnua5mx","tag_id":"cj6686xl8000mxe9zoz2b3ovx","_id":"cj6686xld000uxe9z4hnl9cev"},{"post_id":"cj6686xku0008xe9z73hjqe3p","tag_id":"cj6686xlc000sxe9zdtbln8tc","_id":"cj6686xlw0010xe9zf14732i5"},{"post_id":"cj6686xlu000zxe9ze6lati9s","tag_id":"cj6686xky000axe9zpuchmj7t","_id":"cj6686xly0013xe9zwpmi3gwt"},{"post_id":"cj6686xkz000cxe9zz1sxve06","tag_id":"cj6686xlc000sxe9zdtbln8tc","_id":"cj6686xm00018xe9zhuqmmte7"},{"post_id":"cj6686xlx0011xe9zhc0mbycx","tag_id":"cj6686xlc000sxe9zdtbln8tc","_id":"cj6686xm3001bxe9zanfn4s8k"},{"post_id":"cj6686xl3000exe9zlmb7lqnz","tag_id":"cj6686xlz0015xe9zcy8eej6m","_id":"cj6686xm7001gxe9zk1582qy3"},{"post_id":"cj6686xl6000hxe9z1xi23i6o","tag_id":"cj6686xm5001exe9z49acobes","_id":"cj6686xmg001nxe9z1bltc45r"},{"post_id":"cj6686xl7000jxe9z6tl6i5fc","tag_id":"cj6686xm5001exe9z49acobes","_id":"cj6686xmk001txe9zhypqe7d5"},{"post_id":"cj6686xmh001pxe9z7x7lwntb","tag_id":"cj6686xky000axe9zpuchmj7t","_id":"cj6686xmn001xxe9zk8px5l3g"},{"post_id":"cj6686xmj001sxe9z8xjno3fe","tag_id":"cj6686xlz0015xe9zcy8eej6m","_id":"cj6686xmt0021xe9zbwg7s20u"},{"post_id":"cj6686xl9000nxe9zz6yucg5z","tag_id":"cj6686xm5001exe9z49acobes","_id":"cj6686xmv0025xe9zh7wity1y"},{"post_id":"cj6686xml001vxe9zese60i4z","tag_id":"cj6686xlc000sxe9zdtbln8tc","_id":"cj6686xmy0029xe9z2gfgkaqf"},{"post_id":"cj6686xla000pxe9z4qbove1i","tag_id":"cj6686xlz0015xe9zcy8eej6m","_id":"cj6686xn1002cxe9zmnwixrda"},{"post_id":"cj6686xlc000txe9zdripquqh","tag_id":"cj6686xmv0026xe9zaf1c44ue","_id":"cj6686xn7002nxe9z6afmd2rq"},{"post_id":"cj6686xlc000txe9zdripquqh","tag_id":"cj6686xn1002exe9zz3nwjo8e","_id":"cj6686xn8002rxe9zz98yfsmu"},{"post_id":"cj6686xn3002ixe9zgfydnmju","tag_id":"cj6686xky000axe9zpuchmj7t","_id":"cj6686xna002vxe9zm11cwf8k"},{"post_id":"cj6686xn7002pxe9zr8jyppx5","tag_id":"cj6686xlc000sxe9zdtbln8tc","_id":"cj6686xnb002zxe9z2d7xoncl"},{"post_id":"cj6686xld000vxe9z3g8rqlkh","tag_id":"cj6686xn6002lxe9zmbcly1r9","_id":"cj6686xnc0033xe9ztes4nl09"},{"post_id":"cj6686xna002xxe9zrxu0fue6","tag_id":"cj6686xkp0005xe9zb1yead2y","_id":"cj6686xne0037xe9z9jdb27jy"},{"post_id":"cj6686xm10019xe9zj302ws47","tag_id":"cj6686xn9002uxe9z7nxy4p49","_id":"cj6686xng003axe9zvpbsl4dc"},{"post_id":"cj6686xnc0031xe9zv1jlzsno","tag_id":"cj6686xlc000sxe9zdtbln8tc","_id":"cj6686xnh003dxe9z7ucoek18"},{"post_id":"cj6686xnd0035xe9za03ujnyg","tag_id":"cj6686xlc000sxe9zdtbln8tc","_id":"cj6686xni003gxe9z1x8ssaga"},{"post_id":"cj6686xm4001cxe9z1iylg3z3","tag_id":"cj6686xnc0032xe9zpowu4lv8","_id":"cj6686xni003jxe9zqsdze7xq"},{"post_id":"cj6686xm7001hxe9z7rketmo4","tag_id":"cj6686xnc0032xe9zpowu4lv8","_id":"cj6686xnj003mxe9zqh43twlh"},{"post_id":"cj6686xma001jxe9z2ijqx018","tag_id":"cj6686xn9002uxe9z7nxy4p49","_id":"cj6686xnl003oxe9zznj7t5q0"},{"post_id":"cj6686xmf001mxe9zyxagdft3","tag_id":"cj6686xni003lxe9z99obkeqn","_id":"cj6686xno003txe9zx6wyfnyn"},{"post_id":"cj6686xmq0020xe9z02vuj32r","tag_id":"cj6686xnn003sxe9zwp394e2x","_id":"cj6686xnq0040xe9zvq7yzdh1"},{"post_id":"cj6686xmu0023xe9zo7q8jwx4","tag_id":"cj6686xlz0015xe9zcy8eej6m","_id":"cj6686xnr0043xe9za6vvqa31"},{"post_id":"cj6686xmu0023xe9zo7q8jwx4","tag_id":"cj6686xn1002exe9zz3nwjo8e","_id":"cj6686xnr0044xe9zlktgejqj"},{"post_id":"cj6686xmw0028xe9zepi3s0wj","tag_id":"cj6686xn6002lxe9zmbcly1r9","_id":"cj6686xns0047xe9zdd70w0va"},{"post_id":"cj6686xmw0028xe9zepi3s0wj","tag_id":"cj6686xlz0015xe9zcy8eej6m","_id":"cj6686xns0048xe9z9he7oboc"},{"post_id":"cj6686xmz002bxe9zrarsy2w3","tag_id":"cj6686xns0045xe9zvyrw2ox4","_id":"cj6686xnt004axe9z6v09nzxo"},{"post_id":"cj6686xn2002gxe9z7jzjyvmd","tag_id":"cj6686xlz0015xe9zcy8eej6m","_id":"cj6686xnt004cxe9zxj9xcimx"},{"post_id":"cj6686xn2002gxe9z7jzjyvmd","tag_id":"cj6686xns0049xe9z8rl99hmr","_id":"cj6686xnt004dxe9zvyuqrm8q"},{"post_id":"cj6686xn6002mxe9z9t9akzp4","tag_id":"cj6686xnt004bxe9zkav9kjnf","_id":"cj6686xnu004exe9zn1u28a1d"}],"Tag":[{"name":"情感","_id":"cj6686xkp0005xe9zb1yead2y"},{"name":"Android","_id":"cj6686xky000axe9zpuchmj7t"},{"name":"C语言","_id":"cj6686xl8000mxe9zoz2b3ovx"},{"name":"Objective-C","_id":"cj6686xlc000sxe9zdtbln8tc"},{"name":"命令","_id":"cj6686xlz0015xe9zcy8eej6m"},{"name":"Swift","_id":"cj6686xm5001exe9z49acobes"},{"name":"Xcode","_id":"cj6686xmv0026xe9zaf1c44ue"},{"name":"error","_id":"cj6686xn1002exe9zz3nwjo8e"},{"name":"教程","_id":"cj6686xn6002lxe9zmbcly1r9"},{"name":"教程 翻墙","_id":"cj6686xn9002uxe9z7nxy4p49"},{"name":"教程 Hexo","_id":"cj6686xnc0032xe9zpowu4lv8"},{"name":"javaScript html","_id":"cj6686xni003lxe9z99obkeqn"},{"name":"杂碎","_id":"cj6686xnn003sxe9zwp394e2x"},{"name":"CocoaPods","_id":"cj6686xns0045xe9zvyrw2ox4"},{"name":"MacOS","_id":"cj6686xns0049xe9z8rl99hmr"},{"name":"教程 MacOS","_id":"cj6686xnt004bxe9zkav9kjnf"}]}}